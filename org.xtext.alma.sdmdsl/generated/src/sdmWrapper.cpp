/*
 * ALMA - Atacama Large Millimeter Array
 * (c) European Southern Observatory, 2002
 * (c) Associated Universities Inc., 2002
 * Copyright by ESO (in the framework of the ALMA collaboration),
 * Copyright by AUI (in the framework of the ALMA collaboration),
 * All rights reserved.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY, without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307  USA
 *
 * File sdmWrapper.cpp
 */

#include <iostream>
#include <string.h>
#include <dirent.h>
  
using namespace std;
 
#include <ASDMAll.h>
// *** binaries not included at this time... ***
//#include "SDMBinaryBlock.h"
//#include "SDMBinaryExceptions.h"
//#include "TPBinaryBlock.h"
//using namespace asdmBinary;
// *** binaries not included at this time... ***
using namespace asdm;

#undef max
#define max(a,b) ((a) > (b) ? (a) : (b))
#undef min
#define min(a,b) ((a) < (b) ? (a) : (b))
  
#define sdm_init  sdm_init_
#define sdm_write sdm_write_
#define sdm_close sdm_close_
#define sdm_getbinary sdm_getbinary_
#define sdm_writebinary sdm_writebinary_
#define sdm_getTPbinary sdm_gettpbinary_
#define sdm_writeTPbinary sdm_writetpbinary_


#define sdm_addMainRow sdm_addmainrow_
#define sdm_getMainRow sdm_getmainrow_
#define sdm_getMainTableSize sdm_getmaintablesize_
#define sdm_getMainKeys sdm_getmainkeys_
#define sdm_addAlmaRadiometerRow sdm_addalmaradiometerrow_
#define sdm_getAlmaRadiometerRow sdm_getalmaradiometerrow_
#define sdm_getAlmaRadiometerTableSize sdm_getalmaradiometertablesize_
#define sdm_getAlmaRadiometerKeys sdm_getalmaradiometerkeys_
#define sdm_addAnnotationRow sdm_addannotationrow_
#define sdm_getAnnotationRow sdm_getannotationrow_
#define sdm_getAnnotationTableSize sdm_getannotationtablesize_
#define sdm_getAnnotationKeys sdm_getannotationkeys_
#define sdm_addAntennaRow sdm_addantennarow_
#define sdm_getAntennaRow sdm_getantennarow_
#define sdm_getAntennaTableSize sdm_getantennatablesize_
#define sdm_getAntennaKeys sdm_getantennakeys_
#define sdm_addCalAmpliRow sdm_addcalamplirow_
#define sdm_getCalAmpliRow sdm_getcalamplirow_
#define sdm_getCalAmpliTableSize sdm_getcalamplitablesize_
#define sdm_getCalAmpliKeys sdm_getcalamplikeys_
#define sdm_addCalAppPhaseRow sdm_addcalappphaserow_
#define sdm_getCalAppPhaseRow sdm_getcalappphaserow_
#define sdm_getCalAppPhaseTableSize sdm_getcalappphasetablesize_
#define sdm_getCalAppPhaseKeys sdm_getcalappphasekeys_
#define sdm_addCalAtmosphereRow sdm_addcalatmosphererow_
#define sdm_getCalAtmosphereRow sdm_getcalatmosphererow_
#define sdm_getCalAtmosphereTableSize sdm_getcalatmospheretablesize_
#define sdm_getCalAtmosphereKeys sdm_getcalatmospherekeys_
#define sdm_addCalBandpassRow sdm_addcalbandpassrow_
#define sdm_getCalBandpassRow sdm_getcalbandpassrow_
#define sdm_getCalBandpassTableSize sdm_getcalbandpasstablesize_
#define sdm_getCalBandpassKeys sdm_getcalbandpasskeys_
#define sdm_addCalCurveRow sdm_addcalcurverow_
#define sdm_getCalCurveRow sdm_getcalcurverow_
#define sdm_getCalCurveTableSize sdm_getcalcurvetablesize_
#define sdm_getCalCurveKeys sdm_getcalcurvekeys_
#define sdm_addCalDataRow sdm_addcaldatarow_
#define sdm_getCalDataRow sdm_getcaldatarow_
#define sdm_getCalDataTableSize sdm_getcaldatatablesize_
#define sdm_getCalDataKeys sdm_getcaldatakeys_
#define sdm_addCalDelayRow sdm_addcaldelayrow_
#define sdm_getCalDelayRow sdm_getcaldelayrow_
#define sdm_getCalDelayTableSize sdm_getcaldelaytablesize_
#define sdm_getCalDelayKeys sdm_getcaldelaykeys_
#define sdm_addCalDeviceRow sdm_addcaldevicerow_
#define sdm_getCalDeviceRow sdm_getcaldevicerow_
#define sdm_getCalDeviceTableSize sdm_getcaldevicetablesize_
#define sdm_getCalDeviceKeys sdm_getcaldevicekeys_
#define sdm_addCalFluxRow sdm_addcalfluxrow_
#define sdm_getCalFluxRow sdm_getcalfluxrow_
#define sdm_getCalFluxTableSize sdm_getcalfluxtablesize_
#define sdm_getCalFluxKeys sdm_getcalfluxkeys_
#define sdm_addCalFocusRow sdm_addcalfocusrow_
#define sdm_getCalFocusRow sdm_getcalfocusrow_
#define sdm_getCalFocusTableSize sdm_getcalfocustablesize_
#define sdm_getCalFocusKeys sdm_getcalfocuskeys_
#define sdm_addCalFocusModelRow sdm_addcalfocusmodelrow_
#define sdm_getCalFocusModelRow sdm_getcalfocusmodelrow_
#define sdm_getCalFocusModelTableSize sdm_getcalfocusmodeltablesize_
#define sdm_getCalFocusModelKeys sdm_getcalfocusmodelkeys_
#define sdm_addCalGainRow sdm_addcalgainrow_
#define sdm_getCalGainRow sdm_getcalgainrow_
#define sdm_getCalGainTableSize sdm_getcalgaintablesize_
#define sdm_getCalGainKeys sdm_getcalgainkeys_
#define sdm_addCalHolographyRow sdm_addcalholographyrow_
#define sdm_getCalHolographyRow sdm_getcalholographyrow_
#define sdm_getCalHolographyTableSize sdm_getcalholographytablesize_
#define sdm_getCalHolographyKeys sdm_getcalholographykeys_
#define sdm_addCalPhaseRow sdm_addcalphaserow_
#define sdm_getCalPhaseRow sdm_getcalphaserow_
#define sdm_getCalPhaseTableSize sdm_getcalphasetablesize_
#define sdm_getCalPhaseKeys sdm_getcalphasekeys_
#define sdm_addCalPointingRow sdm_addcalpointingrow_
#define sdm_getCalPointingRow sdm_getcalpointingrow_
#define sdm_getCalPointingTableSize sdm_getcalpointingtablesize_
#define sdm_getCalPointingKeys sdm_getcalpointingkeys_
#define sdm_addCalPointingModelRow sdm_addcalpointingmodelrow_
#define sdm_getCalPointingModelRow sdm_getcalpointingmodelrow_
#define sdm_getCalPointingModelTableSize sdm_getcalpointingmodeltablesize_
#define sdm_getCalPointingModelKeys sdm_getcalpointingmodelkeys_
#define sdm_addCalPositionRow sdm_addcalpositionrow_
#define sdm_getCalPositionRow sdm_getcalpositionrow_
#define sdm_getCalPositionTableSize sdm_getcalpositiontablesize_
#define sdm_getCalPositionKeys sdm_getcalpositionkeys_
#define sdm_addCalPrimaryBeamRow sdm_addcalprimarybeamrow_
#define sdm_getCalPrimaryBeamRow sdm_getcalprimarybeamrow_
#define sdm_getCalPrimaryBeamTableSize sdm_getcalprimarybeamtablesize_
#define sdm_getCalPrimaryBeamKeys sdm_getcalprimarybeamkeys_
#define sdm_addCalReductionRow sdm_addcalreductionrow_
#define sdm_getCalReductionRow sdm_getcalreductionrow_
#define sdm_getCalReductionTableSize sdm_getcalreductiontablesize_
#define sdm_getCalReductionKeys sdm_getcalreductionkeys_
#define sdm_addCalSeeingRow sdm_addcalseeingrow_
#define sdm_getCalSeeingRow sdm_getcalseeingrow_
#define sdm_getCalSeeingTableSize sdm_getcalseeingtablesize_
#define sdm_getCalSeeingKeys sdm_getcalseeingkeys_
#define sdm_addCalWVRRow sdm_addcalwvrrow_
#define sdm_getCalWVRRow sdm_getcalwvrrow_
#define sdm_getCalWVRTableSize sdm_getcalwvrtablesize_
#define sdm_getCalWVRKeys sdm_getcalwvrkeys_
#define sdm_addConfigDescriptionRow sdm_addconfigdescriptionrow_
#define sdm_getConfigDescriptionRow sdm_getconfigdescriptionrow_
#define sdm_getConfigDescriptionTableSize sdm_getconfigdescriptiontablesize_
#define sdm_getConfigDescriptionKeys sdm_getconfigdescriptionkeys_
#define sdm_addCorrelatorModeRow sdm_addcorrelatormoderow_
#define sdm_getCorrelatorModeRow sdm_getcorrelatormoderow_
#define sdm_getCorrelatorModeTableSize sdm_getcorrelatormodetablesize_
#define sdm_getCorrelatorModeKeys sdm_getcorrelatormodekeys_
#define sdm_addDataDescriptionRow sdm_adddatadescriptionrow_
#define sdm_getDataDescriptionRow sdm_getdatadescriptionrow_
#define sdm_getDataDescriptionTableSize sdm_getdatadescriptiontablesize_
#define sdm_getDataDescriptionKeys sdm_getdatadescriptionkeys_
#define sdm_addDelayModelRow sdm_adddelaymodelrow_
#define sdm_getDelayModelRow sdm_getdelaymodelrow_
#define sdm_getDelayModelTableSize sdm_getdelaymodeltablesize_
#define sdm_getDelayModelKeys sdm_getdelaymodelkeys_
#define sdm_addDelayModelFixedParametersRow sdm_adddelaymodelfixedparametersrow_
#define sdm_getDelayModelFixedParametersRow sdm_getdelaymodelfixedparametersrow_
#define sdm_getDelayModelFixedParametersTableSize sdm_getdelaymodelfixedparameterstablesize_
#define sdm_getDelayModelFixedParametersKeys sdm_getdelaymodelfixedparameterskeys_
#define sdm_addDelayModelVariableParametersRow sdm_adddelaymodelvariableparametersrow_
#define sdm_getDelayModelVariableParametersRow sdm_getdelaymodelvariableparametersrow_
#define sdm_getDelayModelVariableParametersTableSize sdm_getdelaymodelvariableparameterstablesize_
#define sdm_getDelayModelVariableParametersKeys sdm_getdelaymodelvariableparameterskeys_
#define sdm_addDopplerRow sdm_adddopplerrow_
#define sdm_getDopplerRow sdm_getdopplerrow_
#define sdm_getDopplerTableSize sdm_getdopplertablesize_
#define sdm_getDopplerKeys sdm_getdopplerkeys_
#define sdm_addEphemerisRow sdm_addephemerisrow_
#define sdm_getEphemerisRow sdm_getephemerisrow_
#define sdm_getEphemerisTableSize sdm_getephemeristablesize_
#define sdm_getEphemerisKeys sdm_getephemeriskeys_
#define sdm_addExecBlockRow sdm_addexecblockrow_
#define sdm_getExecBlockRow sdm_getexecblockrow_
#define sdm_getExecBlockTableSize sdm_getexecblocktablesize_
#define sdm_getExecBlockKeys sdm_getexecblockkeys_
#define sdm_addFeedRow sdm_addfeedrow_
#define sdm_getFeedRow sdm_getfeedrow_
#define sdm_getFeedTableSize sdm_getfeedtablesize_
#define sdm_getFeedKeys sdm_getfeedkeys_
#define sdm_addFieldRow sdm_addfieldrow_
#define sdm_getFieldRow sdm_getfieldrow_
#define sdm_getFieldTableSize sdm_getfieldtablesize_
#define sdm_getFieldKeys sdm_getfieldkeys_
#define sdm_addFlagRow sdm_addflagrow_
#define sdm_getFlagRow sdm_getflagrow_
#define sdm_getFlagTableSize sdm_getflagtablesize_
#define sdm_getFlagKeys sdm_getflagkeys_
#define sdm_addFlagCmdRow sdm_addflagcmdrow_
#define sdm_getFlagCmdRow sdm_getflagcmdrow_
#define sdm_getFlagCmdTableSize sdm_getflagcmdtablesize_
#define sdm_getFlagCmdKeys sdm_getflagcmdkeys_
#define sdm_addFocusRow sdm_addfocusrow_
#define sdm_getFocusRow sdm_getfocusrow_
#define sdm_getFocusTableSize sdm_getfocustablesize_
#define sdm_getFocusKeys sdm_getfocuskeys_
#define sdm_addFocusModelRow sdm_addfocusmodelrow_
#define sdm_getFocusModelRow sdm_getfocusmodelrow_
#define sdm_getFocusModelTableSize sdm_getfocusmodeltablesize_
#define sdm_getFocusModelKeys sdm_getfocusmodelkeys_
#define sdm_addFreqOffsetRow sdm_addfreqoffsetrow_
#define sdm_getFreqOffsetRow sdm_getfreqoffsetrow_
#define sdm_getFreqOffsetTableSize sdm_getfreqoffsettablesize_
#define sdm_getFreqOffsetKeys sdm_getfreqoffsetkeys_
#define sdm_addGainTrackingRow sdm_addgaintrackingrow_
#define sdm_getGainTrackingRow sdm_getgaintrackingrow_
#define sdm_getGainTrackingTableSize sdm_getgaintrackingtablesize_
#define sdm_getGainTrackingKeys sdm_getgaintrackingkeys_
#define sdm_addHistoryRow sdm_addhistoryrow_
#define sdm_getHistoryRow sdm_gethistoryrow_
#define sdm_getHistoryTableSize sdm_gethistorytablesize_
#define sdm_getHistoryKeys sdm_gethistorykeys_
#define sdm_addHolographyRow sdm_addholographyrow_
#define sdm_getHolographyRow sdm_getholographyrow_
#define sdm_getHolographyTableSize sdm_getholographytablesize_
#define sdm_getHolographyKeys sdm_getholographykeys_
#define sdm_addObservationRow sdm_addobservationrow_
#define sdm_getObservationRow sdm_getobservationrow_
#define sdm_getObservationTableSize sdm_getobservationtablesize_
#define sdm_getObservationKeys sdm_getobservationkeys_
#define sdm_addPointingRow sdm_addpointingrow_
#define sdm_getPointingRow sdm_getpointingrow_
#define sdm_getPointingTableSize sdm_getpointingtablesize_
#define sdm_getPointingKeys sdm_getpointingkeys_
#define sdm_addPointingModelRow sdm_addpointingmodelrow_
#define sdm_getPointingModelRow sdm_getpointingmodelrow_
#define sdm_getPointingModelTableSize sdm_getpointingmodeltablesize_
#define sdm_getPointingModelKeys sdm_getpointingmodelkeys_
#define sdm_addPolarizationRow sdm_addpolarizationrow_
#define sdm_getPolarizationRow sdm_getpolarizationrow_
#define sdm_getPolarizationTableSize sdm_getpolarizationtablesize_
#define sdm_getPolarizationKeys sdm_getpolarizationkeys_
#define sdm_addProcessorRow sdm_addprocessorrow_
#define sdm_getProcessorRow sdm_getprocessorrow_
#define sdm_getProcessorTableSize sdm_getprocessortablesize_
#define sdm_getProcessorKeys sdm_getprocessorkeys_
#define sdm_addReceiverRow sdm_addreceiverrow_
#define sdm_getReceiverRow sdm_getreceiverrow_
#define sdm_getReceiverTableSize sdm_getreceivertablesize_
#define sdm_getReceiverKeys sdm_getreceiverkeys_
#define sdm_addSBSummaryRow sdm_addsbsummaryrow_
#define sdm_getSBSummaryRow sdm_getsbsummaryrow_
#define sdm_getSBSummaryTableSize sdm_getsbsummarytablesize_
#define sdm_getSBSummaryKeys sdm_getsbsummarykeys_
#define sdm_addScaleRow sdm_addscalerow_
#define sdm_getScaleRow sdm_getscalerow_
#define sdm_getScaleTableSize sdm_getscaletablesize_
#define sdm_getScaleKeys sdm_getscalekeys_
#define sdm_addScanRow sdm_addscanrow_
#define sdm_getScanRow sdm_getscanrow_
#define sdm_getScanTableSize sdm_getscantablesize_
#define sdm_getScanKeys sdm_getscankeys_
#define sdm_addSeeingRow sdm_addseeingrow_
#define sdm_getSeeingRow sdm_getseeingrow_
#define sdm_getSeeingTableSize sdm_getseeingtablesize_
#define sdm_getSeeingKeys sdm_getseeingkeys_
#define sdm_addSourceRow sdm_addsourcerow_
#define sdm_getSourceRow sdm_getsourcerow_
#define sdm_getSourceTableSize sdm_getsourcetablesize_
#define sdm_getSourceKeys sdm_getsourcekeys_
#define sdm_addSpectralWindowRow sdm_addspectralwindowrow_
#define sdm_getSpectralWindowRow sdm_getspectralwindowrow_
#define sdm_getSpectralWindowTableSize sdm_getspectralwindowtablesize_
#define sdm_getSpectralWindowKeys sdm_getspectralwindowkeys_
#define sdm_addSquareLawDetectorRow sdm_addsquarelawdetectorrow_
#define sdm_getSquareLawDetectorRow sdm_getsquarelawdetectorrow_
#define sdm_getSquareLawDetectorTableSize sdm_getsquarelawdetectortablesize_
#define sdm_getSquareLawDetectorKeys sdm_getsquarelawdetectorkeys_
#define sdm_addStateRow sdm_addstaterow_
#define sdm_getStateRow sdm_getstaterow_
#define sdm_getStateTableSize sdm_getstatetablesize_
#define sdm_getStateKeys sdm_getstatekeys_
#define sdm_addStationRow sdm_addstationrow_
#define sdm_getStationRow sdm_getstationrow_
#define sdm_getStationTableSize sdm_getstationtablesize_
#define sdm_getStationKeys sdm_getstationkeys_
#define sdm_addSubscanRow sdm_addsubscanrow_
#define sdm_getSubscanRow sdm_getsubscanrow_
#define sdm_getSubscanTableSize sdm_getsubscantablesize_
#define sdm_getSubscanKeys sdm_getsubscankeys_
#define sdm_addSwitchCycleRow sdm_addswitchcyclerow_
#define sdm_getSwitchCycleRow sdm_getswitchcyclerow_
#define sdm_getSwitchCycleTableSize sdm_getswitchcycletablesize_
#define sdm_getSwitchCycleKeys sdm_getswitchcyclekeys_
#define sdm_addSysCalRow sdm_addsyscalrow_
#define sdm_getSysCalRow sdm_getsyscalrow_
#define sdm_getSysCalTableSize sdm_getsyscaltablesize_
#define sdm_getSysCalKeys sdm_getsyscalkeys_
#define sdm_addSysPowerRow sdm_addsyspowerrow_
#define sdm_getSysPowerRow sdm_getsyspowerrow_
#define sdm_getSysPowerTableSize sdm_getsyspowertablesize_
#define sdm_getSysPowerKeys sdm_getsyspowerkeys_
#define sdm_addTotalPowerRow sdm_addtotalpowerrow_
#define sdm_getTotalPowerRow sdm_gettotalpowerrow_
#define sdm_getTotalPowerTableSize sdm_gettotalpowertablesize_
#define sdm_getTotalPowerKeys sdm_gettotalpowerkeys_
#define sdm_addWVMCalRow sdm_addwvmcalrow_
#define sdm_getWVMCalRow sdm_getwvmcalrow_
#define sdm_getWVMCalTableSize sdm_getwvmcaltablesize_
#define sdm_getWVMCalKeys sdm_getwvmcalkeys_
#define sdm_addWeatherRow sdm_addweatherrow_
#define sdm_getWeatherRow sdm_getweatherrow_
#define sdm_getWeatherTableSize sdm_getweathertablesize_
#define sdm_getWeatherKeys sdm_getweatherkeys_

extern "C" void sdm_init(char *, bool *);
extern "C" void sdm_write();
extern "C" void sdm_close();

namespace asdm {    
  /**
   * This class is derived from the pure virtual class BinaryAttributeReaderFunctor.
   *
   * It implements the behaviour of the reading machinery when a simple boolean
   * value has to be read . 
   * In our case , the behaviour is reduced to one simple thing : just
   * read one boolean value out of  the EndianIStream.
   */
  class BinaryBooleanAttributeReader : public BinaryAttributeReaderFunctor { 
  private:
    bool value;
  public:
    virtual void operator() (EndianIStream& eis);   
    virtual ~BinaryBooleanAttributeReader();
  };
  void BinaryBooleanAttributeReader::operator()(EndianIStream& eis) {
    value = eis.readBoolean();                                          
  }
  BinaryBooleanAttributeReader::~BinaryBooleanAttributeReader() {;}                          
};

ASDM * dataset;
string datasetDirectory;  


//----------------------------------------------------------------------------

void sdm_init(char * directoryName, bool * error) {
  *error = false;

  // Read from directory
  // cout<<"directoryName="<<directoryName<<endl;
  datasetDirectory=string(directoryName);

  try {
    dataset=0;
    // Check if directory exists and then, if ASDM.xml exists
    if (opendir(directoryName)!=NULL) {
      string asdmFile= datasetDirectory+"/ASDM.xml";
      if (fopen(asdmFile.c_str(),"r")!=NULL) {
	// dataset = ASDM::getFromXML(datasetDirectory);
	dataset = new ASDM();
	// We want to define what has to be done when the TotalPower is read as a binary document and  an attribute "flagRow" is met 
	// that we want to just to skip.
	BinaryBooleanAttributeReader bbar;
	
	// Attach the behaviour defined in bbar to the attribute "flagRow" in the totalpower table.
	//
	TotalPowerTable& tpT = dataset->getTotalPower();
	const string unknownAttributeName("flagRow");
	// Call bbar functor each time the attribute flagRow is met . 
	tpT.setUnknownAttributeBinaryReader(unknownAttributeName, &bbar);  
	dataset->setFromFile(datasetDirectory);
	// cout<<"Dataset initialized from "<<datasetDirectory<<endl;
	     }
	   } else {
	     cout<<"Directory "<<datasetDirectory<<" does not exist"<<endl;
	   }
	 }
	 catch (ConversionException e) {
	 	cout << e.getMessage() << endl;
	 }

  if (dataset==0) {
    cout<<"Create new dataset in "<<datasetDirectory<<endl;
    dataset = new ASDM();
  }
  return;
}
//----------------------------------------------------------------------------

void sdm_write() {
  cout<<"sdm_write()"<<endl;
  if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return;
  }

  try {
    dataset->toFile(datasetDirectory);
    cout << "The dataset has been saved in the directory " << datasetDirectory << endl;
  }
  catch (ConversionException e) {
    cout << e.getMessage() << endl;
  }
}
//----------------------------------------------------------------------------

void sdm_close() {
    // cout<<"sdm_close()"<<endl;
//   dataset->toXML(datasetDirectory);
//   cout << "The dataset has been saved in the directory " << datasetDirectory << endl;
  delete dataset;
  dataset = 0;
}

//----------------------------------------------------------------------------









// =================== AlmaRadiometerTable ============================

extern "C" int sdm_addAlmaRadiometerRow ();
extern "C" int sdm_getAlmaRadiometerRow (int * almaRadiometerId);


extern "C" int sdm_getAlmaRadiometerTableSize ();

extern "C" int sdm_getAlmaRadiometerKeys (int * almaRadiometerId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addAlmaRadiometerRow (){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	AlmaRadiometerTable &table = dataset->getAlmaRadiometer();
	AlmaRadiometerRow *row = 0;

	
	// Create new row
  
	row = table.newRow();

	// Add row
	AlmaRadiometerRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the AlmaRadiometerTable" << endl;
	}
	
	// return atoi((retRow->getAlmaRadiometerId().getId()).c_str());
	return retRow->getAlmaRadiometerId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a AlmaRadiometerRow* given a key.
 */
int sdm_getAlmaRadiometerRow (int * almaRadiometerId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AlmaRadiometerTable &table = dataset->getAlmaRadiometer();
	AlmaRadiometerRow *row = 0;
	row = table.getRowByKey( Tag(*almaRadiometerId, TagType::AlmaRadiometer));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  almaRadiometerId  attr.UpperCaseName: AlmaRadiometerId
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getAlmaRadiometerTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
AlmaRadiometerTable &table = dataset->getAlmaRadiometer();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getAlmaRadiometerKeys(int * almaRadiometerId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	AlmaRadiometerTable &table = dataset->getAlmaRadiometer();
	
	vector< AlmaRadiometerRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// almaRadiometerId[i] = atoi((row[i]->getAlmaRadiometerId().getId()).c_str());
				almaRadiometerId[i] = row[i]->getAlmaRadiometerId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter numAntenna, in a row of the AlmaRadiometer table, given a key
 *
 */

#define sdm_addAlmaRadiometerNumAntenna  sdm_addalmaradiometernumantenna_
extern "C" int sdm_addAlmaRadiometerNumAntenna(int * almaRadiometerId, int * numAntenna);

int sdm_addAlmaRadiometerNumAntenna(int * almaRadiometerId, int * numAntenna) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AlmaRadiometerTable &table = dataset->getAlmaRadiometer();
	
	AlmaRadiometerRow *row = 0;
	row = table.getRowByKey( Tag(*almaRadiometerId, TagType::AlmaRadiometer));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumAntenna(int(* numAntenna ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numAntenna, in a row of the AlmaRadiometer table, given a key
 *
 */

#define sdm_getAlmaRadiometerNumAntenna  sdm_getalmaradiometernumantenna_
extern "C" int sdm_getAlmaRadiometerNumAntenna(int * almaRadiometerId, int * numAntenna);

int sdm_getAlmaRadiometerNumAntenna(int * almaRadiometerId, int * numAntenna) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AlmaRadiometerTable &table = dataset->getAlmaRadiometer();
	AlmaRadiometerRow *row = 0;
	row = table.getRowByKey( Tag(*almaRadiometerId, TagType::AlmaRadiometer));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumAntennaExists()) {
			*numAntenna = row->getNumAntenna();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter spectralWindowId, in a row of the AlmaRadiometer table, given a key
 *
 */

#define sdm_addAlmaRadiometerSpectralWindowId  sdm_addalmaradiometerspectralwindowid_
extern "C" int sdm_addAlmaRadiometerSpectralWindowId(int * almaRadiometerId, int * spectralWindowId, int * spectralWindowIdDim);

int sdm_addAlmaRadiometerSpectralWindowId(int * almaRadiometerId, int * spectralWindowId, int * spectralWindowIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AlmaRadiometerTable &table = dataset->getAlmaRadiometer();
	
	AlmaRadiometerRow *row = 0;
	row = table.getRowByKey( Tag(*almaRadiometerId, TagType::AlmaRadiometer));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Tag>   spectralWindowIdVec(spectralWindowIdDim[0]);
		for (int i=0;i<spectralWindowIdDim[0];i++)
			spectralWindowIdVec[i]= Tag(spectralWindowId[i] , TagType::SpectralWindow);
		row->setSpectralWindowId(spectralWindowIdVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter spectralWindowId, in a row of the AlmaRadiometer table, given a key
 *
 */

#define sdm_getAlmaRadiometerSpectralWindowId  sdm_getalmaradiometerspectralwindowid_
extern "C" int sdm_getAlmaRadiometerSpectralWindowId(int * almaRadiometerId, int * spectralWindowId, int * spectralWindowIdDim);

int sdm_getAlmaRadiometerSpectralWindowId(int * almaRadiometerId, int * spectralWindowId, int * spectralWindowIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AlmaRadiometerTable &table = dataset->getAlmaRadiometer();
	AlmaRadiometerRow *row = 0;
	row = table.getRowByKey( Tag(*almaRadiometerId, TagType::AlmaRadiometer));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSpectralWindowIdExists()) {
			// attr.CppType: vector<Tag>  attr.isOneD: true
			for (int i=0; i<min((int)row->getSpectralWindowId().size(),spectralWindowIdDim[1]); i++)
			// spectralWindowId[i] = atoi((row->getSpectralWindowId()[i]).getId().c_str());
			spectralWindowId[i] = row->getSpectralWindowId()[i].getTagValue();
			spectralWindowIdDim[0] = (int)row->getSpectralWindowId().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace BasebandNameMod;


// =================== AnnotationTable ============================

extern "C" int sdm_addAnnotationRow (int64_t * time, char * issue, int * issueDim, char * details, int * detailsDim);
extern "C" int sdm_getAnnotationRow (int * annotationId, int64_t * time, char * issue, int * issueDim, char * details, int * detailsDim);


extern "C" int sdm_getAnnotationTableSize ();

extern "C" int sdm_getAnnotationKeys (int * annotationId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addAnnotationRow (int64_t * time, char * issue, int * issueDim, char * details, int * detailsDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;

	
	// Create new row
  
	row = table.newRow(ArrayTime(*time), string(issue), string(details));

	// Add row
	AnnotationRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the AnnotationTable" << endl;
	}
	
	// return atoi((retRow->getAnnotationId().getId()).c_str());
	return retRow->getAnnotationId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a AnnotationRow* given a key.
 */
int sdm_getAnnotationRow (int * annotationId, int64_t * time, char * issue, int * issueDim, char * details, int * detailsDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  annotationId  attr.UpperCaseName: AnnotationId
		//  attr.NameS:  time  attr.UpperCaseName: Time
		*time     = row->getTime().get();
		//  attr.NameS:  issue  attr.UpperCaseName: Issue
		if ((int)row->getIssue().size()<issueDim[1])
			strcpy(issue,row->getIssue().c_str());
		else
			strncpy(issue,row->getIssue().c_str(),issueDim[1]);
		issueDim[0] = (int)row->getIssue().size();
		//  attr.NameS:  details  attr.UpperCaseName: Details
		if ((int)row->getDetails().size()<detailsDim[1])
			strcpy(details,row->getDetails().c_str());
		else
			strncpy(details,row->getDetails().c_str(),detailsDim[1]);
		detailsDim[0] = (int)row->getDetails().size();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getAnnotationTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
AnnotationTable &table = dataset->getAnnotation();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getAnnotationKeys(int * annotationId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	
	vector< AnnotationRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// annotationId[i] = atoi((row[i]->getAnnotationId().getId()).c_str());
				annotationId[i] = row[i]->getAnnotationId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter numAntenna, in a row of the Annotation table, given a key
 *
 */

#define sdm_addAnnotationNumAntenna  sdm_addannotationnumantenna_
extern "C" int sdm_addAnnotationNumAntenna(int * annotationId, int * numAntenna);

int sdm_addAnnotationNumAntenna(int * annotationId, int * numAntenna) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumAntenna(int(* numAntenna ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numAntenna, in a row of the Annotation table, given a key
 *
 */

#define sdm_getAnnotationNumAntenna  sdm_getannotationnumantenna_
extern "C" int sdm_getAnnotationNumAntenna(int * annotationId, int * numAntenna);

int sdm_getAnnotationNumAntenna(int * annotationId, int * numAntenna) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumAntennaExists()) {
			*numAntenna = row->getNumAntenna();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter basebandName, in a row of the Annotation table, given a key
 *
 */

#define sdm_addAnnotationBasebandName  sdm_addannotationbasebandname_
extern "C" int sdm_addAnnotationBasebandName(int * annotationId, BasebandName * basebandName, int * basebandNameDim);

int sdm_addAnnotationBasebandName(int * annotationId, BasebandName * basebandName, int * basebandNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<BasebandNameMod::BasebandName >  basebandNameVec(basebandNameDim[0]);
		for (int i=0;i<basebandNameDim[0];i++)
			basebandNameVec[i]= BasebandName(basebandName[i] );
		row->setBasebandName(basebandNameVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter basebandName, in a row of the Annotation table, given a key
 *
 */

#define sdm_getAnnotationBasebandName  sdm_getannotationbasebandname_
extern "C" int sdm_getAnnotationBasebandName(int * annotationId, BasebandName * basebandName, int * basebandNameDim);

int sdm_getAnnotationBasebandName(int * annotationId, BasebandName * basebandName, int * basebandNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isBasebandNameExists()) {
			// attr.CppType: vector<BasebandNameMod::BasebandName > attr.isOneD: true
			for (int i=0; i<min((int)row->getBasebandName().size(),basebandNameDim[1]); i++)
				basebandName[i] = row->getBasebandName()[i];
			basebandNameDim[0] = (int)row->getBasebandName().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numBaseband, in a row of the Annotation table, given a key
 *
 */

#define sdm_addAnnotationNumBaseband  sdm_addannotationnumbaseband_
extern "C" int sdm_addAnnotationNumBaseband(int * annotationId, int * numBaseband);

int sdm_addAnnotationNumBaseband(int * annotationId, int * numBaseband) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumBaseband(int(* numBaseband ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numBaseband, in a row of the Annotation table, given a key
 *
 */

#define sdm_getAnnotationNumBaseband  sdm_getannotationnumbaseband_
extern "C" int sdm_getAnnotationNumBaseband(int * annotationId, int * numBaseband);

int sdm_getAnnotationNumBaseband(int * annotationId, int * numBaseband) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumBasebandExists()) {
			*numBaseband = row->getNumBaseband();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter interval, in a row of the Annotation table, given a key
 *
 */

#define sdm_addAnnotationInterval  sdm_addannotationinterval_
extern "C" int sdm_addAnnotationInterval(int * annotationId, int64_t * interval);

int sdm_addAnnotationInterval(int * annotationId, int64_t * interval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setInterval(Interval(* interval ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter interval, in a row of the Annotation table, given a key
 *
 */

#define sdm_getAnnotationInterval  sdm_getannotationinterval_
extern "C" int sdm_getAnnotationInterval(int * annotationId, int64_t * interval);

int sdm_getAnnotationInterval(int * annotationId, int64_t * interval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isIntervalExists()) {
			*interval = row->getInterval().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter dValue, in a row of the Annotation table, given a key
 *
 */

#define sdm_addAnnotationDValue  sdm_addannotationdvalue_
extern "C" int sdm_addAnnotationDValue(int * annotationId, double * dValue);

int sdm_addAnnotationDValue(int * annotationId, double * dValue) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDValue(double(* dValue ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter dValue, in a row of the Annotation table, given a key
 *
 */

#define sdm_getAnnotationDValue  sdm_getannotationdvalue_
extern "C" int sdm_getAnnotationDValue(int * annotationId, double * dValue);

int sdm_getAnnotationDValue(int * annotationId, double * dValue) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDValueExists()) {
			*dValue = row->getDValue();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter vdValue, in a row of the Annotation table, given a key
 *
 */

#define sdm_addAnnotationVdValue  sdm_addannotationvdvalue_
extern "C" int sdm_addAnnotationVdValue(int * annotationId, double * vdValue, int * vdValueDim);

int sdm_addAnnotationVdValue(int * annotationId, double * vdValue, int * vdValueDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<double >  vdValueVec(vdValueDim[0]);
		for (int i=0;i<vdValueDim[0];i++)
			vdValueVec[i]= double(vdValue[i] );
		row->setVdValue(vdValueVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter vdValue, in a row of the Annotation table, given a key
 *
 */

#define sdm_getAnnotationVdValue  sdm_getannotationvdvalue_
extern "C" int sdm_getAnnotationVdValue(int * annotationId, double * vdValue, int * vdValueDim);

int sdm_getAnnotationVdValue(int * annotationId, double * vdValue, int * vdValueDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isVdValueExists()) {
			// attr.CppType: vector<double > attr.isOneD: true
			for (int i=0; i<min((int)row->getVdValue().size(),vdValueDim[1]); i++)
				vdValue[i] = row->getVdValue()[i];
			vdValueDim[0] = (int)row->getVdValue().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter vvdValues, in a row of the Annotation table, given a key
 *
 */

#define sdm_addAnnotationVvdValues  sdm_addannotationvvdvalues_
extern "C" int sdm_addAnnotationVvdValues(int * annotationId, double * vvdValues, int * vvdValuesDim);

int sdm_addAnnotationVvdValues(int * annotationId, double * vvdValues, int * vvdValuesDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par vvdValues:
		vector<vector<double > >  vvdValuesVec(vvdValuesDim[2]);
		for (int i=0;i<vvdValuesDim[2];i++) {
			vvdValuesVec[i].resize(vvdValuesDim[0]);
			for (int j=0;j<vvdValuesDim[0];j++)
				vvdValuesVec[i][j]= double(vvdValues[i*(vvdValuesDim[1])+j]);
		}
		row->setVvdValues(vvdValuesVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter vvdValues, in a row of the Annotation table, given a key
 *
 */

#define sdm_getAnnotationVvdValues  sdm_getannotationvvdvalues_
extern "C" int sdm_getAnnotationVvdValues(int * annotationId, double * vvdValues, int * vvdValuesDim);

int sdm_getAnnotationVvdValues(int * annotationId, double * vvdValues, int * vvdValuesDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isVvdValuesExists()) {
			// attr.CppType: vector<vector<double > > attr.isOneD: false
			int maxDimZeroVvdValues = 0;
			for (int i=0;i<min((int)row->getVvdValues().size(),vvdValuesDim[3]) ;i++) {
				maxDimZeroVvdValues = max((int)row->getVvdValues()[i].size(),maxDimZeroVvdValues);
				for (int j=0;j<min((int)row->getVvdValues()[i].size(),vvdValuesDim[1]) ;j++) {
					vvdValues[i*vvdValuesDim[1]+j]= row->getVvdValues()[i][j];
				}
			}
			vvdValuesDim[0] = maxDimZeroVvdValues;
			vvdValuesDim[2] = row->getVvdValues().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter llValue, in a row of the Annotation table, given a key
 *
 */

#define sdm_addAnnotationLlValue  sdm_addannotationllvalue_
extern "C" int sdm_addAnnotationLlValue(int * annotationId, int64_t * llValue);

int sdm_addAnnotationLlValue(int * annotationId, int64_t * llValue) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setLlValue(int64_t(* llValue ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter llValue, in a row of the Annotation table, given a key
 *
 */

#define sdm_getAnnotationLlValue  sdm_getannotationllvalue_
extern "C" int sdm_getAnnotationLlValue(int * annotationId, int64_t * llValue);

int sdm_getAnnotationLlValue(int * annotationId, int64_t * llValue) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isLlValueExists()) {
			*llValue = row->getLlValue();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter vllValue, in a row of the Annotation table, given a key
 *
 */

#define sdm_addAnnotationVllValue  sdm_addannotationvllvalue_
extern "C" int sdm_addAnnotationVllValue(int * annotationId, int64_t * vllValue, int * vllValueDim);

int sdm_addAnnotationVllValue(int * annotationId, int64_t * vllValue, int * vllValueDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<int64_t >  vllValueVec(vllValueDim[0]);
		for (int i=0;i<vllValueDim[0];i++)
			vllValueVec[i]= int64_t(vllValue[i] );
		row->setVllValue(vllValueVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter vllValue, in a row of the Annotation table, given a key
 *
 */

#define sdm_getAnnotationVllValue  sdm_getannotationvllvalue_
extern "C" int sdm_getAnnotationVllValue(int * annotationId, int64_t * vllValue, int * vllValueDim);

int sdm_getAnnotationVllValue(int * annotationId, int64_t * vllValue, int * vllValueDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isVllValueExists()) {
			// attr.CppType: vector<int64_t > attr.isOneD: true
			for (int i=0; i<min((int)row->getVllValue().size(),vllValueDim[1]); i++)
				vllValue[i] = row->getVllValue()[i];
			vllValueDim[0] = (int)row->getVllValue().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter vvllValue, in a row of the Annotation table, given a key
 *
 */

#define sdm_addAnnotationVvllValue  sdm_addannotationvvllvalue_
extern "C" int sdm_addAnnotationVvllValue(int * annotationId, int64_t * vvllValue, int * vvllValueDim);

int sdm_addAnnotationVvllValue(int * annotationId, int64_t * vvllValue, int * vvllValueDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par vvllValue:
		vector<vector<int64_t > >  vvllValueVec(vvllValueDim[2]);
		for (int i=0;i<vvllValueDim[2];i++) {
			vvllValueVec[i].resize(vvllValueDim[0]);
			for (int j=0;j<vvllValueDim[0];j++)
				vvllValueVec[i][j]= int64_t(vvllValue[i*(vvllValueDim[1])+j]);
		}
		row->setVvllValue(vvllValueVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter vvllValue, in a row of the Annotation table, given a key
 *
 */

#define sdm_getAnnotationVvllValue  sdm_getannotationvvllvalue_
extern "C" int sdm_getAnnotationVvllValue(int * annotationId, int64_t * vvllValue, int * vvllValueDim);

int sdm_getAnnotationVvllValue(int * annotationId, int64_t * vvllValue, int * vvllValueDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isVvllValueExists()) {
			// attr.CppType: vector<vector<int64_t > > attr.isOneD: false
			int maxDimZeroVvllValue = 0;
			for (int i=0;i<min((int)row->getVvllValue().size(),vvllValueDim[3]) ;i++) {
				maxDimZeroVvllValue = max((int)row->getVvllValue()[i].size(),maxDimZeroVvllValue);
				for (int j=0;j<min((int)row->getVvllValue()[i].size(),vvllValueDim[1]) ;j++) {
					vvllValue[i*vvllValueDim[1]+j]= row->getVvllValue()[i][j];
				}
			}
			vvllValueDim[0] = maxDimZeroVvllValue;
			vvllValueDim[2] = row->getVvllValue().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter antennaId, in a row of the Annotation table, given a key
 *
 */

#define sdm_addAnnotationAntennaId  sdm_addannotationantennaid_
extern "C" int sdm_addAnnotationAntennaId(int * annotationId, int * antennaId, int * antennaIdDim);

int sdm_addAnnotationAntennaId(int * annotationId, int * antennaId, int * antennaIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AnnotationTable &table = dataset->getAnnotation();
	
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Tag>   antennaIdVec(antennaIdDim[0]);
		for (int i=0;i<antennaIdDim[0];i++)
			antennaIdVec[i]= Tag(antennaId[i] , TagType::Antenna);
		row->setAntennaId(antennaIdVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter antennaId, in a row of the Annotation table, given a key
 *
 */

#define sdm_getAnnotationAntennaId  sdm_getannotationantennaid_
extern "C" int sdm_getAnnotationAntennaId(int * annotationId, int * antennaId, int * antennaIdDim);

int sdm_getAnnotationAntennaId(int * annotationId, int * antennaId, int * antennaIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AnnotationTable &table = dataset->getAnnotation();
	AnnotationRow *row = 0;
	row = table.getRowByKey( Tag(*annotationId, TagType::Annotation));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAntennaIdExists()) {
			// attr.CppType: vector<Tag>  attr.isOneD: true
			for (int i=0; i<min((int)row->getAntennaId().size(),antennaIdDim[1]); i++)
			// antennaId[i] = atoi((row->getAntennaId()[i]).getId().c_str());
			antennaId[i] = row->getAntennaId()[i].getTagValue();
			antennaIdDim[0] = (int)row->getAntennaId().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace AntennaMakeMod;
using namespace AntennaTypeMod;


// =================== AntennaTable ============================

extern "C" int sdm_addAntennaRow (char * name, int * nameDim, AntennaMake * antennaMake, AntennaType * antennaType, double * dishDiameter, double * position, int * positionDim, double * offset, int * offsetDim, int64_t * time, int * stationId);
extern "C" int sdm_getAntennaRow (int * antennaId, char * name, int * nameDim, AntennaMake * antennaMake, AntennaType * antennaType, double * dishDiameter, double * position, int * positionDim, double * offset, int * offsetDim, int64_t * time, int * stationId);


extern "C" int sdm_getAntennaTableSize ();

extern "C" int sdm_getAntennaKeys (int * antennaId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addAntennaRow (char * name, int * nameDim, AntennaMake * antennaMake, AntennaType * antennaType, double * dishDiameter, double * position, int * positionDim, double * offset, int * offsetDim, int64_t * time, int * stationId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	AntennaTable &table = dataset->getAntenna();
	AntennaRow *row = 0;

	// antennaMake is an enumeration
	// AntennaMake * antennaMake =  (int) antennaMake;
	// antennaType is an enumeration
	// AntennaType * antennaType =  (int) antennaType;
	// position is an Array
	// position is OneD
	vector<Length >  positionVec(positionDim[0]);
	for (int i=0;i<positionDim[0];i++)
		positionVec[i]= Length(position[i]   );
	// offset is an Array
	// offset is OneD
	vector<Length >  offsetVec(offsetDim[0]);
	for (int i=0;i<offsetDim[0];i++)
		offsetVec[i]= Length(offset[i]   );
	
	// Create new row
  
	row = table.newRow(string(name), *antennaMake, *antennaType, Length(*dishDiameter), positionVec, offsetVec, ArrayTime(*time), Tag(*stationId,TagType::Station));

	// Add row
	AntennaRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the AntennaTable" << endl;
	}
	
	// return atoi((retRow->getAntennaId().getId()).c_str());
	return retRow->getAntennaId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a AntennaRow* given a key.
 */
int sdm_getAntennaRow (int * antennaId, char * name, int * nameDim, AntennaMake * antennaMake, AntennaType * antennaType, double * dishDiameter, double * position, int * positionDim, double * offset, int * offsetDim, int64_t * time, int * stationId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AntennaTable &table = dataset->getAntenna();
	AntennaRow *row = 0;
	row = table.getRowByKey( Tag(*antennaId, TagType::Antenna));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  name  attr.UpperCaseName: Name
		if ((int)row->getName().size()<nameDim[1])
			strcpy(name,row->getName().c_str());
		else
			strncpy(name,row->getName().c_str(),nameDim[1]);
		nameDim[0] = (int)row->getName().size();
		//  attr.NameS:  antennaMake  attr.UpperCaseName: AntennaMake
		*antennaMake = row->getAntennaMake();
		//  attr.NameS:  antennaType  attr.UpperCaseName: AntennaType
		*antennaType = row->getAntennaType();
		//  attr.NameS:  dishDiameter  attr.UpperCaseName: DishDiameter
		*dishDiameter = row->getDishDiameter().get();
		//  attr.NameS:  position  attr.UpperCaseName: Position
		
		vector<Length >  positionVec = row->getPosition();
		
		for (int i=0; i<min((int)positionVec.size(),positionDim[1]); i++)
			position[i] = positionVec[i].get();
		positionDim[0] = positionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  offset  attr.UpperCaseName: Offset
		
		vector<Length >  offsetVec = row->getOffset();
		
		for (int i=0; i<min((int)offsetVec.size(),offsetDim[1]); i++)
			offset[i] = offsetVec[i].get();
		offsetDim[0] = offsetVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  time  attr.UpperCaseName: Time
		*time     = row->getTime().get();
		//  attr.NameS:  stationId  attr.UpperCaseName: StationId
		// *stationId = atoi((row->getStationId().getId()).c_str());
		*stationId = row->getStationId().getTagValue();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getAntennaTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
AntennaTable &table = dataset->getAntenna();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getAntennaKeys(int * antennaId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	AntennaTable &table = dataset->getAntenna();
	
	vector< AntennaRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter assocAntennaId, in a row of the Antenna table, given a key
 *
 */

#define sdm_addAntennaAssocAntennaId  sdm_addantennaassocantennaid_
extern "C" int sdm_addAntennaAssocAntennaId(int * antennaId, int * assocAntennaId);

int sdm_addAntennaAssocAntennaId(int * antennaId, int * assocAntennaId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	AntennaTable &table = dataset->getAntenna();
	
	AntennaRow *row = 0;
	row = table.getRowByKey( Tag(*antennaId, TagType::Antenna));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setAssocAntennaId(Tag(* assocAntennaId , TagType::Antenna));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter assocAntennaId, in a row of the Antenna table, given a key
 *
 */

#define sdm_getAntennaAssocAntennaId  sdm_getantennaassocantennaid_
extern "C" int sdm_getAntennaAssocAntennaId(int * antennaId, int * assocAntennaId);

int sdm_getAntennaAssocAntennaId(int * antennaId, int * assocAntennaId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	AntennaTable &table = dataset->getAntenna();
	AntennaRow *row = 0;
	row = table.getRowByKey( Tag(*antennaId, TagType::Antenna));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAssocAntennaIdExists()) {
			// *assocAntennaId = atoi((row->getAssocAntennaId().getId()).c_str());
			*assocAntennaId = row->getAssocAntennaId().getTagValue();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace AtmPhaseCorrectionMod;
using namespace ReceiverBandMod;
using namespace BasebandNameMod;
using namespace PolarizationTypeMod;


// =================== CalAmpliTable ============================

extern "C" int sdm_addCalAmpliRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, float * apertureEfficiency, int * apertureEfficiencyDim, float * apertureEfficiencyError, int * apertureEfficiencyErrorDim);
extern "C" int sdm_getCalAmpliRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, float * apertureEfficiency, int * apertureEfficiencyDim, float * apertureEfficiencyError, int * apertureEfficiencyErrorDim);


extern "C" int sdm_getCalAmpliTableSize ();

extern "C" int sdm_getCalAmpliKeys (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalAmpliRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, float * apertureEfficiency, int * apertureEfficiencyDim, float * apertureEfficiencyError, int * apertureEfficiencyErrorDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalAmpliTable &table = dataset->getCalAmpli();
	CalAmpliRow *row = 0;

	// atmPhaseCorrection is an enumeration
	// AtmPhaseCorrection * atmPhaseCorrection =  (int) atmPhaseCorrection;
	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// basebandName is an enumeration
	// BasebandName * basebandName =  (int) basebandName;
	// polarizationTypes is an Array
	// polarizationTypes is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec(polarizationTypesDim[0]);
	for (int i=0;i<polarizationTypesDim[0];i++)
		polarizationTypesVec[i]= PolarizationType(polarizationTypes[i]   );
	// frequencyRange is an Array
	// frequencyRange is OneD
	vector<Frequency >  frequencyRangeVec(frequencyRangeDim[0]);
	for (int i=0;i<frequencyRangeDim[0];i++)
		frequencyRangeVec[i]= Frequency(frequencyRange[i]   );
	// apertureEfficiency is an Array
	// apertureEfficiency is OneD
	vector<float >  apertureEfficiencyVec(apertureEfficiencyDim[0]);
	for (int i=0;i<apertureEfficiencyDim[0];i++)
		apertureEfficiencyVec[i]= float(apertureEfficiency[i]   );
	// apertureEfficiencyError is an Array
	// apertureEfficiencyError is OneD
	vector<float >  apertureEfficiencyErrorVec(apertureEfficiencyErrorDim[0]);
	for (int i=0;i<apertureEfficiencyErrorDim[0];i++)
		apertureEfficiencyErrorVec[i]= float(apertureEfficiencyError[i]   );
	
	// Create new row
  
	row = table.newRow(string(antennaName), *atmPhaseCorrection, *receiverBand, *basebandName, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), *numReceptor, polarizationTypesVec, ArrayTime(*startValidTime), ArrayTime(*endValidTime), frequencyRangeVec, apertureEfficiencyVec, apertureEfficiencyErrorVec);

	// Add row
	CalAmpliRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalAmpliTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalAmpliRow* given a key.
 */
int sdm_getCalAmpliRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, float * apertureEfficiency, int * apertureEfficiencyDim, float * apertureEfficiencyError, int * apertureEfficiencyErrorDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAmpliTable &table = dataset->getCalAmpli();
	CalAmpliRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaName  attr.UpperCaseName: AntennaName
		//  attr.NameS:  atmPhaseCorrection  attr.UpperCaseName: AtmPhaseCorrection
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		//  attr.NameS:  basebandName  attr.UpperCaseName: BasebandName
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  polarizationTypes  attr.UpperCaseName: PolarizationTypes
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec = row->getPolarizationTypes();
		
		for (int i=0; i<min((int)polarizationTypesVec.size(),polarizationTypesDim[1]); i++)
			polarizationTypes[i] = polarizationTypesVec[i];
		polarizationTypesDim[0] = (int)polarizationTypesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  frequencyRange  attr.UpperCaseName: FrequencyRange
		
		vector<Frequency >  frequencyRangeVec = row->getFrequencyRange();
		
		for (int i=0; i<min((int)frequencyRangeVec.size(),frequencyRangeDim[1]); i++)
			frequencyRange[i] = frequencyRangeVec[i].get();
		frequencyRangeDim[0] = frequencyRangeVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  apertureEfficiency  attr.UpperCaseName: ApertureEfficiency
		
		vector<float >  apertureEfficiencyVec = row->getApertureEfficiency();
		
		for (int i=0; i<min((int)apertureEfficiencyVec.size(),apertureEfficiencyDim[1]); i++)
			apertureEfficiency[i] = apertureEfficiencyVec[i];
		apertureEfficiencyDim[0] = (int)apertureEfficiencyVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  apertureEfficiencyError  attr.UpperCaseName: ApertureEfficiencyError
		
		vector<float >  apertureEfficiencyErrorVec = row->getApertureEfficiencyError();
		
		for (int i=0; i<min((int)apertureEfficiencyErrorVec.size(),apertureEfficiencyErrorDim[1]); i++)
			apertureEfficiencyError[i] = apertureEfficiencyErrorVec[i];
		apertureEfficiencyErrorDim[0] = (int)apertureEfficiencyErrorVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalAmpliTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalAmpliTable &table = dataset->getCalAmpli();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalAmpliKeys(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalAmpliTable &table = dataset->getCalAmpli();
	
	vector< CalAmpliRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroAntennaName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getAntennaName().size() < antennaNameDim[1])
	  			strcpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str());
	  		else
	  			strncpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str(),antennaNameDim[1]);
	  		maxDimZeroAntennaName = max((int)row[i]->getAntennaName().size(), maxDimZeroAntennaName);
	  		atmPhaseCorrection[i] = row[i]->getAtmPhaseCorrection();
	  		receiverBand[i] = row[i]->getReceiverBand();
	  		basebandName[i] = row[i]->getBasebandName();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
antennaNameDim[0] = maxDimZeroAntennaName ;
antennaNameDim[2] = size ;
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter correctionValidity, in a row of the CalAmpli table, given a key
 *
 */

#define sdm_addCalAmpliCorrectionValidity  sdm_addcalamplicorrectionvalidity_
extern "C" int sdm_addCalAmpliCorrectionValidity(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, bool * correctionValidity);

int sdm_addCalAmpliCorrectionValidity(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, bool * correctionValidity) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAmpliTable &table = dataset->getCalAmpli();
	
	CalAmpliRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCorrectionValidity(bool(* correctionValidity ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter correctionValidity, in a row of the CalAmpli table, given a key
 *
 */

#define sdm_getCalAmpliCorrectionValidity  sdm_getcalamplicorrectionvalidity_
extern "C" int sdm_getCalAmpliCorrectionValidity(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, bool * correctionValidity);

int sdm_getCalAmpliCorrectionValidity(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, bool * correctionValidity) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalAmpliTable &table = dataset->getCalAmpli();
	CalAmpliRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCorrectionValidityExists()) {
			*correctionValidity = row->getCorrectionValidity();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace BasebandNameMod;


// =================== CalAppPhaseTable ============================

extern "C" int sdm_addCalAppPhaseRow (BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int64_t * adjustTime, char * adjustToken, int * adjustTokenDim, char * phasingMode, int * phasingModeDim, int * numPhasedAntennas, char * phasedAntennas, int * phasedAntennasDim, int * refAntennaIndex, int * candRefAntennaIndex, char * phasePacking, int * phasePackingDim, int * numReceptors, int * numChannels, int * numPhaseValues, float * phaseValues, int * phaseValuesDim, int * numCompare, int * numEfficiencies, char * compareArray, int * compareArrayDim, int * efficiencyIndices, int * efficiencyIndicesDim, float * efficiencies, int * efficienciesDim, float * quality, int * qualityDim, char * phasedSumAntenna, int * phasedSumAntennaDim);
extern "C" int sdm_getCalAppPhaseRow (BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int64_t * adjustTime, char * adjustToken, int * adjustTokenDim, char * phasingMode, int * phasingModeDim, int * numPhasedAntennas, char * phasedAntennas, int * phasedAntennasDim, int * refAntennaIndex, int * candRefAntennaIndex, char * phasePacking, int * phasePackingDim, int * numReceptors, int * numChannels, int * numPhaseValues, float * phaseValues, int * phaseValuesDim, int * numCompare, int * numEfficiencies, char * compareArray, int * compareArrayDim, int * efficiencyIndices, int * efficiencyIndicesDim, float * efficiencies, int * efficienciesDim, float * quality, int * qualityDim, char * phasedSumAntenna, int * phasedSumAntennaDim);


extern "C" int sdm_getCalAppPhaseTableSize ();

extern "C" int sdm_getCalAppPhaseKeys (BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalAppPhaseRow (BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int64_t * adjustTime, char * adjustToken, int * adjustTokenDim, char * phasingMode, int * phasingModeDim, int * numPhasedAntennas, char * phasedAntennas, int * phasedAntennasDim, int * refAntennaIndex, int * candRefAntennaIndex, char * phasePacking, int * phasePackingDim, int * numReceptors, int * numChannels, int * numPhaseValues, float * phaseValues, int * phaseValuesDim, int * numCompare, int * numEfficiencies, char * compareArray, int * compareArrayDim, int * efficiencyIndices, int * efficiencyIndicesDim, float * efficiencies, int * efficienciesDim, float * quality, int * qualityDim, char * phasedSumAntenna, int * phasedSumAntennaDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalAppPhaseTable &table = dataset->getCalAppPhase();
	CalAppPhaseRow *row = 0;

	// basebandName is an enumeration
	// BasebandName * basebandName =  (int) basebandName;
	// phasedAntennas is an Array
	// phasedAntennas is OneD
	vector<string >  phasedAntennasVec(phasedAntennasDim[2]);
	for (int i=0;i<phasedAntennasDim[2];i++)
		phasedAntennasVec[i]= string(phasedAntennas+i*phasedAntennasDim[1]  );
	// phaseValues is an Array
	// phaseValues is OneD
	vector<float >  phaseValuesVec(phaseValuesDim[0]);
	for (int i=0;i<phaseValuesDim[0];i++)
		phaseValuesVec[i]= float(phaseValues[i]   );
	// compareArray is an Array
	// compareArray is OneD
	vector<string >  compareArrayVec(compareArrayDim[2]);
	for (int i=0;i<compareArrayDim[2];i++)
		compareArrayVec[i]= string(compareArray+i*compareArrayDim[1]  );
	// efficiencyIndices is an Array
	// efficiencyIndices is OneD
	vector<int >  efficiencyIndicesVec(efficiencyIndicesDim[0]);
	for (int i=0;i<efficiencyIndicesDim[0];i++)
		efficiencyIndicesVec[i]= int(efficiencyIndices[i]   );
	// efficiencies is an Array
	// efficiencies is 2 D
	vector<vector<float > >  efficienciesVec(efficienciesDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<efficienciesDim[2];i++) {
		efficienciesVec[i].resize(efficienciesDim[0]);
		for (int j=0;j<efficienciesDim[0];j++)
			efficienciesVec[i][j]= float(efficiencies[i*efficienciesDim[1]+j]  );
	
	
	}
	// quality is an Array
	// quality is OneD
	vector<float >  qualityVec(qualityDim[0]);
	for (int i=0;i<qualityDim[0];i++)
		qualityVec[i]= float(quality[i]   );
	
	// Create new row
  
	row = table.newRow(*basebandName, *scanNumber, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), ArrayTime(*adjustTime), string(adjustToken), string(phasingMode), *numPhasedAntennas, phasedAntennasVec, *refAntennaIndex, *candRefAntennaIndex, string(phasePacking), *numReceptors, *numChannels, *numPhaseValues, phaseValuesVec, *numCompare, *numEfficiencies, compareArrayVec, efficiencyIndicesVec, efficienciesVec, qualityVec, string(phasedSumAntenna));

	// Add row
	CalAppPhaseRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalAppPhaseTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalAppPhaseRow* given a key.
 */
int sdm_getCalAppPhaseRow (BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int64_t * adjustTime, char * adjustToken, int * adjustTokenDim, char * phasingMode, int * phasingModeDim, int * numPhasedAntennas, char * phasedAntennas, int * phasedAntennasDim, int * refAntennaIndex, int * candRefAntennaIndex, char * phasePacking, int * phasePackingDim, int * numReceptors, int * numChannels, int * numPhaseValues, float * phaseValues, int * phaseValuesDim, int * numCompare, int * numEfficiencies, char * compareArray, int * compareArrayDim, int * efficiencyIndices, int * efficiencyIndicesDim, float * efficiencies, int * efficienciesDim, float * quality, int * qualityDim, char * phasedSumAntenna, int * phasedSumAntennaDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAppPhaseTable &table = dataset->getCalAppPhase();
	CalAppPhaseRow *row = 0;
	row = table.getRowByKey( *basebandName, *scanNumber, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  basebandName  attr.UpperCaseName: BasebandName
		//  attr.NameS:  scanNumber  attr.UpperCaseName: ScanNumber
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  adjustTime  attr.UpperCaseName: AdjustTime
		*adjustTime     = row->getAdjustTime().get();
		//  attr.NameS:  adjustToken  attr.UpperCaseName: AdjustToken
		if ((int)row->getAdjustToken().size()<adjustTokenDim[1])
			strcpy(adjustToken,row->getAdjustToken().c_str());
		else
			strncpy(adjustToken,row->getAdjustToken().c_str(),adjustTokenDim[1]);
		adjustTokenDim[0] = (int)row->getAdjustToken().size();
		//  attr.NameS:  phasingMode  attr.UpperCaseName: PhasingMode
		if ((int)row->getPhasingMode().size()<phasingModeDim[1])
			strcpy(phasingMode,row->getPhasingMode().c_str());
		else
			strncpy(phasingMode,row->getPhasingMode().c_str(),phasingModeDim[1]);
		phasingModeDim[0] = (int)row->getPhasingMode().size();
		//  attr.NameS:  numPhasedAntennas  attr.UpperCaseName: NumPhasedAntennas
		*numPhasedAntennas = row->getNumPhasedAntennas();
		//  attr.NameS:  phasedAntennas  attr.UpperCaseName: PhasedAntennas
		
		vector<string >  phasedAntennasVec = row->getPhasedAntennas();
		
		int maxDimZeroPhasedAntennas = 0;
		for (int i=0; i<min((int)phasedAntennasVec.size(),phasedAntennasDim[3]); i++) {
			if ((int)phasedAntennasVec[i].size()<phasedAntennasDim[1])
				strcpy(phasedAntennas+i*phasedAntennasDim[1],phasedAntennasVec[i].c_str());
			else
				strncpy(phasedAntennas+i*phasedAntennasDim[1],phasedAntennasVec[i].c_str(),phasedAntennasDim[1]);
			maxDimZeroPhasedAntennas = max((int)phasedAntennasVec[i].size(),maxDimZeroPhasedAntennas);
		}
		phasedAntennasDim[0] = maxDimZeroPhasedAntennas;
		phasedAntennasDim[2] = phasedAntennasVec.size();  // number of strings
		
		
		//  attr.NameS:  refAntennaIndex  attr.UpperCaseName: RefAntennaIndex
		*refAntennaIndex = row->getRefAntennaIndex();
		//  attr.NameS:  candRefAntennaIndex  attr.UpperCaseName: CandRefAntennaIndex
		*candRefAntennaIndex = row->getCandRefAntennaIndex();
		//  attr.NameS:  phasePacking  attr.UpperCaseName: PhasePacking
		if ((int)row->getPhasePacking().size()<phasePackingDim[1])
			strcpy(phasePacking,row->getPhasePacking().c_str());
		else
			strncpy(phasePacking,row->getPhasePacking().c_str(),phasePackingDim[1]);
		phasePackingDim[0] = (int)row->getPhasePacking().size();
		//  attr.NameS:  numReceptors  attr.UpperCaseName: NumReceptors
		*numReceptors = row->getNumReceptors();
		//  attr.NameS:  numChannels  attr.UpperCaseName: NumChannels
		*numChannels = row->getNumChannels();
		//  attr.NameS:  numPhaseValues  attr.UpperCaseName: NumPhaseValues
		*numPhaseValues = row->getNumPhaseValues();
		//  attr.NameS:  phaseValues  attr.UpperCaseName: PhaseValues
		
		vector<float >  phaseValuesVec = row->getPhaseValues();
		
		for (int i=0; i<min((int)phaseValuesVec.size(),phaseValuesDim[1]); i++)
			phaseValues[i] = phaseValuesVec[i];
		phaseValuesDim[0] = (int)phaseValuesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  numCompare  attr.UpperCaseName: NumCompare
		*numCompare = row->getNumCompare();
		//  attr.NameS:  numEfficiencies  attr.UpperCaseName: NumEfficiencies
		*numEfficiencies = row->getNumEfficiencies();
		//  attr.NameS:  compareArray  attr.UpperCaseName: CompareArray
		
		vector<string >  compareArrayVec = row->getCompareArray();
		
		int maxDimZeroCompareArray = 0;
		for (int i=0; i<min((int)compareArrayVec.size(),compareArrayDim[3]); i++) {
			if ((int)compareArrayVec[i].size()<compareArrayDim[1])
				strcpy(compareArray+i*compareArrayDim[1],compareArrayVec[i].c_str());
			else
				strncpy(compareArray+i*compareArrayDim[1],compareArrayVec[i].c_str(),compareArrayDim[1]);
			maxDimZeroCompareArray = max((int)compareArrayVec[i].size(),maxDimZeroCompareArray);
		}
		compareArrayDim[0] = maxDimZeroCompareArray;
		compareArrayDim[2] = compareArrayVec.size();  // number of strings
		
		
		//  attr.NameS:  efficiencyIndices  attr.UpperCaseName: EfficiencyIndices
		
		vector<int >  efficiencyIndicesVec = row->getEfficiencyIndices();
		
		for (int i=0; i<min((int)efficiencyIndicesVec.size(),efficiencyIndicesDim[1]); i++)
			efficiencyIndices[i] = efficiencyIndicesVec[i];
		efficiencyIndicesDim[0] = (int)efficiencyIndicesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  efficiencies  attr.UpperCaseName: Efficiencies
		
		vector<vector<float > >  efficienciesVec = row->getEfficiencies();
		
		int maxDimZeroEfficiencies = 0;
		for (int i=0;i<min((int)efficienciesVec.size(),efficienciesDim[3]) ;i++) {
			maxDimZeroEfficiencies = max((int)efficienciesVec[i].size(),maxDimZeroEfficiencies);
			for (int j=0;j<min((int)efficienciesVec[i].size(),efficienciesDim[1]) ;j++) {
				efficiencies[i*efficienciesDim[1]+j]= efficienciesVec[i][j];
			}
		}
		efficienciesDim[0] = maxDimZeroEfficiencies;
		efficienciesDim[2] = efficienciesVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  quality  attr.UpperCaseName: Quality
		
		vector<float >  qualityVec = row->getQuality();
		
		for (int i=0; i<min((int)qualityVec.size(),qualityDim[1]); i++)
			quality[i] = qualityVec[i];
		qualityDim[0] = (int)qualityVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  phasedSumAntenna  attr.UpperCaseName: PhasedSumAntenna
		if ((int)row->getPhasedSumAntenna().size()<phasedSumAntennaDim[1])
			strcpy(phasedSumAntenna,row->getPhasedSumAntenna().c_str());
		else
			strncpy(phasedSumAntenna,row->getPhasedSumAntenna().c_str(),phasedSumAntennaDim[1]);
		phasedSumAntennaDim[0] = (int)row->getPhasedSumAntenna().size();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalAppPhaseTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalAppPhaseTable &table = dataset->getCalAppPhase();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalAppPhaseKeys(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalAppPhaseTable &table = dataset->getCalAppPhase();
	
	vector< CalAppPhaseRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		basebandName[i] = row[i]->getBasebandName();
	  		scanNumber[i] = row[i]->getScanNumber();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter typeSupports, in a row of the CalAppPhase table, given a key
 *
 */

#define sdm_addCalAppPhaseTypeSupports  sdm_addcalappphasetypesupports_
extern "C" int sdm_addCalAppPhaseTypeSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, char * typeSupports, int * typeSupportsDim);

int sdm_addCalAppPhaseTypeSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, char * typeSupports, int * typeSupportsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAppPhaseTable &table = dataset->getCalAppPhase();
	
	CalAppPhaseRow *row = 0;
	row = table.getRowByKey( *basebandName, *scanNumber, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTypeSupports(string(typeSupports));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter typeSupports, in a row of the CalAppPhase table, given a key
 *
 */

#define sdm_getCalAppPhaseTypeSupports  sdm_getcalappphasetypesupports_
extern "C" int sdm_getCalAppPhaseTypeSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, char * typeSupports, int * typeSupportsDim);

int sdm_getCalAppPhaseTypeSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, char * typeSupports, int * typeSupportsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalAppPhaseTable &table = dataset->getCalAppPhase();
	CalAppPhaseRow *row = 0;
	row = table.getRowByKey( *basebandName, *scanNumber, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTypeSupportsExists()) {
			if ((int)row->getTypeSupports().size()<typeSupportsDim[1])
				strcpy(typeSupports,row->getTypeSupports().c_str());
			else
				strncpy(typeSupports,row->getTypeSupports().c_str(),typeSupportsDim[1]);
			typeSupportsDim[0] = (int)row->getTypeSupports().size();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numSupports, in a row of the CalAppPhase table, given a key
 *
 */

#define sdm_addCalAppPhaseNumSupports  sdm_addcalappphasenumsupports_
extern "C" int sdm_addCalAppPhaseNumSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, int * numSupports);

int sdm_addCalAppPhaseNumSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, int * numSupports) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAppPhaseTable &table = dataset->getCalAppPhase();
	
	CalAppPhaseRow *row = 0;
	row = table.getRowByKey( *basebandName, *scanNumber, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumSupports(int(* numSupports ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numSupports, in a row of the CalAppPhase table, given a key
 *
 */

#define sdm_getCalAppPhaseNumSupports  sdm_getcalappphasenumsupports_
extern "C" int sdm_getCalAppPhaseNumSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, int * numSupports);

int sdm_getCalAppPhaseNumSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, int * numSupports) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalAppPhaseTable &table = dataset->getCalAppPhase();
	CalAppPhaseRow *row = 0;
	row = table.getRowByKey( *basebandName, *scanNumber, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumSupportsExists()) {
			*numSupports = row->getNumSupports();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter phaseSupports, in a row of the CalAppPhase table, given a key
 *
 */

#define sdm_addCalAppPhasePhaseSupports  sdm_addcalappphasephasesupports_
extern "C" int sdm_addCalAppPhasePhaseSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, float * phaseSupports, int * phaseSupportsDim);

int sdm_addCalAppPhasePhaseSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, float * phaseSupports, int * phaseSupportsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAppPhaseTable &table = dataset->getCalAppPhase();
	
	CalAppPhaseRow *row = 0;
	row = table.getRowByKey( *basebandName, *scanNumber, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<float >  phaseSupportsVec(phaseSupportsDim[0]);
		for (int i=0;i<phaseSupportsDim[0];i++)
			phaseSupportsVec[i]= float(phaseSupports[i] );
		row->setPhaseSupports(phaseSupportsVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter phaseSupports, in a row of the CalAppPhase table, given a key
 *
 */

#define sdm_getCalAppPhasePhaseSupports  sdm_getcalappphasephasesupports_
extern "C" int sdm_getCalAppPhasePhaseSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, float * phaseSupports, int * phaseSupportsDim);

int sdm_getCalAppPhasePhaseSupports(BasebandName * basebandName, int * scanNumber, int * calDataId, int * calReductionId, float * phaseSupports, int * phaseSupportsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalAppPhaseTable &table = dataset->getCalAppPhase();
	CalAppPhaseRow *row = 0;
	row = table.getRowByKey( *basebandName, *scanNumber, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPhaseSupportsExists()) {
			// attr.CppType: vector<float > attr.isOneD: true
			for (int i=0; i<min((int)row->getPhaseSupports().size(),phaseSupportsDim[1]); i++)
				phaseSupports[i] = row->getPhaseSupports()[i];
			phaseSupportsDim[0] = (int)row->getPhaseSupports().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace ReceiverBandMod;
using namespace BasebandNameMod;
using namespace PolarizationTypeMod;
using namespace SyscalMethodMod;


// =================== CalAtmosphereTable ============================

extern "C" int sdm_addCalAtmosphereRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numFreq, int * numLoad, int * numReceptor, float * forwardEffSpectrum, int * forwardEffSpectrumDim, double * frequencyRange, int * frequencyRangeDim, double * groundPressure, double * groundRelHumidity, double * frequencySpectrum, int * frequencySpectrumDim, double * groundTemperature, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * powerSkySpectrum, int * powerSkySpectrumDim, float * powerLoadSpectrum, int * powerLoadSpectrumDim, SyscalMethod * syscalType, double * tAtmSpectrum, int * tAtmSpectrumDim, double * tRecSpectrum, int * tRecSpectrumDim, double * tSysSpectrum, int * tSysSpectrumDim, float * tauSpectrum, int * tauSpectrumDim, double * tAtm, int * tAtmDim, double * tRec, int * tRecDim, double * tSys, int * tSysDim, float * tau, int * tauDim, double * water, int * waterDim, double * waterError, int * waterErrorDim);
extern "C" int sdm_getCalAtmosphereRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numFreq, int * numLoad, int * numReceptor, float * forwardEffSpectrum, int * forwardEffSpectrumDim, double * frequencyRange, int * frequencyRangeDim, double * groundPressure, double * groundRelHumidity, double * frequencySpectrum, int * frequencySpectrumDim, double * groundTemperature, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * powerSkySpectrum, int * powerSkySpectrumDim, float * powerLoadSpectrum, int * powerLoadSpectrumDim, SyscalMethod * syscalType, double * tAtmSpectrum, int * tAtmSpectrumDim, double * tRecSpectrum, int * tRecSpectrumDim, double * tSysSpectrum, int * tSysSpectrumDim, float * tauSpectrum, int * tauSpectrumDim, double * tAtm, int * tAtmDim, double * tRec, int * tRecDim, double * tSys, int * tSysDim, float * tau, int * tauDim, double * water, int * waterDim, double * waterError, int * waterErrorDim);


extern "C" int sdm_getCalAtmosphereTableSize ();

extern "C" int sdm_getCalAtmosphereKeys (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalAtmosphereRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numFreq, int * numLoad, int * numReceptor, float * forwardEffSpectrum, int * forwardEffSpectrumDim, double * frequencyRange, int * frequencyRangeDim, double * groundPressure, double * groundRelHumidity, double * frequencySpectrum, int * frequencySpectrumDim, double * groundTemperature, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * powerSkySpectrum, int * powerSkySpectrumDim, float * powerLoadSpectrum, int * powerLoadSpectrumDim, SyscalMethod * syscalType, double * tAtmSpectrum, int * tAtmSpectrumDim, double * tRecSpectrum, int * tRecSpectrumDim, double * tSysSpectrum, int * tSysSpectrumDim, float * tauSpectrum, int * tauSpectrumDim, double * tAtm, int * tAtmDim, double * tRec, int * tRecDim, double * tSys, int * tSysDim, float * tau, int * tauDim, double * water, int * waterDim, double * waterError, int * waterErrorDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	CalAtmosphereRow *row = 0;

	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// basebandName is an enumeration
	// BasebandName * basebandName =  (int) basebandName;
	// forwardEffSpectrum is an Array
	// forwardEffSpectrum is 2 D
	vector<vector<float > >  forwardEffSpectrumVec(forwardEffSpectrumDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<forwardEffSpectrumDim[2];i++) {
		forwardEffSpectrumVec[i].resize(forwardEffSpectrumDim[0]);
		for (int j=0;j<forwardEffSpectrumDim[0];j++)
			forwardEffSpectrumVec[i][j]= float(forwardEffSpectrum[i*forwardEffSpectrumDim[1]+j]  );
	
	
	}
	// frequencyRange is an Array
	// frequencyRange is OneD
	vector<Frequency >  frequencyRangeVec(frequencyRangeDim[0]);
	for (int i=0;i<frequencyRangeDim[0];i++)
		frequencyRangeVec[i]= Frequency(frequencyRange[i]   );
	// frequencySpectrum is an Array
	// frequencySpectrum is OneD
	vector<Frequency >  frequencySpectrumVec(frequencySpectrumDim[0]);
	for (int i=0;i<frequencySpectrumDim[0];i++)
		frequencySpectrumVec[i]= Frequency(frequencySpectrum[i]   );
	// polarizationTypes is an Array
	// polarizationTypes is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec(polarizationTypesDim[0]);
	for (int i=0;i<polarizationTypesDim[0];i++)
		polarizationTypesVec[i]= PolarizationType(polarizationTypes[i]   );
	// powerSkySpectrum is an Array
	// powerSkySpectrum is 2 D
	vector<vector<float > >  powerSkySpectrumVec(powerSkySpectrumDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<powerSkySpectrumDim[2];i++) {
		powerSkySpectrumVec[i].resize(powerSkySpectrumDim[0]);
		for (int j=0;j<powerSkySpectrumDim[0];j++)
			powerSkySpectrumVec[i][j]= float(powerSkySpectrum[i*powerSkySpectrumDim[1]+j]  );
	
	
	}
	// powerLoadSpectrum is an Array
	// powerLoadSpectrum is 3 D
	vector<vector<vector<float > > >  powerLoadSpectrumVec(powerLoadSpectrumDim[4]);   // Inversion of dim in fortran/C
	for (int i=0;i<powerLoadSpectrumDim[4];i++) {
		powerLoadSpectrumVec[i].resize(powerLoadSpectrumDim[2]);
		for (int j=0;j<powerLoadSpectrumDim[2];j++) {
			powerLoadSpectrumVec[i][j].resize(powerLoadSpectrumDim[0]);
			for (int k=0;k<powerLoadSpectrumDim[0];k++)
		    powerLoadSpectrumVec[i][j][k]= float(powerLoadSpectrum[(i*powerLoadSpectrumDim[3]+j)*powerLoadSpectrumDim[1]+k] );
		}
	}
	// syscalType is an enumeration
	// SyscalMethod * syscalType =  (int) syscalType;
	// tAtmSpectrum is an Array
	// tAtmSpectrum is 2 D
	vector<vector<Temperature > >  tAtmSpectrumVec(tAtmSpectrumDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<tAtmSpectrumDim[2];i++) {
		tAtmSpectrumVec[i].resize(tAtmSpectrumDim[0]);
		for (int j=0;j<tAtmSpectrumDim[0];j++)
			tAtmSpectrumVec[i][j]= Temperature(tAtmSpectrum[i*tAtmSpectrumDim[1]+j]  );
	
	
	}
	// tRecSpectrum is an Array
	// tRecSpectrum is 2 D
	vector<vector<Temperature > >  tRecSpectrumVec(tRecSpectrumDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<tRecSpectrumDim[2];i++) {
		tRecSpectrumVec[i].resize(tRecSpectrumDim[0]);
		for (int j=0;j<tRecSpectrumDim[0];j++)
			tRecSpectrumVec[i][j]= Temperature(tRecSpectrum[i*tRecSpectrumDim[1]+j]  );
	
	
	}
	// tSysSpectrum is an Array
	// tSysSpectrum is 2 D
	vector<vector<Temperature > >  tSysSpectrumVec(tSysSpectrumDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<tSysSpectrumDim[2];i++) {
		tSysSpectrumVec[i].resize(tSysSpectrumDim[0]);
		for (int j=0;j<tSysSpectrumDim[0];j++)
			tSysSpectrumVec[i][j]= Temperature(tSysSpectrum[i*tSysSpectrumDim[1]+j]  );
	
	
	}
	// tauSpectrum is an Array
	// tauSpectrum is 2 D
	vector<vector<float > >  tauSpectrumVec(tauSpectrumDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<tauSpectrumDim[2];i++) {
		tauSpectrumVec[i].resize(tauSpectrumDim[0]);
		for (int j=0;j<tauSpectrumDim[0];j++)
			tauSpectrumVec[i][j]= float(tauSpectrum[i*tauSpectrumDim[1]+j]  );
	
	
	}
	// tAtm is an Array
	// tAtm is OneD
	vector<Temperature >  tAtmVec(tAtmDim[0]);
	for (int i=0;i<tAtmDim[0];i++)
		tAtmVec[i]= Temperature(tAtm[i]   );
	// tRec is an Array
	// tRec is OneD
	vector<Temperature >  tRecVec(tRecDim[0]);
	for (int i=0;i<tRecDim[0];i++)
		tRecVec[i]= Temperature(tRec[i]   );
	// tSys is an Array
	// tSys is OneD
	vector<Temperature >  tSysVec(tSysDim[0]);
	for (int i=0;i<tSysDim[0];i++)
		tSysVec[i]= Temperature(tSys[i]   );
	// tau is an Array
	// tau is OneD
	vector<float >  tauVec(tauDim[0]);
	for (int i=0;i<tauDim[0];i++)
		tauVec[i]= float(tau[i]   );
	// water is an Array
	// water is OneD
	vector<Length >  waterVec(waterDim[0]);
	for (int i=0;i<waterDim[0];i++)
		waterVec[i]= Length(water[i]   );
	// waterError is an Array
	// waterError is OneD
	vector<Length >  waterErrorVec(waterErrorDim[0]);
	for (int i=0;i<waterErrorDim[0];i++)
		waterErrorVec[i]= Length(waterError[i]   );
	
	// Create new row
  
	row = table.newRow(string(antennaName), *receiverBand, *basebandName, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), *numFreq, *numLoad, *numReceptor, forwardEffSpectrumVec, frequencyRangeVec, Pressure(*groundPressure), Humidity(*groundRelHumidity), frequencySpectrumVec, Temperature(*groundTemperature), polarizationTypesVec, powerSkySpectrumVec, powerLoadSpectrumVec, *syscalType, tAtmSpectrumVec, tRecSpectrumVec, tSysSpectrumVec, tauSpectrumVec, tAtmVec, tRecVec, tSysVec, tauVec, waterVec, waterErrorVec);

	// Add row
	CalAtmosphereRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalAtmosphereTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalAtmosphereRow* given a key.
 */
int sdm_getCalAtmosphereRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numFreq, int * numLoad, int * numReceptor, float * forwardEffSpectrum, int * forwardEffSpectrumDim, double * frequencyRange, int * frequencyRangeDim, double * groundPressure, double * groundRelHumidity, double * frequencySpectrum, int * frequencySpectrumDim, double * groundTemperature, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * powerSkySpectrum, int * powerSkySpectrumDim, float * powerLoadSpectrum, int * powerLoadSpectrumDim, SyscalMethod * syscalType, double * tAtmSpectrum, int * tAtmSpectrumDim, double * tRecSpectrum, int * tRecSpectrumDim, double * tSysSpectrum, int * tSysSpectrumDim, float * tauSpectrum, int * tauSpectrumDim, double * tAtm, int * tAtmDim, double * tRec, int * tRecDim, double * tSys, int * tSysDim, float * tau, int * tauDim, double * water, int * waterDim, double * waterError, int * waterErrorDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaName  attr.UpperCaseName: AntennaName
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		//  attr.NameS:  basebandName  attr.UpperCaseName: BasebandName
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  numFreq  attr.UpperCaseName: NumFreq
		*numFreq = row->getNumFreq();
		//  attr.NameS:  numLoad  attr.UpperCaseName: NumLoad
		*numLoad = row->getNumLoad();
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  forwardEffSpectrum  attr.UpperCaseName: ForwardEffSpectrum
		
		vector<vector<float > >  forwardEffSpectrumVec = row->getForwardEffSpectrum();
		
		int maxDimZeroForwardEffSpectrum = 0;
		for (int i=0;i<min((int)forwardEffSpectrumVec.size(),forwardEffSpectrumDim[3]) ;i++) {
			maxDimZeroForwardEffSpectrum = max((int)forwardEffSpectrumVec[i].size(),maxDimZeroForwardEffSpectrum);
			for (int j=0;j<min((int)forwardEffSpectrumVec[i].size(),forwardEffSpectrumDim[1]) ;j++) {
				forwardEffSpectrum[i*forwardEffSpectrumDim[1]+j]= forwardEffSpectrumVec[i][j];
			}
		}
		forwardEffSpectrumDim[0] = maxDimZeroForwardEffSpectrum;
		forwardEffSpectrumDim[2] = forwardEffSpectrumVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  frequencyRange  attr.UpperCaseName: FrequencyRange
		
		vector<Frequency >  frequencyRangeVec = row->getFrequencyRange();
		
		for (int i=0; i<min((int)frequencyRangeVec.size(),frequencyRangeDim[1]); i++)
			frequencyRange[i] = frequencyRangeVec[i].get();
		frequencyRangeDim[0] = frequencyRangeVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  groundPressure  attr.UpperCaseName: GroundPressure
		*groundPressure = row->getGroundPressure().get();
		//  attr.NameS:  groundRelHumidity  attr.UpperCaseName: GroundRelHumidity
		*groundRelHumidity = row->getGroundRelHumidity().get();
		//  attr.NameS:  frequencySpectrum  attr.UpperCaseName: FrequencySpectrum
		
		vector<Frequency >  frequencySpectrumVec = row->getFrequencySpectrum();
		
		for (int i=0; i<min((int)frequencySpectrumVec.size(),frequencySpectrumDim[1]); i++)
			frequencySpectrum[i] = frequencySpectrumVec[i].get();
		frequencySpectrumDim[0] = frequencySpectrumVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  groundTemperature  attr.UpperCaseName: GroundTemperature
		*groundTemperature = row->getGroundTemperature().get();
		//  attr.NameS:  polarizationTypes  attr.UpperCaseName: PolarizationTypes
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec = row->getPolarizationTypes();
		
		for (int i=0; i<min((int)polarizationTypesVec.size(),polarizationTypesDim[1]); i++)
			polarizationTypes[i] = polarizationTypesVec[i];
		polarizationTypesDim[0] = (int)polarizationTypesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  powerSkySpectrum  attr.UpperCaseName: PowerSkySpectrum
		
		vector<vector<float > >  powerSkySpectrumVec = row->getPowerSkySpectrum();
		
		int maxDimZeroPowerSkySpectrum = 0;
		for (int i=0;i<min((int)powerSkySpectrumVec.size(),powerSkySpectrumDim[3]) ;i++) {
			maxDimZeroPowerSkySpectrum = max((int)powerSkySpectrumVec[i].size(),maxDimZeroPowerSkySpectrum);
			for (int j=0;j<min((int)powerSkySpectrumVec[i].size(),powerSkySpectrumDim[1]) ;j++) {
				powerSkySpectrum[i*powerSkySpectrumDim[1]+j]= powerSkySpectrumVec[i][j];
			}
		}
		powerSkySpectrumDim[0] = maxDimZeroPowerSkySpectrum;
		powerSkySpectrumDim[2] = powerSkySpectrumVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  powerLoadSpectrum  attr.UpperCaseName: PowerLoadSpectrum
		
		vector<vector<vector<float > > >  powerLoadSpectrumVec = row->getPowerLoadSpectrum();
		int maxDimTwoPowerLoadSpectrum = 0;
		int maxDimZeroPowerLoadSpectrum = 0;
		for (int i=0; i<  min((int)powerLoadSpectrumVec.size(),powerLoadSpectrumDim[5]) ;i++) {
			maxDimTwoPowerLoadSpectrum = max((int)powerLoadSpectrumVec[i].size(),maxDimTwoPowerLoadSpectrum);
			for (int j=0;j< min((int)powerLoadSpectrumVec[i].size(),powerLoadSpectrumDim[3]) ;j++) {
				maxDimZeroPowerLoadSpectrum = max((int)powerLoadSpectrumVec[i][j].size(),maxDimZeroPowerLoadSpectrum);
				for (int k=0; k< min((int)powerLoadSpectrumVec[i][j].size(),powerLoadSpectrumDim[1]) ;k++) {
powerLoadSpectrum[(i*powerLoadSpectrumDim[3]+j)*powerLoadSpectrumDim[1]+k]= powerLoadSpectrumVec[i][j][k];
				}
			}
		}
		powerLoadSpectrumDim[0] = maxDimZeroPowerLoadSpectrum;
		powerLoadSpectrumDim[2] = maxDimTwoPowerLoadSpectrum;
		powerLoadSpectrumDim[4] = powerLoadSpectrumVec.size();  // return dimension of the ASDM table
		//  attr.NameS:  syscalType  attr.UpperCaseName: SyscalType
		*syscalType = row->getSyscalType();
		//  attr.NameS:  tAtmSpectrum  attr.UpperCaseName: TAtmSpectrum
		
		vector<vector<Temperature > >  tAtmSpectrumVec = row->getTAtmSpectrum();
		
		int maxDimZeroTAtmSpectrum = 0;
		for (int i=0; i< min((int)tAtmSpectrumVec.size(),tAtmSpectrumDim[3]) ;i++) {
			maxDimZeroTAtmSpectrum = max((int)tAtmSpectrumVec[i].size(),maxDimZeroTAtmSpectrum);
			for (int j=0; j<min((int)tAtmSpectrumVec[i].size(),tAtmSpectrumDim[1]) ;j++) {
				tAtmSpectrum[i*tAtmSpectrumDim[1]+j] = tAtmSpectrumVec[i][j].get();
			}
		}
		tAtmSpectrumDim[0] = maxDimZeroTAtmSpectrum;
		tAtmSpectrumDim[2] = tAtmSpectrumVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  tRecSpectrum  attr.UpperCaseName: TRecSpectrum
		
		vector<vector<Temperature > >  tRecSpectrumVec = row->getTRecSpectrum();
		
		int maxDimZeroTRecSpectrum = 0;
		for (int i=0; i< min((int)tRecSpectrumVec.size(),tRecSpectrumDim[3]) ;i++) {
			maxDimZeroTRecSpectrum = max((int)tRecSpectrumVec[i].size(),maxDimZeroTRecSpectrum);
			for (int j=0; j<min((int)tRecSpectrumVec[i].size(),tRecSpectrumDim[1]) ;j++) {
				tRecSpectrum[i*tRecSpectrumDim[1]+j] = tRecSpectrumVec[i][j].get();
			}
		}
		tRecSpectrumDim[0] = maxDimZeroTRecSpectrum;
		tRecSpectrumDim[2] = tRecSpectrumVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  tSysSpectrum  attr.UpperCaseName: TSysSpectrum
		
		vector<vector<Temperature > >  tSysSpectrumVec = row->getTSysSpectrum();
		
		int maxDimZeroTSysSpectrum = 0;
		for (int i=0; i< min((int)tSysSpectrumVec.size(),tSysSpectrumDim[3]) ;i++) {
			maxDimZeroTSysSpectrum = max((int)tSysSpectrumVec[i].size(),maxDimZeroTSysSpectrum);
			for (int j=0; j<min((int)tSysSpectrumVec[i].size(),tSysSpectrumDim[1]) ;j++) {
				tSysSpectrum[i*tSysSpectrumDim[1]+j] = tSysSpectrumVec[i][j].get();
			}
		}
		tSysSpectrumDim[0] = maxDimZeroTSysSpectrum;
		tSysSpectrumDim[2] = tSysSpectrumVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  tauSpectrum  attr.UpperCaseName: TauSpectrum
		
		vector<vector<float > >  tauSpectrumVec = row->getTauSpectrum();
		
		int maxDimZeroTauSpectrum = 0;
		for (int i=0;i<min((int)tauSpectrumVec.size(),tauSpectrumDim[3]) ;i++) {
			maxDimZeroTauSpectrum = max((int)tauSpectrumVec[i].size(),maxDimZeroTauSpectrum);
			for (int j=0;j<min((int)tauSpectrumVec[i].size(),tauSpectrumDim[1]) ;j++) {
				tauSpectrum[i*tauSpectrumDim[1]+j]= tauSpectrumVec[i][j];
			}
		}
		tauSpectrumDim[0] = maxDimZeroTauSpectrum;
		tauSpectrumDim[2] = tauSpectrumVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  tAtm  attr.UpperCaseName: TAtm
		
		vector<Temperature >  tAtmVec = row->getTAtm();
		
		for (int i=0; i<min((int)tAtmVec.size(),tAtmDim[1]); i++)
			tAtm[i] = tAtmVec[i].get();
		tAtmDim[0] = tAtmVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  tRec  attr.UpperCaseName: TRec
		
		vector<Temperature >  tRecVec = row->getTRec();
		
		for (int i=0; i<min((int)tRecVec.size(),tRecDim[1]); i++)
			tRec[i] = tRecVec[i].get();
		tRecDim[0] = tRecVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  tSys  attr.UpperCaseName: TSys
		
		vector<Temperature >  tSysVec = row->getTSys();
		
		for (int i=0; i<min((int)tSysVec.size(),tSysDim[1]); i++)
			tSys[i] = tSysVec[i].get();
		tSysDim[0] = tSysVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  tau  attr.UpperCaseName: Tau
		
		vector<float >  tauVec = row->getTau();
		
		for (int i=0; i<min((int)tauVec.size(),tauDim[1]); i++)
			tau[i] = tauVec[i];
		tauDim[0] = (int)tauVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  water  attr.UpperCaseName: Water
		
		vector<Length >  waterVec = row->getWater();
		
		for (int i=0; i<min((int)waterVec.size(),waterDim[1]); i++)
			water[i] = waterVec[i].get();
		waterDim[0] = waterVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  waterError  attr.UpperCaseName: WaterError
		
		vector<Length >  waterErrorVec = row->getWaterError();
		
		for (int i=0; i<min((int)waterErrorVec.size(),waterErrorDim[1]); i++)
			waterError[i] = waterErrorVec[i].get();
		waterErrorDim[0] = waterErrorVec.size(); // return dimension of the ASDM table
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalAtmosphereTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalAtmosphereTable &table = dataset->getCalAtmosphere();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalAtmosphereKeys(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	
	vector< CalAtmosphereRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroAntennaName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getAntennaName().size() < antennaNameDim[1])
	  			strcpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str());
	  		else
	  			strncpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str(),antennaNameDim[1]);
	  		maxDimZeroAntennaName = max((int)row[i]->getAntennaName().size(), maxDimZeroAntennaName);
	  		receiverBand[i] = row[i]->getReceiverBand();
	  		basebandName[i] = row[i]->getBasebandName();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
antennaNameDim[0] = maxDimZeroAntennaName ;
antennaNameDim[2] = size ;
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter alphaSpectrum, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_addCalAtmosphereAlphaSpectrum  sdm_addcalatmospherealphaspectrum_
extern "C" int sdm_addCalAtmosphereAlphaSpectrum(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * alphaSpectrum, int * alphaSpectrumDim);

int sdm_addCalAtmosphereAlphaSpectrum(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * alphaSpectrum, int * alphaSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par alphaSpectrum:
		vector<vector<float > >  alphaSpectrumVec(alphaSpectrumDim[2]);
		for (int i=0;i<alphaSpectrumDim[2];i++) {
			alphaSpectrumVec[i].resize(alphaSpectrumDim[0]);
			for (int j=0;j<alphaSpectrumDim[0];j++)
				alphaSpectrumVec[i][j]= float(alphaSpectrum[i*(alphaSpectrumDim[1])+j]);
		}
		row->setAlphaSpectrum(alphaSpectrumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter alphaSpectrum, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_getCalAtmosphereAlphaSpectrum  sdm_getcalatmospherealphaspectrum_
extern "C" int sdm_getCalAtmosphereAlphaSpectrum(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * alphaSpectrum, int * alphaSpectrumDim);

int sdm_getCalAtmosphereAlphaSpectrum(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * alphaSpectrum, int * alphaSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAlphaSpectrumExists()) {
			// attr.CppType: vector<vector<float > > attr.isOneD: false
			int maxDimZeroAlphaSpectrum = 0;
			for (int i=0;i<min((int)row->getAlphaSpectrum().size(),alphaSpectrumDim[3]) ;i++) {
				maxDimZeroAlphaSpectrum = max((int)row->getAlphaSpectrum()[i].size(),maxDimZeroAlphaSpectrum);
				for (int j=0;j<min((int)row->getAlphaSpectrum()[i].size(),alphaSpectrumDim[1]) ;j++) {
					alphaSpectrum[i*alphaSpectrumDim[1]+j]= row->getAlphaSpectrum()[i][j];
				}
			}
			alphaSpectrumDim[0] = maxDimZeroAlphaSpectrum;
			alphaSpectrumDim[2] = row->getAlphaSpectrum().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter forwardEfficiency, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_addCalAtmosphereForwardEfficiency  sdm_addcalatmosphereforwardefficiency_
extern "C" int sdm_addCalAtmosphereForwardEfficiency(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * forwardEfficiency, int * forwardEfficiencyDim);

int sdm_addCalAtmosphereForwardEfficiency(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * forwardEfficiency, int * forwardEfficiencyDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<float >  forwardEfficiencyVec(forwardEfficiencyDim[0]);
		for (int i=0;i<forwardEfficiencyDim[0];i++)
			forwardEfficiencyVec[i]= float(forwardEfficiency[i] );
		row->setForwardEfficiency(forwardEfficiencyVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter forwardEfficiency, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_getCalAtmosphereForwardEfficiency  sdm_getcalatmosphereforwardefficiency_
extern "C" int sdm_getCalAtmosphereForwardEfficiency(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * forwardEfficiency, int * forwardEfficiencyDim);

int sdm_getCalAtmosphereForwardEfficiency(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * forwardEfficiency, int * forwardEfficiencyDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isForwardEfficiencyExists()) {
			// attr.CppType: vector<float > attr.isOneD: true
			for (int i=0; i<min((int)row->getForwardEfficiency().size(),forwardEfficiencyDim[1]); i++)
				forwardEfficiency[i] = row->getForwardEfficiency()[i];
			forwardEfficiencyDim[0] = (int)row->getForwardEfficiency().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter forwardEfficiencyError, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_addCalAtmosphereForwardEfficiencyError  sdm_addcalatmosphereforwardefficiencyerror_
extern "C" int sdm_addCalAtmosphereForwardEfficiencyError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, double * forwardEfficiencyError, int * forwardEfficiencyErrorDim);

int sdm_addCalAtmosphereForwardEfficiencyError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, double * forwardEfficiencyError, int * forwardEfficiencyErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<double >  forwardEfficiencyErrorVec(forwardEfficiencyErrorDim[0]);
		for (int i=0;i<forwardEfficiencyErrorDim[0];i++)
			forwardEfficiencyErrorVec[i]= double(forwardEfficiencyError[i] );
		row->setForwardEfficiencyError(forwardEfficiencyErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter forwardEfficiencyError, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_getCalAtmosphereForwardEfficiencyError  sdm_getcalatmosphereforwardefficiencyerror_
extern "C" int sdm_getCalAtmosphereForwardEfficiencyError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, double * forwardEfficiencyError, int * forwardEfficiencyErrorDim);

int sdm_getCalAtmosphereForwardEfficiencyError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, double * forwardEfficiencyError, int * forwardEfficiencyErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isForwardEfficiencyErrorExists()) {
			// attr.CppType: vector<double > attr.isOneD: true
			for (int i=0; i<min((int)row->getForwardEfficiencyError().size(),forwardEfficiencyErrorDim[1]); i++)
				forwardEfficiencyError[i] = row->getForwardEfficiencyError()[i];
			forwardEfficiencyErrorDim[0] = (int)row->getForwardEfficiencyError().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sbGain, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_addCalAtmosphereSbGain  sdm_addcalatmospheresbgain_
extern "C" int sdm_addCalAtmosphereSbGain(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGain, int * sbGainDim);

int sdm_addCalAtmosphereSbGain(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGain, int * sbGainDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<float >  sbGainVec(sbGainDim[0]);
		for (int i=0;i<sbGainDim[0];i++)
			sbGainVec[i]= float(sbGain[i] );
		row->setSbGain(sbGainVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sbGain, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_getCalAtmosphereSbGain  sdm_getcalatmospheresbgain_
extern "C" int sdm_getCalAtmosphereSbGain(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGain, int * sbGainDim);

int sdm_getCalAtmosphereSbGain(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGain, int * sbGainDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSbGainExists()) {
			// attr.CppType: vector<float > attr.isOneD: true
			for (int i=0; i<min((int)row->getSbGain().size(),sbGainDim[1]); i++)
				sbGain[i] = row->getSbGain()[i];
			sbGainDim[0] = (int)row->getSbGain().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sbGainError, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_addCalAtmosphereSbGainError  sdm_addcalatmospheresbgainerror_
extern "C" int sdm_addCalAtmosphereSbGainError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGainError, int * sbGainErrorDim);

int sdm_addCalAtmosphereSbGainError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGainError, int * sbGainErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<float >  sbGainErrorVec(sbGainErrorDim[0]);
		for (int i=0;i<sbGainErrorDim[0];i++)
			sbGainErrorVec[i]= float(sbGainError[i] );
		row->setSbGainError(sbGainErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sbGainError, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_getCalAtmosphereSbGainError  sdm_getcalatmospheresbgainerror_
extern "C" int sdm_getCalAtmosphereSbGainError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGainError, int * sbGainErrorDim);

int sdm_getCalAtmosphereSbGainError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGainError, int * sbGainErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSbGainErrorExists()) {
			// attr.CppType: vector<float > attr.isOneD: true
			for (int i=0; i<min((int)row->getSbGainError().size(),sbGainErrorDim[1]); i++)
				sbGainError[i] = row->getSbGainError()[i];
			sbGainErrorDim[0] = (int)row->getSbGainError().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sbGainSpectrum, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_addCalAtmosphereSbGainSpectrum  sdm_addcalatmospheresbgainspectrum_
extern "C" int sdm_addCalAtmosphereSbGainSpectrum(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGainSpectrum, int * sbGainSpectrumDim);

int sdm_addCalAtmosphereSbGainSpectrum(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGainSpectrum, int * sbGainSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par sbGainSpectrum:
		vector<vector<float > >  sbGainSpectrumVec(sbGainSpectrumDim[2]);
		for (int i=0;i<sbGainSpectrumDim[2];i++) {
			sbGainSpectrumVec[i].resize(sbGainSpectrumDim[0]);
			for (int j=0;j<sbGainSpectrumDim[0];j++)
				sbGainSpectrumVec[i][j]= float(sbGainSpectrum[i*(sbGainSpectrumDim[1])+j]);
		}
		row->setSbGainSpectrum(sbGainSpectrumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sbGainSpectrum, in a row of the CalAtmosphere table, given a key
 *
 */

#define sdm_getCalAtmosphereSbGainSpectrum  sdm_getcalatmospheresbgainspectrum_
extern "C" int sdm_getCalAtmosphereSbGainSpectrum(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGainSpectrum, int * sbGainSpectrumDim);

int sdm_getCalAtmosphereSbGainSpectrum(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, BasebandName * basebandName, int * calDataId, int * calReductionId, float * sbGainSpectrum, int * sbGainSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalAtmosphereTable &table = dataset->getCalAtmosphere();
	CalAtmosphereRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *basebandName, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSbGainSpectrumExists()) {
			// attr.CppType: vector<vector<float > > attr.isOneD: false
			int maxDimZeroSbGainSpectrum = 0;
			for (int i=0;i<min((int)row->getSbGainSpectrum().size(),sbGainSpectrumDim[3]) ;i++) {
				maxDimZeroSbGainSpectrum = max((int)row->getSbGainSpectrum()[i].size(),maxDimZeroSbGainSpectrum);
				for (int j=0;j<min((int)row->getSbGainSpectrum()[i].size(),sbGainSpectrumDim[1]) ;j++) {
					sbGainSpectrum[i*sbGainSpectrumDim[1]+j]= row->getSbGainSpectrum()[i][j];
				}
			}
			sbGainSpectrumDim[0] = maxDimZeroSbGainSpectrum;
			sbGainSpectrumDim[2] = row->getSbGainSpectrum().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace BasebandNameMod;
using namespace NetSidebandMod;
using namespace AtmPhaseCorrectionMod;
using namespace CalCurveTypeMod;
using namespace ReceiverBandMod;
using namespace PolarizationTypeMod;


// =================== CalBandpassTable ============================

extern "C" int sdm_addCalBandpassRow (BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numAntenna, int * numPoly, int * numReceptor, char * antennaNames, int * antennaNamesDim, char * refAntennaName, int * refAntennaNameDim, double * freqLimits, int * freqLimitsDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * curve, int * curveDim, double * reducedChiSquared, int * reducedChiSquaredDim);
extern "C" int sdm_getCalBandpassRow (BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numAntenna, int * numPoly, int * numReceptor, char * antennaNames, int * antennaNamesDim, char * refAntennaName, int * refAntennaNameDim, double * freqLimits, int * freqLimitsDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * curve, int * curveDim, double * reducedChiSquared, int * reducedChiSquaredDim);


extern "C" int sdm_getCalBandpassTableSize ();

extern "C" int sdm_getCalBandpassKeys (BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalBandpassRow (BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numAntenna, int * numPoly, int * numReceptor, char * antennaNames, int * antennaNamesDim, char * refAntennaName, int * refAntennaNameDim, double * freqLimits, int * freqLimitsDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * curve, int * curveDim, double * reducedChiSquared, int * reducedChiSquaredDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalBandpassTable &table = dataset->getCalBandpass();
	CalBandpassRow *row = 0;

	// basebandName is an enumeration
	// BasebandName * basebandName =  (int) basebandName;
	// sideband is an enumeration
	// NetSideband * sideband =  (int) sideband;
	// atmPhaseCorrection is an enumeration
	// AtmPhaseCorrection * atmPhaseCorrection =  (int) atmPhaseCorrection;
	// typeCurve is an enumeration
	// CalCurveType * typeCurve =  (int) typeCurve;
	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// antennaNames is an Array
	// antennaNames is OneD
	vector<string >  antennaNamesVec(antennaNamesDim[2]);
	for (int i=0;i<antennaNamesDim[2];i++)
		antennaNamesVec[i]= string(antennaNames+i*antennaNamesDim[1]  );
	// freqLimits is an Array
	// freqLimits is OneD
	vector<Frequency >  freqLimitsVec(freqLimitsDim[0]);
	for (int i=0;i<freqLimitsDim[0];i++)
		freqLimitsVec[i]= Frequency(freqLimits[i]   );
	// polarizationTypes is an Array
	// polarizationTypes is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec(polarizationTypesDim[0]);
	for (int i=0;i<polarizationTypesDim[0];i++)
		polarizationTypesVec[i]= PolarizationType(polarizationTypes[i]   );
	// curve is an Array
	// curve is 3 D
	vector<vector<vector<float > > >  curveVec(curveDim[4]);   // Inversion of dim in fortran/C
	for (int i=0;i<curveDim[4];i++) {
		curveVec[i].resize(curveDim[2]);
		for (int j=0;j<curveDim[2];j++) {
			curveVec[i][j].resize(curveDim[0]);
			for (int k=0;k<curveDim[0];k++)
		    curveVec[i][j][k]= float(curve[(i*curveDim[3]+j)*curveDim[1]+k] );
		}
	}
	// reducedChiSquared is an Array
	// reducedChiSquared is OneD
	vector<double >  reducedChiSquaredVec(reducedChiSquaredDim[0]);
	for (int i=0;i<reducedChiSquaredDim[0];i++)
		reducedChiSquaredVec[i]= double(reducedChiSquared[i]   );
	
	// Create new row
  
	row = table.newRow(*basebandName, *sideband, *atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), *numAntenna, *numPoly, *numReceptor, antennaNamesVec, string(refAntennaName), freqLimitsVec, polarizationTypesVec, curveVec, reducedChiSquaredVec);

	// Add row
	CalBandpassRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalBandpassTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalBandpassRow* given a key.
 */
int sdm_getCalBandpassRow (BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numAntenna, int * numPoly, int * numReceptor, char * antennaNames, int * antennaNamesDim, char * refAntennaName, int * refAntennaNameDim, double * freqLimits, int * freqLimitsDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * curve, int * curveDim, double * reducedChiSquared, int * reducedChiSquaredDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalBandpassTable &table = dataset->getCalBandpass();
	CalBandpassRow *row = 0;
	row = table.getRowByKey( *basebandName, *sideband, *atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  basebandName  attr.UpperCaseName: BasebandName
		//  attr.NameS:  sideband  attr.UpperCaseName: Sideband
		//  attr.NameS:  atmPhaseCorrection  attr.UpperCaseName: AtmPhaseCorrection
		//  attr.NameS:  typeCurve  attr.UpperCaseName: TypeCurve
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  numAntenna  attr.UpperCaseName: NumAntenna
		*numAntenna = row->getNumAntenna();
		//  attr.NameS:  numPoly  attr.UpperCaseName: NumPoly
		*numPoly = row->getNumPoly();
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  antennaNames  attr.UpperCaseName: AntennaNames
		
		vector<string >  antennaNamesVec = row->getAntennaNames();
		
		int maxDimZeroAntennaNames = 0;
		for (int i=0; i<min((int)antennaNamesVec.size(),antennaNamesDim[3]); i++) {
			if ((int)antennaNamesVec[i].size()<antennaNamesDim[1])
				strcpy(antennaNames+i*antennaNamesDim[1],antennaNamesVec[i].c_str());
			else
				strncpy(antennaNames+i*antennaNamesDim[1],antennaNamesVec[i].c_str(),antennaNamesDim[1]);
			maxDimZeroAntennaNames = max((int)antennaNamesVec[i].size(),maxDimZeroAntennaNames);
		}
		antennaNamesDim[0] = maxDimZeroAntennaNames;
		antennaNamesDim[2] = antennaNamesVec.size();  // number of strings
		
		
		//  attr.NameS:  refAntennaName  attr.UpperCaseName: RefAntennaName
		if ((int)row->getRefAntennaName().size()<refAntennaNameDim[1])
			strcpy(refAntennaName,row->getRefAntennaName().c_str());
		else
			strncpy(refAntennaName,row->getRefAntennaName().c_str(),refAntennaNameDim[1]);
		refAntennaNameDim[0] = (int)row->getRefAntennaName().size();
		//  attr.NameS:  freqLimits  attr.UpperCaseName: FreqLimits
		
		vector<Frequency >  freqLimitsVec = row->getFreqLimits();
		
		for (int i=0; i<min((int)freqLimitsVec.size(),freqLimitsDim[1]); i++)
			freqLimits[i] = freqLimitsVec[i].get();
		freqLimitsDim[0] = freqLimitsVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  polarizationTypes  attr.UpperCaseName: PolarizationTypes
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec = row->getPolarizationTypes();
		
		for (int i=0; i<min((int)polarizationTypesVec.size(),polarizationTypesDim[1]); i++)
			polarizationTypes[i] = polarizationTypesVec[i];
		polarizationTypesDim[0] = (int)polarizationTypesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  curve  attr.UpperCaseName: Curve
		
		vector<vector<vector<float > > >  curveVec = row->getCurve();
		int maxDimTwoCurve = 0;
		int maxDimZeroCurve = 0;
		for (int i=0; i<  min((int)curveVec.size(),curveDim[5]) ;i++) {
			maxDimTwoCurve = max((int)curveVec[i].size(),maxDimTwoCurve);
			for (int j=0;j< min((int)curveVec[i].size(),curveDim[3]) ;j++) {
				maxDimZeroCurve = max((int)curveVec[i][j].size(),maxDimZeroCurve);
				for (int k=0; k< min((int)curveVec[i][j].size(),curveDim[1]) ;k++) {
curve[(i*curveDim[3]+j)*curveDim[1]+k]= curveVec[i][j][k];
				}
			}
		}
		curveDim[0] = maxDimZeroCurve;
		curveDim[2] = maxDimTwoCurve;
		curveDim[4] = curveVec.size();  // return dimension of the ASDM table
		//  attr.NameS:  reducedChiSquared  attr.UpperCaseName: ReducedChiSquared
		
		vector<double >  reducedChiSquaredVec = row->getReducedChiSquared();
		
		for (int i=0; i<min((int)reducedChiSquaredVec.size(),reducedChiSquaredDim[1]); i++)
			reducedChiSquared[i] = reducedChiSquaredVec[i];
		reducedChiSquaredDim[0] = (int)reducedChiSquaredVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalBandpassTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalBandpassTable &table = dataset->getCalBandpass();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalBandpassKeys(BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalBandpassTable &table = dataset->getCalBandpass();
	
	vector< CalBandpassRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		basebandName[i] = row[i]->getBasebandName();
	  		sideband[i] = row[i]->getSideband();
	  		atmPhaseCorrection[i] = row[i]->getAtmPhaseCorrection();
	  		typeCurve[i] = row[i]->getTypeCurve();
	  		receiverBand[i] = row[i]->getReceiverBand();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter numBaseline, in a row of the CalBandpass table, given a key
 *
 */

#define sdm_addCalBandpassNumBaseline  sdm_addcalbandpassnumbaseline_
extern "C" int sdm_addCalBandpassNumBaseline(BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numBaseline);

int sdm_addCalBandpassNumBaseline(BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numBaseline) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalBandpassTable &table = dataset->getCalBandpass();
	
	CalBandpassRow *row = 0;
	row = table.getRowByKey( *basebandName, *sideband, *atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumBaseline(int(* numBaseline ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numBaseline, in a row of the CalBandpass table, given a key
 *
 */

#define sdm_getCalBandpassNumBaseline  sdm_getcalbandpassnumbaseline_
extern "C" int sdm_getCalBandpassNumBaseline(BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numBaseline);

int sdm_getCalBandpassNumBaseline(BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numBaseline) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalBandpassTable &table = dataset->getCalBandpass();
	CalBandpassRow *row = 0;
	row = table.getRowByKey( *basebandName, *sideband, *atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumBaselineExists()) {
			*numBaseline = row->getNumBaseline();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter rms, in a row of the CalBandpass table, given a key
 *
 */

#define sdm_addCalBandpassRms  sdm_addcalbandpassrms_
extern "C" int sdm_addCalBandpassRms(BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, float * rms, int * rmsDim);

int sdm_addCalBandpassRms(BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, float * rms, int * rmsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalBandpassTable &table = dataset->getCalBandpass();
	
	CalBandpassRow *row = 0;
	row = table.getRowByKey( *basebandName, *sideband, *atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par rms:
		vector<vector<float > >  rmsVec(rmsDim[2]);
		for (int i=0;i<rmsDim[2];i++) {
			rmsVec[i].resize(rmsDim[0]);
			for (int j=0;j<rmsDim[0];j++)
				rmsVec[i][j]= float(rms[i*(rmsDim[1])+j]);
		}
		row->setRms(rmsVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter rms, in a row of the CalBandpass table, given a key
 *
 */

#define sdm_getCalBandpassRms  sdm_getcalbandpassrms_
extern "C" int sdm_getCalBandpassRms(BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, float * rms, int * rmsDim);

int sdm_getCalBandpassRms(BasebandName * basebandName, NetSideband * sideband, AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, float * rms, int * rmsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalBandpassTable &table = dataset->getCalBandpass();
	CalBandpassRow *row = 0;
	row = table.getRowByKey( *basebandName, *sideband, *atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isRmsExists()) {
			// attr.CppType: vector<vector<float > > attr.isOneD: false
			int maxDimZeroRms = 0;
			for (int i=0;i<min((int)row->getRms().size(),rmsDim[3]) ;i++) {
				maxDimZeroRms = max((int)row->getRms()[i].size(),maxDimZeroRms);
				for (int j=0;j<min((int)row->getRms()[i].size(),rmsDim[1]) ;j++) {
					rms[i*rmsDim[1]+j]= row->getRms()[i][j];
				}
			}
			rmsDim[0] = maxDimZeroRms;
			rmsDim[2] = row->getRms().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace AtmPhaseCorrectionMod;
using namespace CalCurveTypeMod;
using namespace ReceiverBandMod;
using namespace PolarizationTypeMod;


// =================== CalCurveTable ============================

extern "C" int sdm_addCalCurveRow (AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, int * numAntenna, int * numPoly, int * numReceptor, char * antennaNames, int * antennaNamesDim, char * refAntennaName, int * refAntennaNameDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * curve, int * curveDim, double * reducedChiSquared, int * reducedChiSquaredDim);
extern "C" int sdm_getCalCurveRow (AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, int * numAntenna, int * numPoly, int * numReceptor, char * antennaNames, int * antennaNamesDim, char * refAntennaName, int * refAntennaNameDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * curve, int * curveDim, double * reducedChiSquared, int * reducedChiSquaredDim);


extern "C" int sdm_getCalCurveTableSize ();

extern "C" int sdm_getCalCurveKeys (AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalCurveRow (AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, int * numAntenna, int * numPoly, int * numReceptor, char * antennaNames, int * antennaNamesDim, char * refAntennaName, int * refAntennaNameDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * curve, int * curveDim, double * reducedChiSquared, int * reducedChiSquaredDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalCurveTable &table = dataset->getCalCurve();
	CalCurveRow *row = 0;

	// atmPhaseCorrection is an enumeration
	// AtmPhaseCorrection * atmPhaseCorrection =  (int) atmPhaseCorrection;
	// typeCurve is an enumeration
	// CalCurveType * typeCurve =  (int) typeCurve;
	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// frequencyRange is an Array
	// frequencyRange is OneD
	vector<Frequency >  frequencyRangeVec(frequencyRangeDim[0]);
	for (int i=0;i<frequencyRangeDim[0];i++)
		frequencyRangeVec[i]= Frequency(frequencyRange[i]   );
	// antennaNames is an Array
	// antennaNames is OneD
	vector<string >  antennaNamesVec(antennaNamesDim[2]);
	for (int i=0;i<antennaNamesDim[2];i++)
		antennaNamesVec[i]= string(antennaNames+i*antennaNamesDim[1]  );
	// polarizationTypes is an Array
	// polarizationTypes is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec(polarizationTypesDim[0]);
	for (int i=0;i<polarizationTypesDim[0];i++)
		polarizationTypesVec[i]= PolarizationType(polarizationTypes[i]   );
	// curve is an Array
	// curve is 3 D
	vector<vector<vector<float > > >  curveVec(curveDim[4]);   // Inversion of dim in fortran/C
	for (int i=0;i<curveDim[4];i++) {
		curveVec[i].resize(curveDim[2]);
		for (int j=0;j<curveDim[2];j++) {
			curveVec[i][j].resize(curveDim[0]);
			for (int k=0;k<curveDim[0];k++)
		    curveVec[i][j][k]= float(curve[(i*curveDim[3]+j)*curveDim[1]+k] );
		}
	}
	// reducedChiSquared is an Array
	// reducedChiSquared is OneD
	vector<double >  reducedChiSquaredVec(reducedChiSquaredDim[0]);
	for (int i=0;i<reducedChiSquaredDim[0];i++)
		reducedChiSquaredVec[i]= double(reducedChiSquared[i]   );
	
	// Create new row
  
	row = table.newRow(*atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), frequencyRangeVec, *numAntenna, *numPoly, *numReceptor, antennaNamesVec, string(refAntennaName), polarizationTypesVec, curveVec, reducedChiSquaredVec);

	// Add row
	CalCurveRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalCurveTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalCurveRow* given a key.
 */
int sdm_getCalCurveRow (AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, int * numAntenna, int * numPoly, int * numReceptor, char * antennaNames, int * antennaNamesDim, char * refAntennaName, int * refAntennaNameDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * curve, int * curveDim, double * reducedChiSquared, int * reducedChiSquaredDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalCurveTable &table = dataset->getCalCurve();
	CalCurveRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  atmPhaseCorrection  attr.UpperCaseName: AtmPhaseCorrection
		//  attr.NameS:  typeCurve  attr.UpperCaseName: TypeCurve
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  frequencyRange  attr.UpperCaseName: FrequencyRange
		
		vector<Frequency >  frequencyRangeVec = row->getFrequencyRange();
		
		for (int i=0; i<min((int)frequencyRangeVec.size(),frequencyRangeDim[1]); i++)
			frequencyRange[i] = frequencyRangeVec[i].get();
		frequencyRangeDim[0] = frequencyRangeVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  numAntenna  attr.UpperCaseName: NumAntenna
		*numAntenna = row->getNumAntenna();
		//  attr.NameS:  numPoly  attr.UpperCaseName: NumPoly
		*numPoly = row->getNumPoly();
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  antennaNames  attr.UpperCaseName: AntennaNames
		
		vector<string >  antennaNamesVec = row->getAntennaNames();
		
		int maxDimZeroAntennaNames = 0;
		for (int i=0; i<min((int)antennaNamesVec.size(),antennaNamesDim[3]); i++) {
			if ((int)antennaNamesVec[i].size()<antennaNamesDim[1])
				strcpy(antennaNames+i*antennaNamesDim[1],antennaNamesVec[i].c_str());
			else
				strncpy(antennaNames+i*antennaNamesDim[1],antennaNamesVec[i].c_str(),antennaNamesDim[1]);
			maxDimZeroAntennaNames = max((int)antennaNamesVec[i].size(),maxDimZeroAntennaNames);
		}
		antennaNamesDim[0] = maxDimZeroAntennaNames;
		antennaNamesDim[2] = antennaNamesVec.size();  // number of strings
		
		
		//  attr.NameS:  refAntennaName  attr.UpperCaseName: RefAntennaName
		if ((int)row->getRefAntennaName().size()<refAntennaNameDim[1])
			strcpy(refAntennaName,row->getRefAntennaName().c_str());
		else
			strncpy(refAntennaName,row->getRefAntennaName().c_str(),refAntennaNameDim[1]);
		refAntennaNameDim[0] = (int)row->getRefAntennaName().size();
		//  attr.NameS:  polarizationTypes  attr.UpperCaseName: PolarizationTypes
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec = row->getPolarizationTypes();
		
		for (int i=0; i<min((int)polarizationTypesVec.size(),polarizationTypesDim[1]); i++)
			polarizationTypes[i] = polarizationTypesVec[i];
		polarizationTypesDim[0] = (int)polarizationTypesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  curve  attr.UpperCaseName: Curve
		
		vector<vector<vector<float > > >  curveVec = row->getCurve();
		int maxDimTwoCurve = 0;
		int maxDimZeroCurve = 0;
		for (int i=0; i<  min((int)curveVec.size(),curveDim[5]) ;i++) {
			maxDimTwoCurve = max((int)curveVec[i].size(),maxDimTwoCurve);
			for (int j=0;j< min((int)curveVec[i].size(),curveDim[3]) ;j++) {
				maxDimZeroCurve = max((int)curveVec[i][j].size(),maxDimZeroCurve);
				for (int k=0; k< min((int)curveVec[i][j].size(),curveDim[1]) ;k++) {
curve[(i*curveDim[3]+j)*curveDim[1]+k]= curveVec[i][j][k];
				}
			}
		}
		curveDim[0] = maxDimZeroCurve;
		curveDim[2] = maxDimTwoCurve;
		curveDim[4] = curveVec.size();  // return dimension of the ASDM table
		//  attr.NameS:  reducedChiSquared  attr.UpperCaseName: ReducedChiSquared
		
		vector<double >  reducedChiSquaredVec = row->getReducedChiSquared();
		
		for (int i=0; i<min((int)reducedChiSquaredVec.size(),reducedChiSquaredDim[1]); i++)
			reducedChiSquared[i] = reducedChiSquaredVec[i];
		reducedChiSquaredDim[0] = (int)reducedChiSquaredVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalCurveTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalCurveTable &table = dataset->getCalCurve();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalCurveKeys(AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalCurveTable &table = dataset->getCalCurve();
	
	vector< CalCurveRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		atmPhaseCorrection[i] = row[i]->getAtmPhaseCorrection();
	  		typeCurve[i] = row[i]->getTypeCurve();
	  		receiverBand[i] = row[i]->getReceiverBand();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter numBaseline, in a row of the CalCurve table, given a key
 *
 */

#define sdm_addCalCurveNumBaseline  sdm_addcalcurvenumbaseline_
extern "C" int sdm_addCalCurveNumBaseline(AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numBaseline);

int sdm_addCalCurveNumBaseline(AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numBaseline) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalCurveTable &table = dataset->getCalCurve();
	
	CalCurveRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumBaseline(int(* numBaseline ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numBaseline, in a row of the CalCurve table, given a key
 *
 */

#define sdm_getCalCurveNumBaseline  sdm_getcalcurvenumbaseline_
extern "C" int sdm_getCalCurveNumBaseline(AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numBaseline);

int sdm_getCalCurveNumBaseline(AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numBaseline) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalCurveTable &table = dataset->getCalCurve();
	CalCurveRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumBaselineExists()) {
			*numBaseline = row->getNumBaseline();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter rms, in a row of the CalCurve table, given a key
 *
 */

#define sdm_addCalCurveRms  sdm_addcalcurverms_
extern "C" int sdm_addCalCurveRms(AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, float * rms, int * rmsDim);

int sdm_addCalCurveRms(AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, float * rms, int * rmsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalCurveTable &table = dataset->getCalCurve();
	
	CalCurveRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par rms:
		vector<vector<float > >  rmsVec(rmsDim[2]);
		for (int i=0;i<rmsDim[2];i++) {
			rmsVec[i].resize(rmsDim[0]);
			for (int j=0;j<rmsDim[0];j++)
				rmsVec[i][j]= float(rms[i*(rmsDim[1])+j]);
		}
		row->setRms(rmsVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter rms, in a row of the CalCurve table, given a key
 *
 */

#define sdm_getCalCurveRms  sdm_getcalcurverms_
extern "C" int sdm_getCalCurveRms(AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, float * rms, int * rmsDim);

int sdm_getCalCurveRms(AtmPhaseCorrection * atmPhaseCorrection, CalCurveType * typeCurve, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, float * rms, int * rmsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalCurveTable &table = dataset->getCalCurve();
	CalCurveRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, *typeCurve, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isRmsExists()) {
			// attr.CppType: vector<vector<float > > attr.isOneD: false
			int maxDimZeroRms = 0;
			for (int i=0;i<min((int)row->getRms().size(),rmsDim[3]) ;i++) {
				maxDimZeroRms = max((int)row->getRms()[i].size(),maxDimZeroRms);
				for (int j=0;j<min((int)row->getRms()[i].size(),rmsDim[1]) ;j++) {
					rms[i*rmsDim[1]+j]= row->getRms()[i][j];
				}
			}
			rmsDim[0] = maxDimZeroRms;
			rmsDim[2] = row->getRms().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace CalDataOriginMod;
using namespace CalTypeMod;
using namespace AssociatedCalNatureMod;
using namespace ScanIntentMod;


// =================== CalDataTable ============================

extern "C" int sdm_addCalDataRow (int64_t * startTimeObserved, int64_t * endTimeObserved, char * execBlockUID, int * execBlockUIDDim, CalDataOrigin * calDataType, CalType * calType, int * numScan, int * scanSet, int * scanSetDim);
extern "C" int sdm_getCalDataRow (int * calDataId, int64_t * startTimeObserved, int64_t * endTimeObserved, char * execBlockUID, int * execBlockUIDDim, CalDataOrigin * calDataType, CalType * calType, int * numScan, int * scanSet, int * scanSetDim);


extern "C" int sdm_getCalDataTableSize ();

extern "C" int sdm_getCalDataKeys (int * calDataId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalDataRow (int64_t * startTimeObserved, int64_t * endTimeObserved, char * execBlockUID, int * execBlockUIDDim, CalDataOrigin * calDataType, CalType * calType, int * numScan, int * scanSet, int * scanSetDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalDataTable &table = dataset->getCalData();
	CalDataRow *row = 0;

	// calDataType is an enumeration
	// CalDataOrigin * calDataType =  (int) calDataType;
	// calType is an enumeration
	// CalType * calType =  (int) calType;
	// scanSet is an Array
	// scanSet is OneD
	vector<int >  scanSetVec(scanSetDim[0]);
	for (int i=0;i<scanSetDim[0];i++)
		scanSetVec[i]= int(scanSet[i]   );
	
	// Create new row
  
	row = table.newRow(ArrayTime(*startTimeObserved), ArrayTime(*endTimeObserved), EntityRef(string(execBlockUID)), *calDataType, *calType, *numScan, scanSetVec);

	// Add row
	CalDataRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalDataTable" << endl;
	}
	
	// return atoi((retRow->getCalDataId().getId()).c_str());
	return retRow->getCalDataId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalDataRow* given a key.
 */
int sdm_getCalDataRow (int * calDataId, int64_t * startTimeObserved, int64_t * endTimeObserved, char * execBlockUID, int * execBlockUIDDim, CalDataOrigin * calDataType, CalType * calType, int * numScan, int * scanSet, int * scanSetDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDataTable &table = dataset->getCalData();
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  startTimeObserved  attr.UpperCaseName: StartTimeObserved
		*startTimeObserved     = row->getStartTimeObserved().get();
		//  attr.NameS:  endTimeObserved  attr.UpperCaseName: EndTimeObserved
		*endTimeObserved     = row->getEndTimeObserved().get();
		//  attr.NameS:  execBlockUID  attr.UpperCaseName: ExecBlockUID
		strcpy(execBlockUID,row->getExecBlockUID().toString().c_str());
		//  attr.NameS:  calDataType  attr.UpperCaseName: CalDataType
		*calDataType = row->getCalDataType();
		//  attr.NameS:  calType  attr.UpperCaseName: CalType
		*calType = row->getCalType();
		//  attr.NameS:  numScan  attr.UpperCaseName: NumScan
		*numScan = row->getNumScan();
		//  attr.NameS:  scanSet  attr.UpperCaseName: ScanSet
		
		vector<int >  scanSetVec = row->getScanSet();
		
		for (int i=0; i<min((int)scanSetVec.size(),scanSetDim[1]); i++)
			scanSet[i] = scanSetVec[i];
		scanSetDim[0] = (int)scanSetVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalDataTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalDataTable &table = dataset->getCalData();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalDataKeys(int * calDataId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalDataTable &table = dataset->getCalData();
	
	vector< CalDataRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter assocCalDataId, in a row of the CalData table, given a key
 *
 */

#define sdm_addCalDataAssocCalDataId  sdm_addcaldataassoccaldataid_
extern "C" int sdm_addCalDataAssocCalDataId(int * calDataId, int * assocCalDataId);

int sdm_addCalDataAssocCalDataId(int * calDataId, int * assocCalDataId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDataTable &table = dataset->getCalData();
	
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setAssocCalDataId(Tag(* assocCalDataId , TagType::CalData));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter assocCalDataId, in a row of the CalData table, given a key
 *
 */

#define sdm_getCalDataAssocCalDataId  sdm_getcaldataassoccaldataid_
extern "C" int sdm_getCalDataAssocCalDataId(int * calDataId, int * assocCalDataId);

int sdm_getCalDataAssocCalDataId(int * calDataId, int * assocCalDataId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDataTable &table = dataset->getCalData();
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAssocCalDataIdExists()) {
			// *assocCalDataId = atoi((row->getAssocCalDataId().getId()).c_str());
			*assocCalDataId = row->getAssocCalDataId().getTagValue();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter assocCalNature, in a row of the CalData table, given a key
 *
 */

#define sdm_addCalDataAssocCalNature  sdm_addcaldataassoccalnature_
extern "C" int sdm_addCalDataAssocCalNature(int * calDataId, AssociatedCalNature * assocCalNature);

int sdm_addCalDataAssocCalNature(int * calDataId, AssociatedCalNature * assocCalNature) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDataTable &table = dataset->getCalData();
	
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setAssocCalNature(AssociatedCalNature(* assocCalNature ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter assocCalNature, in a row of the CalData table, given a key
 *
 */

#define sdm_getCalDataAssocCalNature  sdm_getcaldataassoccalnature_
extern "C" int sdm_getCalDataAssocCalNature(int * calDataId, AssociatedCalNature * assocCalNature);

int sdm_getCalDataAssocCalNature(int * calDataId, AssociatedCalNature * assocCalNature) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDataTable &table = dataset->getCalData();
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAssocCalNatureExists()) {
			*assocCalNature = row->getAssocCalNature();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter fieldName, in a row of the CalData table, given a key
 *
 */

#define sdm_addCalDataFieldName  sdm_addcaldatafieldname_
extern "C" int sdm_addCalDataFieldName(int * calDataId, char * fieldName, int * fieldNameDim);

int sdm_addCalDataFieldName(int * calDataId, char * fieldName, int * fieldNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDataTable &table = dataset->getCalData();
	
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<string >  fieldNameVec(fieldNameDim[2]);
		for (int i=0;i<fieldNameDim[2];i++)
			fieldNameVec[i]= string(fieldName+i*fieldNameDim[1]  
		row->setFieldName(fieldNameVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter fieldName, in a row of the CalData table, given a key
 *
 */

#define sdm_getCalDataFieldName  sdm_getcaldatafieldname_
extern "C" int sdm_getCalDataFieldName(int * calDataId, char * fieldName, int * fieldNameDim);

int sdm_getCalDataFieldName(int * calDataId, char * fieldName, int * fieldNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDataTable &table = dataset->getCalData();
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFieldNameExists()) {
			// attr.CppType: vector<string > attr.isOneD: true
			int maxDimZeroFieldName = 0;
			for (int i=0; i<min((int)row->getFieldName().size(),fieldNameDim[3]); i++) {
				if ((int)row->getFieldName()[i].size()<fieldNameDim[1])
					strcpy(fieldName+i*fieldNameDim[1],row->getFieldName()[i].c_str());
				else
					strncpy(fieldName+i*fieldNameDim[1],row->getFieldName()[i].c_str(),fieldNameDim[1]);
				maxDimZeroFieldName = max((int)row->getFieldName()[i].size(),maxDimZeroFieldName);
			}
			fieldNameDim[0] = maxDimZeroFieldName;
			fieldNameDim[2] = row->getFieldName().size();  // number of strings
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sourceName, in a row of the CalData table, given a key
 *
 */

#define sdm_addCalDataSourceName  sdm_addcaldatasourcename_
extern "C" int sdm_addCalDataSourceName(int * calDataId, char * sourceName, int * sourceNameDim);

int sdm_addCalDataSourceName(int * calDataId, char * sourceName, int * sourceNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDataTable &table = dataset->getCalData();
	
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<string >  sourceNameVec(sourceNameDim[2]);
		for (int i=0;i<sourceNameDim[2];i++)
			sourceNameVec[i]= string(sourceName+i*sourceNameDim[1]  
		row->setSourceName(sourceNameVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sourceName, in a row of the CalData table, given a key
 *
 */

#define sdm_getCalDataSourceName  sdm_getcaldatasourcename_
extern "C" int sdm_getCalDataSourceName(int * calDataId, char * sourceName, int * sourceNameDim);

int sdm_getCalDataSourceName(int * calDataId, char * sourceName, int * sourceNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDataTable &table = dataset->getCalData();
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSourceNameExists()) {
			// attr.CppType: vector<string > attr.isOneD: true
			int maxDimZeroSourceName = 0;
			for (int i=0; i<min((int)row->getSourceName().size(),sourceNameDim[3]); i++) {
				if ((int)row->getSourceName()[i].size()<sourceNameDim[1])
					strcpy(sourceName+i*sourceNameDim[1],row->getSourceName()[i].c_str());
				else
					strncpy(sourceName+i*sourceNameDim[1],row->getSourceName()[i].c_str(),sourceNameDim[1]);
				maxDimZeroSourceName = max((int)row->getSourceName()[i].size(),maxDimZeroSourceName);
			}
			sourceNameDim[0] = maxDimZeroSourceName;
			sourceNameDim[2] = row->getSourceName().size();  // number of strings
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sourceCode, in a row of the CalData table, given a key
 *
 */

#define sdm_addCalDataSourceCode  sdm_addcaldatasourcecode_
extern "C" int sdm_addCalDataSourceCode(int * calDataId, char * sourceCode, int * sourceCodeDim);

int sdm_addCalDataSourceCode(int * calDataId, char * sourceCode, int * sourceCodeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDataTable &table = dataset->getCalData();
	
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<string >  sourceCodeVec(sourceCodeDim[2]);
		for (int i=0;i<sourceCodeDim[2];i++)
			sourceCodeVec[i]= string(sourceCode+i*sourceCodeDim[1]  
		row->setSourceCode(sourceCodeVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sourceCode, in a row of the CalData table, given a key
 *
 */

#define sdm_getCalDataSourceCode  sdm_getcaldatasourcecode_
extern "C" int sdm_getCalDataSourceCode(int * calDataId, char * sourceCode, int * sourceCodeDim);

int sdm_getCalDataSourceCode(int * calDataId, char * sourceCode, int * sourceCodeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDataTable &table = dataset->getCalData();
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSourceCodeExists()) {
			// attr.CppType: vector<string > attr.isOneD: true
			int maxDimZeroSourceCode = 0;
			for (int i=0; i<min((int)row->getSourceCode().size(),sourceCodeDim[3]); i++) {
				if ((int)row->getSourceCode()[i].size()<sourceCodeDim[1])
					strcpy(sourceCode+i*sourceCodeDim[1],row->getSourceCode()[i].c_str());
				else
					strncpy(sourceCode+i*sourceCodeDim[1],row->getSourceCode()[i].c_str(),sourceCodeDim[1]);
				maxDimZeroSourceCode = max((int)row->getSourceCode()[i].size(),maxDimZeroSourceCode);
			}
			sourceCodeDim[0] = maxDimZeroSourceCode;
			sourceCodeDim[2] = row->getSourceCode().size();  // number of strings
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter scanIntent, in a row of the CalData table, given a key
 *
 */

#define sdm_addCalDataScanIntent  sdm_addcaldatascanintent_
extern "C" int sdm_addCalDataScanIntent(int * calDataId, ScanIntent * scanIntent, int * scanIntentDim);

int sdm_addCalDataScanIntent(int * calDataId, ScanIntent * scanIntent, int * scanIntentDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDataTable &table = dataset->getCalData();
	
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<ScanIntentMod::ScanIntent >  scanIntentVec(scanIntentDim[0]);
		for (int i=0;i<scanIntentDim[0];i++)
			scanIntentVec[i]= ScanIntent(scanIntent[i] );
		row->setScanIntent(scanIntentVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter scanIntent, in a row of the CalData table, given a key
 *
 */

#define sdm_getCalDataScanIntent  sdm_getcaldatascanintent_
extern "C" int sdm_getCalDataScanIntent(int * calDataId, ScanIntent * scanIntent, int * scanIntentDim);

int sdm_getCalDataScanIntent(int * calDataId, ScanIntent * scanIntent, int * scanIntentDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDataTable &table = dataset->getCalData();
	CalDataRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isScanIntentExists()) {
			// attr.CppType: vector<ScanIntentMod::ScanIntent > attr.isOneD: true
			for (int i=0; i<min((int)row->getScanIntent().size(),scanIntentDim[1]); i++)
				scanIntent[i] = row->getScanIntent()[i];
			scanIntentDim[0] = (int)row->getScanIntent().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace AtmPhaseCorrectionMod;
using namespace BasebandNameMod;
using namespace ReceiverBandMod;
using namespace PolarizationTypeMod;
using namespace ReceiverSidebandMod;


// =================== CalDelayTable ============================

extern "C" int sdm_addCalDelayRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, char * refAntennaName, int * refAntennaNameDim, int * numReceptor, double * delayError, int * delayErrorDim, double * delayOffset, int * delayOffsetDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * reducedChiSquared, int * reducedChiSquaredDim, double * appliedDelay, int * appliedDelayDim);
extern "C" int sdm_getCalDelayRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, char * refAntennaName, int * refAntennaNameDim, int * numReceptor, double * delayError, int * delayErrorDim, double * delayOffset, int * delayOffsetDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * reducedChiSquared, int * reducedChiSquaredDim, double * appliedDelay, int * appliedDelayDim);


extern "C" int sdm_getCalDelayTableSize ();

extern "C" int sdm_getCalDelayKeys (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalDelayRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, char * refAntennaName, int * refAntennaNameDim, int * numReceptor, double * delayError, int * delayErrorDim, double * delayOffset, int * delayOffsetDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * reducedChiSquared, int * reducedChiSquaredDim, double * appliedDelay, int * appliedDelayDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalDelayTable &table = dataset->getCalDelay();
	CalDelayRow *row = 0;

	// atmPhaseCorrection is an enumeration
	// AtmPhaseCorrection * atmPhaseCorrection =  (int) atmPhaseCorrection;
	// basebandName is an enumeration
	// BasebandName * basebandName =  (int) basebandName;
	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// delayError is an Array
	// delayError is OneD
	vector<double >  delayErrorVec(delayErrorDim[0]);
	for (int i=0;i<delayErrorDim[0];i++)
		delayErrorVec[i]= double(delayError[i]   );
	// delayOffset is an Array
	// delayOffset is OneD
	vector<double >  delayOffsetVec(delayOffsetDim[0]);
	for (int i=0;i<delayOffsetDim[0];i++)
		delayOffsetVec[i]= double(delayOffset[i]   );
	// polarizationTypes is an Array
	// polarizationTypes is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec(polarizationTypesDim[0]);
	for (int i=0;i<polarizationTypesDim[0];i++)
		polarizationTypesVec[i]= PolarizationType(polarizationTypes[i]   );
	// reducedChiSquared is an Array
	// reducedChiSquared is OneD
	vector<double >  reducedChiSquaredVec(reducedChiSquaredDim[0]);
	for (int i=0;i<reducedChiSquaredDim[0];i++)
		reducedChiSquaredVec[i]= double(reducedChiSquared[i]   );
	// appliedDelay is an Array
	// appliedDelay is OneD
	vector<double >  appliedDelayVec(appliedDelayDim[0]);
	for (int i=0;i<appliedDelayDim[0];i++)
		appliedDelayVec[i]= double(appliedDelay[i]   );
	
	// Create new row
  
	row = table.newRow(string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), string(refAntennaName), *numReceptor, delayErrorVec, delayOffsetVec, polarizationTypesVec, reducedChiSquaredVec, appliedDelayVec);

	// Add row
	CalDelayRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalDelayTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalDelayRow* given a key.
 */
int sdm_getCalDelayRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, char * refAntennaName, int * refAntennaNameDim, int * numReceptor, double * delayError, int * delayErrorDim, double * delayOffset, int * delayOffsetDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * reducedChiSquared, int * reducedChiSquaredDim, double * appliedDelay, int * appliedDelayDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDelayTable &table = dataset->getCalDelay();
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaName  attr.UpperCaseName: AntennaName
		//  attr.NameS:  atmPhaseCorrection  attr.UpperCaseName: AtmPhaseCorrection
		//  attr.NameS:  basebandName  attr.UpperCaseName: BasebandName
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  refAntennaName  attr.UpperCaseName: RefAntennaName
		if ((int)row->getRefAntennaName().size()<refAntennaNameDim[1])
			strcpy(refAntennaName,row->getRefAntennaName().c_str());
		else
			strncpy(refAntennaName,row->getRefAntennaName().c_str(),refAntennaNameDim[1]);
		refAntennaNameDim[0] = (int)row->getRefAntennaName().size();
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  delayError  attr.UpperCaseName: DelayError
		
		vector<double >  delayErrorVec = row->getDelayError();
		
		for (int i=0; i<min((int)delayErrorVec.size(),delayErrorDim[1]); i++)
			delayError[i] = delayErrorVec[i];
		delayErrorDim[0] = (int)delayErrorVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  delayOffset  attr.UpperCaseName: DelayOffset
		
		vector<double >  delayOffsetVec = row->getDelayOffset();
		
		for (int i=0; i<min((int)delayOffsetVec.size(),delayOffsetDim[1]); i++)
			delayOffset[i] = delayOffsetVec[i];
		delayOffsetDim[0] = (int)delayOffsetVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  polarizationTypes  attr.UpperCaseName: PolarizationTypes
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec = row->getPolarizationTypes();
		
		for (int i=0; i<min((int)polarizationTypesVec.size(),polarizationTypesDim[1]); i++)
			polarizationTypes[i] = polarizationTypesVec[i];
		polarizationTypesDim[0] = (int)polarizationTypesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  reducedChiSquared  attr.UpperCaseName: ReducedChiSquared
		
		vector<double >  reducedChiSquaredVec = row->getReducedChiSquared();
		
		for (int i=0; i<min((int)reducedChiSquaredVec.size(),reducedChiSquaredDim[1]); i++)
			reducedChiSquared[i] = reducedChiSquaredVec[i];
		reducedChiSquaredDim[0] = (int)reducedChiSquaredVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  appliedDelay  attr.UpperCaseName: AppliedDelay
		
		vector<double >  appliedDelayVec = row->getAppliedDelay();
		
		for (int i=0; i<min((int)appliedDelayVec.size(),appliedDelayDim[1]); i++)
			appliedDelay[i] = appliedDelayVec[i];
		appliedDelayDim[0] = (int)appliedDelayVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalDelayTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalDelayTable &table = dataset->getCalDelay();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalDelayKeys(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalDelayTable &table = dataset->getCalDelay();
	
	vector< CalDelayRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroAntennaName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getAntennaName().size() < antennaNameDim[1])
	  			strcpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str());
	  		else
	  			strncpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str(),antennaNameDim[1]);
	  		maxDimZeroAntennaName = max((int)row[i]->getAntennaName().size(), maxDimZeroAntennaName);
	  		atmPhaseCorrection[i] = row[i]->getAtmPhaseCorrection();
	  		basebandName[i] = row[i]->getBasebandName();
	  		receiverBand[i] = row[i]->getReceiverBand();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
antennaNameDim[0] = maxDimZeroAntennaName ;
antennaNameDim[2] = size ;
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter crossDelayOffset, in a row of the CalDelay table, given a key
 *
 */

#define sdm_addCalDelayCrossDelayOffset  sdm_addcaldelaycrossdelayoffset_
extern "C" int sdm_addCalDelayCrossDelayOffset(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * crossDelayOffset);

int sdm_addCalDelayCrossDelayOffset(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * crossDelayOffset) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDelayTable &table = dataset->getCalDelay();
	
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCrossDelayOffset(double(* crossDelayOffset ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter crossDelayOffset, in a row of the CalDelay table, given a key
 *
 */

#define sdm_getCalDelayCrossDelayOffset  sdm_getcaldelaycrossdelayoffset_
extern "C" int sdm_getCalDelayCrossDelayOffset(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * crossDelayOffset);

int sdm_getCalDelayCrossDelayOffset(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * crossDelayOffset) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDelayTable &table = dataset->getCalDelay();
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCrossDelayOffsetExists()) {
			*crossDelayOffset = row->getCrossDelayOffset();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter crossDelayOffsetError, in a row of the CalDelay table, given a key
 *
 */

#define sdm_addCalDelayCrossDelayOffsetError  sdm_addcaldelaycrossdelayoffseterror_
extern "C" int sdm_addCalDelayCrossDelayOffsetError(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * crossDelayOffsetError);

int sdm_addCalDelayCrossDelayOffsetError(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * crossDelayOffsetError) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDelayTable &table = dataset->getCalDelay();
	
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCrossDelayOffsetError(double(* crossDelayOffsetError ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter crossDelayOffsetError, in a row of the CalDelay table, given a key
 *
 */

#define sdm_getCalDelayCrossDelayOffsetError  sdm_getcaldelaycrossdelayoffseterror_
extern "C" int sdm_getCalDelayCrossDelayOffsetError(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * crossDelayOffsetError);

int sdm_getCalDelayCrossDelayOffsetError(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * crossDelayOffsetError) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDelayTable &table = dataset->getCalDelay();
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCrossDelayOffsetErrorExists()) {
			*crossDelayOffsetError = row->getCrossDelayOffsetError();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numSideband, in a row of the CalDelay table, given a key
 *
 */

#define sdm_addCalDelayNumSideband  sdm_addcaldelaynumsideband_
extern "C" int sdm_addCalDelayNumSideband(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numSideband);

int sdm_addCalDelayNumSideband(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numSideband) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDelayTable &table = dataset->getCalDelay();
	
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumSideband(int(* numSideband ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numSideband, in a row of the CalDelay table, given a key
 *
 */

#define sdm_getCalDelayNumSideband  sdm_getcaldelaynumsideband_
extern "C" int sdm_getCalDelayNumSideband(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numSideband);

int sdm_getCalDelayNumSideband(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numSideband) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDelayTable &table = dataset->getCalDelay();
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumSidebandExists()) {
			*numSideband = row->getNumSideband();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter refFreq, in a row of the CalDelay table, given a key
 *
 */

#define sdm_addCalDelayRefFreq  sdm_addcaldelayreffreq_
extern "C" int sdm_addCalDelayRefFreq(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * refFreq, int * refFreqDim);

int sdm_addCalDelayRefFreq(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * refFreq, int * refFreqDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDelayTable &table = dataset->getCalDelay();
	
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Frequency >  refFreqVec(refFreqDim[0]);
		for (int i=0;i<refFreqDim[0];i++)
			refFreqVec[i]= Frequency(refFreq[i] );
		row->setRefFreq(refFreqVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter refFreq, in a row of the CalDelay table, given a key
 *
 */

#define sdm_getCalDelayRefFreq  sdm_getcaldelayreffreq_
extern "C" int sdm_getCalDelayRefFreq(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * refFreq, int * refFreqDim);

int sdm_getCalDelayRefFreq(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * refFreq, int * refFreqDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDelayTable &table = dataset->getCalDelay();
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isRefFreqExists()) {
			// attr.CppType: vector<Frequency > attr.isOneD: true
			for (int i=0; i<min((int)row->getRefFreq().size(),refFreqDim[1]); i++)
				refFreq[i] = row->getRefFreq()[i].get();
			refFreqDim[0] = row->getRefFreq().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter refFreqPhase, in a row of the CalDelay table, given a key
 *
 */

#define sdm_addCalDelayRefFreqPhase  sdm_addcaldelayreffreqphase_
extern "C" int sdm_addCalDelayRefFreqPhase(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * refFreqPhase, int * refFreqPhaseDim);

int sdm_addCalDelayRefFreqPhase(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * refFreqPhase, int * refFreqPhaseDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDelayTable &table = dataset->getCalDelay();
	
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Angle >  refFreqPhaseVec(refFreqPhaseDim[0]);
		for (int i=0;i<refFreqPhaseDim[0];i++)
			refFreqPhaseVec[i]= Angle(refFreqPhase[i] );
		row->setRefFreqPhase(refFreqPhaseVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter refFreqPhase, in a row of the CalDelay table, given a key
 *
 */

#define sdm_getCalDelayRefFreqPhase  sdm_getcaldelayreffreqphase_
extern "C" int sdm_getCalDelayRefFreqPhase(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * refFreqPhase, int * refFreqPhaseDim);

int sdm_getCalDelayRefFreqPhase(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * refFreqPhase, int * refFreqPhaseDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDelayTable &table = dataset->getCalDelay();
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isRefFreqPhaseExists()) {
			// attr.CppType: vector<Angle > attr.isOneD: true
			for (int i=0; i<min((int)row->getRefFreqPhase().size(),refFreqPhaseDim[1]); i++)
				refFreqPhase[i] = row->getRefFreqPhase()[i].get();
			refFreqPhaseDim[0] = row->getRefFreqPhase().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sidebands, in a row of the CalDelay table, given a key
 *
 */

#define sdm_addCalDelaySidebands  sdm_addcaldelaysidebands_
extern "C" int sdm_addCalDelaySidebands(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, ReceiverSideband * sidebands, int * sidebandsDim);

int sdm_addCalDelaySidebands(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, ReceiverSideband * sidebands, int * sidebandsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDelayTable &table = dataset->getCalDelay();
	
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<ReceiverSidebandMod::ReceiverSideband >  sidebandsVec(sidebandsDim[0]);
		for (int i=0;i<sidebandsDim[0];i++)
			sidebandsVec[i]= ReceiverSideband(sidebands[i] );
		row->setSidebands(sidebandsVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sidebands, in a row of the CalDelay table, given a key
 *
 */

#define sdm_getCalDelaySidebands  sdm_getcaldelaysidebands_
extern "C" int sdm_getCalDelaySidebands(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, ReceiverSideband * sidebands, int * sidebandsDim);

int sdm_getCalDelaySidebands(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, BasebandName * basebandName, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, ReceiverSideband * sidebands, int * sidebandsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDelayTable &table = dataset->getCalDelay();
	CalDelayRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, *basebandName, *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSidebandsExists()) {
			// attr.CppType: vector<ReceiverSidebandMod::ReceiverSideband > attr.isOneD: true
			for (int i=0; i<min((int)row->getSidebands().size(),sidebandsDim[1]); i++)
				sidebands[i] = row->getSidebands()[i];
			sidebandsDim[0] = (int)row->getSidebands().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace CalibrationDeviceMod;


// =================== CalDeviceTable ============================

extern "C" int sdm_addCalDeviceRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numCalload, CalibrationDevice * calLoadNames, int * calLoadNamesDim);
extern "C" int sdm_getCalDeviceRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numCalload, CalibrationDevice * calLoadNames, int * calLoadNamesDim);


extern "C" int sdm_getCalDeviceTableSize ();

extern "C" int sdm_getCalDeviceKeys (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalDeviceRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numCalload, CalibrationDevice * calLoadNames, int * calLoadNamesDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalDeviceTable &table = dataset->getCalDevice();
	CalDeviceRow *row = 0;

	// calLoadNames is an Array
	// calLoadNames is OneD
	vector<CalibrationDeviceMod::CalibrationDevice >  calLoadNamesVec(calLoadNamesDim[0]);
	for (int i=0;i<calLoadNamesDim[0];i++)
		calLoadNamesVec[i]= CalibrationDevice(calLoadNames[i]   );
	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId, *numCalload, calLoadNamesVec);
	} else {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId, *numCalload, calLoadNamesVec);
	}

	// Add row
	CalDeviceRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalDeviceTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalDeviceRow* given a key.
 */
int sdm_getCalDeviceRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numCalload, CalibrationDevice * calLoadNames, int * calLoadNamesDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDeviceTable &table = dataset->getCalDevice();
	CalDeviceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  feedId  attr.UpperCaseName: FeedId
		//  attr.NameS:  numCalload  attr.UpperCaseName: NumCalload
		*numCalload = row->getNumCalload();
		//  attr.NameS:  calLoadNames  attr.UpperCaseName: CalLoadNames
		
		vector<CalibrationDeviceMod::CalibrationDevice >  calLoadNamesVec = row->getCalLoadNames();
		
		for (int i=0; i<min((int)calLoadNamesVec.size(),calLoadNamesDim[1]); i++)
			calLoadNames[i] = calLoadNamesVec[i];
		calLoadNamesDim[0] = (int)calLoadNamesVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalDeviceTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalDeviceTable &table = dataset->getCalDevice();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalDeviceKeys(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalDeviceTable &table = dataset->getCalDevice();
	
	vector< CalDeviceRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		// spectralWindowId[i] = atoi((row[i]->getSpectralWindowId().getId()).c_str());
				spectralWindowId[i] = row[i]->getSpectralWindowId().getTagValue();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
	  		feedId[i] = row[i]->getFeedId();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter numReceptor, in a row of the CalDevice table, given a key
 *
 */

#define sdm_addCalDeviceNumReceptor  sdm_addcaldevicenumreceptor_
extern "C" int sdm_addCalDeviceNumReceptor(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor);

int sdm_addCalDeviceNumReceptor(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDeviceTable &table = dataset->getCalDevice();
	
	CalDeviceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumReceptor(int(* numReceptor ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numReceptor, in a row of the CalDevice table, given a key
 *
 */

#define sdm_getCalDeviceNumReceptor  sdm_getcaldevicenumreceptor_
extern "C" int sdm_getCalDeviceNumReceptor(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor);

int sdm_getCalDeviceNumReceptor(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDeviceTable &table = dataset->getCalDevice();
	CalDeviceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumReceptorExists()) {
			*numReceptor = row->getNumReceptor();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter calEff, in a row of the CalDevice table, given a key
 *
 */

#define sdm_addCalDeviceCalEff  sdm_addcaldevicecaleff_
extern "C" int sdm_addCalDeviceCalEff(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * calEff, int * calEffDim);

int sdm_addCalDeviceCalEff(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * calEff, int * calEffDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDeviceTable &table = dataset->getCalDevice();
	
	CalDeviceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par calEff:
		vector<vector<float > >  calEffVec(calEffDim[2]);
		for (int i=0;i<calEffDim[2];i++) {
			calEffVec[i].resize(calEffDim[0]);
			for (int j=0;j<calEffDim[0];j++)
				calEffVec[i][j]= float(calEff[i*(calEffDim[1])+j]);
		}
		row->setCalEff(calEffVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter calEff, in a row of the CalDevice table, given a key
 *
 */

#define sdm_getCalDeviceCalEff  sdm_getcaldevicecaleff_
extern "C" int sdm_getCalDeviceCalEff(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * calEff, int * calEffDim);

int sdm_getCalDeviceCalEff(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * calEff, int * calEffDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDeviceTable &table = dataset->getCalDevice();
	CalDeviceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCalEffExists()) {
			// attr.CppType: vector<vector<float > > attr.isOneD: false
			int maxDimZeroCalEff = 0;
			for (int i=0;i<min((int)row->getCalEff().size(),calEffDim[3]) ;i++) {
				maxDimZeroCalEff = max((int)row->getCalEff()[i].size(),maxDimZeroCalEff);
				for (int j=0;j<min((int)row->getCalEff()[i].size(),calEffDim[1]) ;j++) {
					calEff[i*calEffDim[1]+j]= row->getCalEff()[i][j];
				}
			}
			calEffDim[0] = maxDimZeroCalEff;
			calEffDim[2] = row->getCalEff().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter noiseCal, in a row of the CalDevice table, given a key
 *
 */

#define sdm_addCalDeviceNoiseCal  sdm_addcaldevicenoisecal_
extern "C" int sdm_addCalDeviceNoiseCal(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * noiseCal, int * noiseCalDim);

int sdm_addCalDeviceNoiseCal(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * noiseCal, int * noiseCalDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDeviceTable &table = dataset->getCalDevice();
	
	CalDeviceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<double >  noiseCalVec(noiseCalDim[0]);
		for (int i=0;i<noiseCalDim[0];i++)
			noiseCalVec[i]= double(noiseCal[i] );
		row->setNoiseCal(noiseCalVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter noiseCal, in a row of the CalDevice table, given a key
 *
 */

#define sdm_getCalDeviceNoiseCal  sdm_getcaldevicenoisecal_
extern "C" int sdm_getCalDeviceNoiseCal(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * noiseCal, int * noiseCalDim);

int sdm_getCalDeviceNoiseCal(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * noiseCal, int * noiseCalDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDeviceTable &table = dataset->getCalDevice();
	CalDeviceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNoiseCalExists()) {
			// attr.CppType: vector<double > attr.isOneD: true
			for (int i=0; i<min((int)row->getNoiseCal().size(),noiseCalDim[1]); i++)
				noiseCal[i] = row->getNoiseCal()[i];
			noiseCalDim[0] = (int)row->getNoiseCal().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter coupledNoiseCal, in a row of the CalDevice table, given a key
 *
 */

#define sdm_addCalDeviceCoupledNoiseCal  sdm_addcaldevicecouplednoisecal_
extern "C" int sdm_addCalDeviceCoupledNoiseCal(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * coupledNoiseCal, int * coupledNoiseCalDim);

int sdm_addCalDeviceCoupledNoiseCal(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * coupledNoiseCal, int * coupledNoiseCalDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDeviceTable &table = dataset->getCalDevice();
	
	CalDeviceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par coupledNoiseCal:
		vector<vector<float > >  coupledNoiseCalVec(coupledNoiseCalDim[2]);
		for (int i=0;i<coupledNoiseCalDim[2];i++) {
			coupledNoiseCalVec[i].resize(coupledNoiseCalDim[0]);
			for (int j=0;j<coupledNoiseCalDim[0];j++)
				coupledNoiseCalVec[i][j]= float(coupledNoiseCal[i*(coupledNoiseCalDim[1])+j]);
		}
		row->setCoupledNoiseCal(coupledNoiseCalVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter coupledNoiseCal, in a row of the CalDevice table, given a key
 *
 */

#define sdm_getCalDeviceCoupledNoiseCal  sdm_getcaldevicecouplednoisecal_
extern "C" int sdm_getCalDeviceCoupledNoiseCal(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * coupledNoiseCal, int * coupledNoiseCalDim);

int sdm_getCalDeviceCoupledNoiseCal(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * coupledNoiseCal, int * coupledNoiseCalDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDeviceTable &table = dataset->getCalDevice();
	CalDeviceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCoupledNoiseCalExists()) {
			// attr.CppType: vector<vector<float > > attr.isOneD: false
			int maxDimZeroCoupledNoiseCal = 0;
			for (int i=0;i<min((int)row->getCoupledNoiseCal().size(),coupledNoiseCalDim[3]) ;i++) {
				maxDimZeroCoupledNoiseCal = max((int)row->getCoupledNoiseCal()[i].size(),maxDimZeroCoupledNoiseCal);
				for (int j=0;j<min((int)row->getCoupledNoiseCal()[i].size(),coupledNoiseCalDim[1]) ;j++) {
					coupledNoiseCal[i*coupledNoiseCalDim[1]+j]= row->getCoupledNoiseCal()[i][j];
				}
			}
			coupledNoiseCalDim[0] = maxDimZeroCoupledNoiseCal;
			coupledNoiseCalDim[2] = row->getCoupledNoiseCal().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter temperatureLoad, in a row of the CalDevice table, given a key
 *
 */

#define sdm_addCalDeviceTemperatureLoad  sdm_addcaldevicetemperatureload_
extern "C" int sdm_addCalDeviceTemperatureLoad(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * temperatureLoad, int * temperatureLoadDim);

int sdm_addCalDeviceTemperatureLoad(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * temperatureLoad, int * temperatureLoadDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalDeviceTable &table = dataset->getCalDevice();
	
	CalDeviceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  temperatureLoadVec(temperatureLoadDim[0]);
		for (int i=0;i<temperatureLoadDim[0];i++)
			temperatureLoadVec[i]= Temperature(temperatureLoad[i] );
		row->setTemperatureLoad(temperatureLoadVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter temperatureLoad, in a row of the CalDevice table, given a key
 *
 */

#define sdm_getCalDeviceTemperatureLoad  sdm_getcaldevicetemperatureload_
extern "C" int sdm_getCalDeviceTemperatureLoad(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * temperatureLoad, int * temperatureLoadDim);

int sdm_getCalDeviceTemperatureLoad(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * temperatureLoad, int * temperatureLoadDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalDeviceTable &table = dataset->getCalDevice();
	CalDeviceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTemperatureLoadExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getTemperatureLoad().size(),temperatureLoadDim[1]); i++)
				temperatureLoad[i] = row->getTemperatureLoad()[i].get();
			temperatureLoadDim[0] = row->getTemperatureLoad().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace FluxCalibrationMethodMod;
using namespace StokesParameterMod;
using namespace DirectionReferenceCodeMod;
using namespace SourceModelMod;


// =================== CalFluxTable ============================

extern "C" int sdm_addCalFluxRow (char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numFrequencyRanges, int * numStokes, double * frequencyRanges, int * frequencyRangesDim, FluxCalibrationMethod * fluxMethod, double * flux, int * fluxDim, double * fluxError, int * fluxErrorDim, StokesParameter * stokes, int * stokesDim);
extern "C" int sdm_getCalFluxRow (char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numFrequencyRanges, int * numStokes, double * frequencyRanges, int * frequencyRangesDim, FluxCalibrationMethod * fluxMethod, double * flux, int * fluxDim, double * fluxError, int * fluxErrorDim, StokesParameter * stokes, int * stokesDim);


extern "C" int sdm_getCalFluxTableSize ();

extern "C" int sdm_getCalFluxKeys (char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalFluxRow (char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numFrequencyRanges, int * numStokes, double * frequencyRanges, int * frequencyRangesDim, FluxCalibrationMethod * fluxMethod, double * flux, int * fluxDim, double * fluxError, int * fluxErrorDim, StokesParameter * stokes, int * stokesDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalFluxTable &table = dataset->getCalFlux();
	CalFluxRow *row = 0;

	// frequencyRanges is an Array
	// frequencyRanges is 2 D
	vector<vector<Frequency > >  frequencyRangesVec(frequencyRangesDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<frequencyRangesDim[2];i++) {
		frequencyRangesVec[i].resize(frequencyRangesDim[0]);
		for (int j=0;j<frequencyRangesDim[0];j++)
			frequencyRangesVec[i][j]= Frequency(frequencyRanges[i*frequencyRangesDim[1]+j]  );
	
	
	}
	// fluxMethod is an enumeration
	// FluxCalibrationMethod * fluxMethod =  (int) fluxMethod;
	// flux is an Array
	// flux is 2 D
	vector<vector<double > >  fluxVec(fluxDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<fluxDim[2];i++) {
		fluxVec[i].resize(fluxDim[0]);
		for (int j=0;j<fluxDim[0];j++)
			fluxVec[i][j]= double(flux[i*fluxDim[1]+j]  );
	
	
	}
	// fluxError is an Array
	// fluxError is 2 D
	vector<vector<double > >  fluxErrorVec(fluxErrorDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<fluxErrorDim[2];i++) {
		fluxErrorVec[i].resize(fluxErrorDim[0]);
		for (int j=0;j<fluxErrorDim[0];j++)
			fluxErrorVec[i][j]= double(fluxError[i*fluxErrorDim[1]+j]  );
	
	
	}
	// stokes is an Array
	// stokes is OneD
	vector<StokesParameterMod::StokesParameter >  stokesVec(stokesDim[0]);
	for (int i=0;i<stokesDim[0];i++)
		stokesVec[i]= StokesParameter(stokes[i]   );
	
	// Create new row
  
	row = table.newRow(string(sourceName), Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), *numFrequencyRanges, *numStokes, frequencyRangesVec, *fluxMethod, fluxVec, fluxErrorVec, stokesVec);

	// Add row
	CalFluxRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalFluxTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalFluxRow* given a key.
 */
int sdm_getCalFluxRow (char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numFrequencyRanges, int * numStokes, double * frequencyRanges, int * frequencyRangesDim, FluxCalibrationMethod * fluxMethod, double * flux, int * fluxDim, double * fluxError, int * fluxErrorDim, StokesParameter * stokes, int * stokesDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFluxTable &table = dataset->getCalFlux();
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  sourceName  attr.UpperCaseName: SourceName
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  numFrequencyRanges  attr.UpperCaseName: NumFrequencyRanges
		*numFrequencyRanges = row->getNumFrequencyRanges();
		//  attr.NameS:  numStokes  attr.UpperCaseName: NumStokes
		*numStokes = row->getNumStokes();
		//  attr.NameS:  frequencyRanges  attr.UpperCaseName: FrequencyRanges
		
		vector<vector<Frequency > >  frequencyRangesVec = row->getFrequencyRanges();
		
		int maxDimZeroFrequencyRanges = 0;
		for (int i=0; i< min((int)frequencyRangesVec.size(),frequencyRangesDim[3]) ;i++) {
			maxDimZeroFrequencyRanges = max((int)frequencyRangesVec[i].size(),maxDimZeroFrequencyRanges);
			for (int j=0; j<min((int)frequencyRangesVec[i].size(),frequencyRangesDim[1]) ;j++) {
				frequencyRanges[i*frequencyRangesDim[1]+j] = frequencyRangesVec[i][j].get();
			}
		}
		frequencyRangesDim[0] = maxDimZeroFrequencyRanges;
		frequencyRangesDim[2] = frequencyRangesVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  fluxMethod  attr.UpperCaseName: FluxMethod
		*fluxMethod = row->getFluxMethod();
		//  attr.NameS:  flux  attr.UpperCaseName: Flux
		
		vector<vector<double > >  fluxVec = row->getFlux();
		
		int maxDimZeroFlux = 0;
		for (int i=0;i<min((int)fluxVec.size(),fluxDim[3]) ;i++) {
			maxDimZeroFlux = max((int)fluxVec[i].size(),maxDimZeroFlux);
			for (int j=0;j<min((int)fluxVec[i].size(),fluxDim[1]) ;j++) {
				flux[i*fluxDim[1]+j]= fluxVec[i][j];
			}
		}
		fluxDim[0] = maxDimZeroFlux;
		fluxDim[2] = fluxVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  fluxError  attr.UpperCaseName: FluxError
		
		vector<vector<double > >  fluxErrorVec = row->getFluxError();
		
		int maxDimZeroFluxError = 0;
		for (int i=0;i<min((int)fluxErrorVec.size(),fluxErrorDim[3]) ;i++) {
			maxDimZeroFluxError = max((int)fluxErrorVec[i].size(),maxDimZeroFluxError);
			for (int j=0;j<min((int)fluxErrorVec[i].size(),fluxErrorDim[1]) ;j++) {
				fluxError[i*fluxErrorDim[1]+j]= fluxErrorVec[i][j];
			}
		}
		fluxErrorDim[0] = maxDimZeroFluxError;
		fluxErrorDim[2] = fluxErrorVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  stokes  attr.UpperCaseName: Stokes
		
		vector<StokesParameterMod::StokesParameter >  stokesVec = row->getStokes();
		
		for (int i=0; i<min((int)stokesVec.size(),stokesDim[1]); i++)
			stokes[i] = stokesVec[i];
		stokesDim[0] = (int)stokesVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalFluxTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalFluxTable &table = dataset->getCalFlux();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalFluxKeys(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalFluxTable &table = dataset->getCalFlux();
	
	vector< CalFluxRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroSourceName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getSourceName().size() < sourceNameDim[1])
	  			strcpy(sourceName+i*sourceNameDim[1],row[i]->getSourceName().c_str());
	  		else
	  			strncpy(sourceName+i*sourceNameDim[1],row[i]->getSourceName().c_str(),sourceNameDim[1]);
	  		maxDimZeroSourceName = max((int)row[i]->getSourceName().size(), maxDimZeroSourceName);
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
sourceNameDim[0] = maxDimZeroSourceName ;
sourceNameDim[2] = size ;
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter direction, in a row of the CalFlux table, given a key
 *
 */

#define sdm_addCalFluxDirection  sdm_addcalfluxdirection_
extern "C" int sdm_addCalFluxDirection(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * direction, int * directionDim);

int sdm_addCalFluxDirection(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * direction, int * directionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFluxTable &table = dataset->getCalFlux();
	
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Angle >  directionVec(directionDim[0]);
		for (int i=0;i<directionDim[0];i++)
			directionVec[i]= Angle(direction[i] );
		row->setDirection(directionVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter direction, in a row of the CalFlux table, given a key
 *
 */

#define sdm_getCalFluxDirection  sdm_getcalfluxdirection_
extern "C" int sdm_getCalFluxDirection(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * direction, int * directionDim);

int sdm_getCalFluxDirection(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * direction, int * directionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFluxTable &table = dataset->getCalFlux();
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDirectionExists()) {
			// attr.CppType: vector<Angle > attr.isOneD: true
			for (int i=0; i<min((int)row->getDirection().size(),directionDim[1]); i++)
				direction[i] = row->getDirection()[i].get();
			directionDim[0] = row->getDirection().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter directionCode, in a row of the CalFlux table, given a key
 *
 */

#define sdm_addCalFluxDirectionCode  sdm_addcalfluxdirectioncode_
extern "C" int sdm_addCalFluxDirectionCode(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, DirectionReferenceCode * directionCode);

int sdm_addCalFluxDirectionCode(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, DirectionReferenceCode * directionCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFluxTable &table = dataset->getCalFlux();
	
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDirectionCode(DirectionReferenceCode(* directionCode ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter directionCode, in a row of the CalFlux table, given a key
 *
 */

#define sdm_getCalFluxDirectionCode  sdm_getcalfluxdirectioncode_
extern "C" int sdm_getCalFluxDirectionCode(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, DirectionReferenceCode * directionCode);

int sdm_getCalFluxDirectionCode(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, DirectionReferenceCode * directionCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFluxTable &table = dataset->getCalFlux();
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDirectionCodeExists()) {
			*directionCode = row->getDirectionCode();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter directionEquinox, in a row of the CalFlux table, given a key
 *
 */

#define sdm_addCalFluxDirectionEquinox  sdm_addcalfluxdirectionequinox_
extern "C" int sdm_addCalFluxDirectionEquinox(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * directionEquinox);

int sdm_addCalFluxDirectionEquinox(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * directionEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFluxTable &table = dataset->getCalFlux();
	
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDirectionEquinox(Angle(* directionEquinox ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter directionEquinox, in a row of the CalFlux table, given a key
 *
 */

#define sdm_getCalFluxDirectionEquinox  sdm_getcalfluxdirectionequinox_
extern "C" int sdm_getCalFluxDirectionEquinox(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * directionEquinox);

int sdm_getCalFluxDirectionEquinox(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * directionEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFluxTable &table = dataset->getCalFlux();
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDirectionEquinoxExists()) {
			*directionEquinox = row->getDirectionEquinox().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter PA, in a row of the CalFlux table, given a key
 *
 */

#define sdm_addCalFluxPA  sdm_addcalfluxpa_
extern "C" int sdm_addCalFluxPA(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * PA, int * PADim);

int sdm_addCalFluxPA(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * PA, int * PADim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFluxTable &table = dataset->getCalFlux();
	
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par PA:
		vector<vector<Angle > >  PAVec(PADim[2]);
		for (int i=0;i<PADim[2];i++) {
			PAVec[i].resize(PADim[0]);
			for (int j=0;j<PADim[0];j++)
				PAVec[i][j]= Angle(PA[i*(PADim[1])+j]);
		}
		row->setPA(PAVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter PA, in a row of the CalFlux table, given a key
 *
 */

#define sdm_getCalFluxPA  sdm_getcalfluxpa_
extern "C" int sdm_getCalFluxPA(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * PA, int * PADim);

int sdm_getCalFluxPA(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * PA, int * PADim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFluxTable &table = dataset->getCalFlux();
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPAExists()) {
			// attr.CppType: vector<vector<Angle > > attr.isOneD: false
			int maxDimZeroPA = 0;
			for (int i=0; i< min((int)row->getPA().size(),PADim[3]) ;i++) {
				maxDimZeroPA = max((int)row->getPA()[i].size(),maxDimZeroPA);
				for (int j=0; j<min((int)row->getPA()[i].size(),PADim[1]) ;j++) {
					PA[i*PADim[1]+j] = row->getPA()[i][j].get();
				}
			}
			PADim[0] = maxDimZeroPA;
			PADim[2] = row->getPA().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter PAError, in a row of the CalFlux table, given a key
 *
 */

#define sdm_addCalFluxPAError  sdm_addcalfluxpaerror_
extern "C" int sdm_addCalFluxPAError(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * PAError, int * PAErrorDim);

int sdm_addCalFluxPAError(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * PAError, int * PAErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFluxTable &table = dataset->getCalFlux();
	
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par PAError:
		vector<vector<Angle > >  PAErrorVec(PAErrorDim[2]);
		for (int i=0;i<PAErrorDim[2];i++) {
			PAErrorVec[i].resize(PAErrorDim[0]);
			for (int j=0;j<PAErrorDim[0];j++)
				PAErrorVec[i][j]= Angle(PAError[i*(PAErrorDim[1])+j]);
		}
		row->setPAError(PAErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter PAError, in a row of the CalFlux table, given a key
 *
 */

#define sdm_getCalFluxPAError  sdm_getcalfluxpaerror_
extern "C" int sdm_getCalFluxPAError(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * PAError, int * PAErrorDim);

int sdm_getCalFluxPAError(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * PAError, int * PAErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFluxTable &table = dataset->getCalFlux();
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPAErrorExists()) {
			// attr.CppType: vector<vector<Angle > > attr.isOneD: false
			int maxDimZeroPAError = 0;
			for (int i=0; i< min((int)row->getPAError().size(),PAErrorDim[3]) ;i++) {
				maxDimZeroPAError = max((int)row->getPAError()[i].size(),maxDimZeroPAError);
				for (int j=0; j<min((int)row->getPAError()[i].size(),PAErrorDim[1]) ;j++) {
					PAError[i*PAErrorDim[1]+j] = row->getPAError()[i][j].get();
				}
			}
			PAErrorDim[0] = maxDimZeroPAError;
			PAErrorDim[2] = row->getPAError().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter size, in a row of the CalFlux table, given a key
 *
 */

#define sdm_addCalFluxSize  sdm_addcalfluxsize_
extern "C" int sdm_addCalFluxSize(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * size, int * sizeDim);

int sdm_addCalFluxSize(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * size, int * sizeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFluxTable &table = dataset->getCalFlux();
	
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 3 dimensions optional par size:  
		vector<vector<vector<Angle > > >  sizeVec(sizeDim[4]);
		for (int i=0;i<sizeDim[4];i++) {
			sizeVec[i].resize(sizeDim[2]);
			for (int j=0;j<sizeDim[2];j++) {
				sizeVec[i][j].resize(sizeDim[0]);
				for (int k=0;k<sizeDim[0];k++)
					sizeVec[i][j][k]= Angle(size[(i*sizeDim[3]+j)*sizeDim[1]+k]);
			}
		}
		row->setSize(sizeVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter size, in a row of the CalFlux table, given a key
 *
 */

#define sdm_getCalFluxSize  sdm_getcalfluxsize_
extern "C" int sdm_getCalFluxSize(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * size, int * sizeDim);

int sdm_getCalFluxSize(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * size, int * sizeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFluxTable &table = dataset->getCalFlux();
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSizeExists()) {
			// attr.CppType: vector<vector<vector<Angle > > > attr.isOneD: false
			int maxDimTwoSize = 0;
			int maxDimZeroSize = 0;
			for (int i=0; i<  min((int)row->getSize().size(),sizeDim[5]) ;i++) {
				maxDimTwoSize = max((int)row->getSize()[i].size(),maxDimTwoSize);
				for (int j=0;j< min((int)row->getSize()[i].size(),sizeDim[3]) ;j++) {
					maxDimZeroSize = max((int)row->getSize()[i][j].size(),maxDimZeroSize);
					for (int k=0; k< min((int)row->getSize()[i][j].size(),sizeDim[1]) ;k++) {
						size[(i*sizeDim[3]+j)*sizeDim[1]+k]= row->getSize()[i][j][k].get();
					}
				}
			}
			sizeDim[0] = maxDimZeroSize;
			sizeDim[2] = maxDimTwoSize;
			sizeDim[4] = row->getSize().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sizeError, in a row of the CalFlux table, given a key
 *
 */

#define sdm_addCalFluxSizeError  sdm_addcalfluxsizeerror_
extern "C" int sdm_addCalFluxSizeError(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * sizeError, int * sizeErrorDim);

int sdm_addCalFluxSizeError(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * sizeError, int * sizeErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFluxTable &table = dataset->getCalFlux();
	
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 3 dimensions optional par sizeError:  
		vector<vector<vector<Angle > > >  sizeErrorVec(sizeErrorDim[4]);
		for (int i=0;i<sizeErrorDim[4];i++) {
			sizeErrorVec[i].resize(sizeErrorDim[2]);
			for (int j=0;j<sizeErrorDim[2];j++) {
				sizeErrorVec[i][j].resize(sizeErrorDim[0]);
				for (int k=0;k<sizeErrorDim[0];k++)
					sizeErrorVec[i][j][k]= Angle(sizeError[(i*sizeErrorDim[3]+j)*sizeErrorDim[1]+k]);
			}
		}
		row->setSizeError(sizeErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sizeError, in a row of the CalFlux table, given a key
 *
 */

#define sdm_getCalFluxSizeError  sdm_getcalfluxsizeerror_
extern "C" int sdm_getCalFluxSizeError(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * sizeError, int * sizeErrorDim);

int sdm_getCalFluxSizeError(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, double * sizeError, int * sizeErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFluxTable &table = dataset->getCalFlux();
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSizeErrorExists()) {
			// attr.CppType: vector<vector<vector<Angle > > > attr.isOneD: false
			int maxDimTwoSizeError = 0;
			int maxDimZeroSizeError = 0;
			for (int i=0; i<  min((int)row->getSizeError().size(),sizeErrorDim[5]) ;i++) {
				maxDimTwoSizeError = max((int)row->getSizeError()[i].size(),maxDimTwoSizeError);
				for (int j=0;j< min((int)row->getSizeError()[i].size(),sizeErrorDim[3]) ;j++) {
					maxDimZeroSizeError = max((int)row->getSizeError()[i][j].size(),maxDimZeroSizeError);
					for (int k=0; k< min((int)row->getSizeError()[i][j].size(),sizeErrorDim[1]) ;k++) {
						sizeError[(i*sizeErrorDim[3]+j)*sizeErrorDim[1]+k]= row->getSizeError()[i][j][k].get();
					}
				}
			}
			sizeErrorDim[0] = maxDimZeroSizeError;
			sizeErrorDim[2] = maxDimTwoSizeError;
			sizeErrorDim[4] = row->getSizeError().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sourceModel, in a row of the CalFlux table, given a key
 *
 */

#define sdm_addCalFluxSourceModel  sdm_addcalfluxsourcemodel_
extern "C" int sdm_addCalFluxSourceModel(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, SourceModel * sourceModel);

int sdm_addCalFluxSourceModel(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, SourceModel * sourceModel) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFluxTable &table = dataset->getCalFlux();
	
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSourceModel(SourceModel(* sourceModel ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sourceModel, in a row of the CalFlux table, given a key
 *
 */

#define sdm_getCalFluxSourceModel  sdm_getcalfluxsourcemodel_
extern "C" int sdm_getCalFluxSourceModel(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, SourceModel * sourceModel);

int sdm_getCalFluxSourceModel(char * sourceName, int * sourceNameDim, int * calDataId, int * calReductionId, SourceModel * sourceModel) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFluxTable &table = dataset->getCalFlux();
	CalFluxRow *row = 0;
	row = table.getRowByKey( string(sourceName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSourceModelExists()) {
			*sourceModel = row->getSourceModel();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace ReceiverBandMod;
using namespace PolarizationTypeMod;
using namespace AntennaMakeMod;


// =================== CalFocusModelTable ============================

extern "C" int sdm_addCalFocusModelRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, PolarizationType * polarizationType, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, int * numCoeff, int * numSourceObs, char * coeffName, int * coeffNameDim, char * coeffFormula, int * coeffFormulaDim, float * coeffValue, int * coeffValueDim, float * coeffError, int * coeffErrorDim, bool * coeffFixed, int * coeffFixedDim, char * focusModel, int * focusModelDim, double * focusRMS, int * focusRMSDim, double * reducedChiSquared);
extern "C" int sdm_getCalFocusModelRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, PolarizationType * polarizationType, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, int * numCoeff, int * numSourceObs, char * coeffName, int * coeffNameDim, char * coeffFormula, int * coeffFormulaDim, float * coeffValue, int * coeffValueDim, float * coeffError, int * coeffErrorDim, bool * coeffFixed, int * coeffFixedDim, char * focusModel, int * focusModelDim, double * focusRMS, int * focusRMSDim, double * reducedChiSquared);


extern "C" int sdm_getCalFocusModelTableSize ();

extern "C" int sdm_getCalFocusModelKeys (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, PolarizationType * polarizationType, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalFocusModelRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, PolarizationType * polarizationType, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, int * numCoeff, int * numSourceObs, char * coeffName, int * coeffNameDim, char * coeffFormula, int * coeffFormulaDim, float * coeffValue, int * coeffValueDim, float * coeffError, int * coeffErrorDim, bool * coeffFixed, int * coeffFixedDim, char * focusModel, int * focusModelDim, double * focusRMS, int * focusRMSDim, double * reducedChiSquared){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalFocusModelTable &table = dataset->getCalFocusModel();
	CalFocusModelRow *row = 0;

	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// polarizationType is an enumeration
	// PolarizationType * polarizationType =  (int) polarizationType;
	// antennaMake is an enumeration
	// AntennaMake * antennaMake =  (int) antennaMake;
	// coeffName is an Array
	// coeffName is OneD
	vector<string >  coeffNameVec(coeffNameDim[2]);
	for (int i=0;i<coeffNameDim[2];i++)
		coeffNameVec[i]= string(coeffName+i*coeffNameDim[1]  );
	// coeffFormula is an Array
	// coeffFormula is OneD
	vector<string >  coeffFormulaVec(coeffFormulaDim[2]);
	for (int i=0;i<coeffFormulaDim[2];i++)
		coeffFormulaVec[i]= string(coeffFormula+i*coeffFormulaDim[1]  );
	// coeffValue is an Array
	// coeffValue is OneD
	vector<float >  coeffValueVec(coeffValueDim[0]);
	for (int i=0;i<coeffValueDim[0];i++)
		coeffValueVec[i]= float(coeffValue[i]   );
	// coeffError is an Array
	// coeffError is OneD
	vector<float >  coeffErrorVec(coeffErrorDim[0]);
	for (int i=0;i<coeffErrorDim[0];i++)
		coeffErrorVec[i]= float(coeffError[i]   );
	// coeffFixed is an Array
	// coeffFixed is OneD
	vector<bool >  coeffFixedVec(coeffFixedDim[0]);
	for (int i=0;i<coeffFixedDim[0];i++)
		coeffFixedVec[i]= bool(coeffFixed[i]   );
	// focusRMS is an Array
	// focusRMS is OneD
	vector<Length >  focusRMSVec(focusRMSDim[0]);
	for (int i=0;i<focusRMSDim[0];i++)
		focusRMSVec[i]= Length(focusRMS[i]   );
	
	// Create new row
  
	row = table.newRow(string(antennaName), *receiverBand, *polarizationType, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), *antennaMake, *numCoeff, *numSourceObs, coeffNameVec, coeffFormulaVec, coeffValueVec, coeffErrorVec, coeffFixedVec, string(focusModel), focusRMSVec, *reducedChiSquared);

	// Add row
	CalFocusModelRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalFocusModelTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalFocusModelRow* given a key.
 */
int sdm_getCalFocusModelRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, PolarizationType * polarizationType, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, int * numCoeff, int * numSourceObs, char * coeffName, int * coeffNameDim, char * coeffFormula, int * coeffFormulaDim, float * coeffValue, int * coeffValueDim, float * coeffError, int * coeffErrorDim, bool * coeffFixed, int * coeffFixedDim, char * focusModel, int * focusModelDim, double * focusRMS, int * focusRMSDim, double * reducedChiSquared) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusModelTable &table = dataset->getCalFocusModel();
	CalFocusModelRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, *polarizationType, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaName  attr.UpperCaseName: AntennaName
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		//  attr.NameS:  polarizationType  attr.UpperCaseName: PolarizationType
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  antennaMake  attr.UpperCaseName: AntennaMake
		*antennaMake = row->getAntennaMake();
		//  attr.NameS:  numCoeff  attr.UpperCaseName: NumCoeff
		*numCoeff = row->getNumCoeff();
		//  attr.NameS:  numSourceObs  attr.UpperCaseName: NumSourceObs
		*numSourceObs = row->getNumSourceObs();
		//  attr.NameS:  coeffName  attr.UpperCaseName: CoeffName
		
		vector<string >  coeffNameVec = row->getCoeffName();
		
		int maxDimZeroCoeffName = 0;
		for (int i=0; i<min((int)coeffNameVec.size(),coeffNameDim[3]); i++) {
			if ((int)coeffNameVec[i].size()<coeffNameDim[1])
				strcpy(coeffName+i*coeffNameDim[1],coeffNameVec[i].c_str());
			else
				strncpy(coeffName+i*coeffNameDim[1],coeffNameVec[i].c_str(),coeffNameDim[1]);
			maxDimZeroCoeffName = max((int)coeffNameVec[i].size(),maxDimZeroCoeffName);
		}
		coeffNameDim[0] = maxDimZeroCoeffName;
		coeffNameDim[2] = coeffNameVec.size();  // number of strings
		
		
		//  attr.NameS:  coeffFormula  attr.UpperCaseName: CoeffFormula
		
		vector<string >  coeffFormulaVec = row->getCoeffFormula();
		
		int maxDimZeroCoeffFormula = 0;
		for (int i=0; i<min((int)coeffFormulaVec.size(),coeffFormulaDim[3]); i++) {
			if ((int)coeffFormulaVec[i].size()<coeffFormulaDim[1])
				strcpy(coeffFormula+i*coeffFormulaDim[1],coeffFormulaVec[i].c_str());
			else
				strncpy(coeffFormula+i*coeffFormulaDim[1],coeffFormulaVec[i].c_str(),coeffFormulaDim[1]);
			maxDimZeroCoeffFormula = max((int)coeffFormulaVec[i].size(),maxDimZeroCoeffFormula);
		}
		coeffFormulaDim[0] = maxDimZeroCoeffFormula;
		coeffFormulaDim[2] = coeffFormulaVec.size();  // number of strings
		
		
		//  attr.NameS:  coeffValue  attr.UpperCaseName: CoeffValue
		
		vector<float >  coeffValueVec = row->getCoeffValue();
		
		for (int i=0; i<min((int)coeffValueVec.size(),coeffValueDim[1]); i++)
			coeffValue[i] = coeffValueVec[i];
		coeffValueDim[0] = (int)coeffValueVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  coeffError  attr.UpperCaseName: CoeffError
		
		vector<float >  coeffErrorVec = row->getCoeffError();
		
		for (int i=0; i<min((int)coeffErrorVec.size(),coeffErrorDim[1]); i++)
			coeffError[i] = coeffErrorVec[i];
		coeffErrorDim[0] = (int)coeffErrorVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  coeffFixed  attr.UpperCaseName: CoeffFixed
		
		vector<bool >  coeffFixedVec = row->getCoeffFixed();
		
		for (int i=0; i<min((int)coeffFixedVec.size(),coeffFixedDim[1]); i++)
			coeffFixed[i] = coeffFixedVec[i];
		coeffFixedDim[0] = (int)coeffFixedVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  focusModel  attr.UpperCaseName: FocusModel
		if ((int)row->getFocusModel().size()<focusModelDim[1])
			strcpy(focusModel,row->getFocusModel().c_str());
		else
			strncpy(focusModel,row->getFocusModel().c_str(),focusModelDim[1]);
		focusModelDim[0] = (int)row->getFocusModel().size();
		//  attr.NameS:  focusRMS  attr.UpperCaseName: FocusRMS
		
		vector<Length >  focusRMSVec = row->getFocusRMS();
		
		for (int i=0; i<min((int)focusRMSVec.size(),focusRMSDim[1]); i++)
			focusRMS[i] = focusRMSVec[i].get();
		focusRMSDim[0] = focusRMSVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  reducedChiSquared  attr.UpperCaseName: ReducedChiSquared
		*reducedChiSquared = row->getReducedChiSquared();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalFocusModelTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalFocusModelTable &table = dataset->getCalFocusModel();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalFocusModelKeys(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, PolarizationType * polarizationType, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalFocusModelTable &table = dataset->getCalFocusModel();
	
	vector< CalFocusModelRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroAntennaName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getAntennaName().size() < antennaNameDim[1])
	  			strcpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str());
	  		else
	  			strncpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str(),antennaNameDim[1]);
	  		maxDimZeroAntennaName = max((int)row[i]->getAntennaName().size(), maxDimZeroAntennaName);
	  		receiverBand[i] = row[i]->getReceiverBand();
	  		polarizationType[i] = row[i]->getPolarizationType();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
antennaNameDim[0] = maxDimZeroAntennaName ;
antennaNameDim[2] = size ;
		return size;
  	}
}





using namespace ReceiverBandMod;
using namespace AtmPhaseCorrectionMod;
using namespace FocusMethodMod;
using namespace PolarizationTypeMod;


// =================== CalFocusTable ============================

extern "C" int sdm_addCalFocusRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, AtmPhaseCorrection * atmPhaseCorrection, FocusMethod * focusMethod, double * frequencyRange, int * frequencyRangeDim, double * pointingDirection, int * pointingDirectionDim, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, bool * wereFixed, int * wereFixedDim, double * offset, int * offsetDim, double * offsetError, int * offsetErrorDim, bool * offsetWasTied, int * offsetWasTiedDim, double * reducedChiSquared, int * reducedChiSquaredDim, double * position, int * positionDim);
extern "C" int sdm_getCalFocusRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, AtmPhaseCorrection * atmPhaseCorrection, FocusMethod * focusMethod, double * frequencyRange, int * frequencyRangeDim, double * pointingDirection, int * pointingDirectionDim, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, bool * wereFixed, int * wereFixedDim, double * offset, int * offsetDim, double * offsetError, int * offsetErrorDim, bool * offsetWasTied, int * offsetWasTiedDim, double * reducedChiSquared, int * reducedChiSquaredDim, double * position, int * positionDim);


extern "C" int sdm_getCalFocusTableSize ();

extern "C" int sdm_getCalFocusKeys (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalFocusRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, AtmPhaseCorrection * atmPhaseCorrection, FocusMethod * focusMethod, double * frequencyRange, int * frequencyRangeDim, double * pointingDirection, int * pointingDirectionDim, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, bool * wereFixed, int * wereFixedDim, double * offset, int * offsetDim, double * offsetError, int * offsetErrorDim, bool * offsetWasTied, int * offsetWasTiedDim, double * reducedChiSquared, int * reducedChiSquaredDim, double * position, int * positionDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;

	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// atmPhaseCorrection is an enumeration
	// AtmPhaseCorrection * atmPhaseCorrection =  (int) atmPhaseCorrection;
	// focusMethod is an enumeration
	// FocusMethod * focusMethod =  (int) focusMethod;
	// frequencyRange is an Array
	// frequencyRange is OneD
	vector<Frequency >  frequencyRangeVec(frequencyRangeDim[0]);
	for (int i=0;i<frequencyRangeDim[0];i++)
		frequencyRangeVec[i]= Frequency(frequencyRange[i]   );
	// pointingDirection is an Array
	// pointingDirection is OneD
	vector<Angle >  pointingDirectionVec(pointingDirectionDim[0]);
	for (int i=0;i<pointingDirectionDim[0];i++)
		pointingDirectionVec[i]= Angle(pointingDirection[i]   );
	// polarizationTypes is an Array
	// polarizationTypes is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec(polarizationTypesDim[0]);
	for (int i=0;i<polarizationTypesDim[0];i++)
		polarizationTypesVec[i]= PolarizationType(polarizationTypes[i]   );
	// wereFixed is an Array
	// wereFixed is OneD
	vector<bool >  wereFixedVec(wereFixedDim[0]);
	for (int i=0;i<wereFixedDim[0];i++)
		wereFixedVec[i]= bool(wereFixed[i]   );
	// offset is an Array
	// offset is 2 D
	vector<vector<Length > >  offsetVec(offsetDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<offsetDim[2];i++) {
		offsetVec[i].resize(offsetDim[0]);
		for (int j=0;j<offsetDim[0];j++)
			offsetVec[i][j]= Length(offset[i*offsetDim[1]+j]  );
	
	
	}
	// offsetError is an Array
	// offsetError is 2 D
	vector<vector<Length > >  offsetErrorVec(offsetErrorDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<offsetErrorDim[2];i++) {
		offsetErrorVec[i].resize(offsetErrorDim[0]);
		for (int j=0;j<offsetErrorDim[0];j++)
			offsetErrorVec[i][j]= Length(offsetError[i*offsetErrorDim[1]+j]  );
	
	
	}
	// offsetWasTied is an Array
	// offsetWasTied is 2 D
	vector<vector<bool > >  offsetWasTiedVec(offsetWasTiedDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<offsetWasTiedDim[2];i++) {
		offsetWasTiedVec[i].resize(offsetWasTiedDim[0]);
		for (int j=0;j<offsetWasTiedDim[0];j++)
			offsetWasTiedVec[i][j]= bool(offsetWasTied[i*offsetWasTiedDim[1]+j]  );
	
	
	}
	// reducedChiSquared is an Array
	// reducedChiSquared is 2 D
	vector<vector<double > >  reducedChiSquaredVec(reducedChiSquaredDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<reducedChiSquaredDim[2];i++) {
		reducedChiSquaredVec[i].resize(reducedChiSquaredDim[0]);
		for (int j=0;j<reducedChiSquaredDim[0];j++)
			reducedChiSquaredVec[i][j]= double(reducedChiSquared[i*reducedChiSquaredDim[1]+j]  );
	
	
	}
	// position is an Array
	// position is 2 D
	vector<vector<Length > >  positionVec(positionDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<positionDim[2];i++) {
		positionVec[i].resize(positionDim[0]);
		for (int j=0;j<positionDim[0];j++)
			positionVec[i][j]= Length(position[i*positionDim[1]+j]  );
	
	
	}
	
	// Create new row
  
	row = table.newRow(string(antennaName), *receiverBand, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), Temperature(*ambientTemperature), *atmPhaseCorrection, *focusMethod, frequencyRangeVec, pointingDirectionVec, *numReceptor, polarizationTypesVec, wereFixedVec, offsetVec, offsetErrorVec, offsetWasTiedVec, reducedChiSquaredVec, positionVec);

	// Add row
	CalFocusRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalFocusTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalFocusRow* given a key.
 */
int sdm_getCalFocusRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, AtmPhaseCorrection * atmPhaseCorrection, FocusMethod * focusMethod, double * frequencyRange, int * frequencyRangeDim, double * pointingDirection, int * pointingDirectionDim, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, bool * wereFixed, int * wereFixedDim, double * offset, int * offsetDim, double * offsetError, int * offsetErrorDim, bool * offsetWasTied, int * offsetWasTiedDim, double * reducedChiSquared, int * reducedChiSquaredDim, double * position, int * positionDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaName  attr.UpperCaseName: AntennaName
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  ambientTemperature  attr.UpperCaseName: AmbientTemperature
		*ambientTemperature = row->getAmbientTemperature().get();
		//  attr.NameS:  atmPhaseCorrection  attr.UpperCaseName: AtmPhaseCorrection
		*atmPhaseCorrection = row->getAtmPhaseCorrection();
		//  attr.NameS:  focusMethod  attr.UpperCaseName: FocusMethod
		*focusMethod = row->getFocusMethod();
		//  attr.NameS:  frequencyRange  attr.UpperCaseName: FrequencyRange
		
		vector<Frequency >  frequencyRangeVec = row->getFrequencyRange();
		
		for (int i=0; i<min((int)frequencyRangeVec.size(),frequencyRangeDim[1]); i++)
			frequencyRange[i] = frequencyRangeVec[i].get();
		frequencyRangeDim[0] = frequencyRangeVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  pointingDirection  attr.UpperCaseName: PointingDirection
		
		vector<Angle >  pointingDirectionVec = row->getPointingDirection();
		
		for (int i=0; i<min((int)pointingDirectionVec.size(),pointingDirectionDim[1]); i++)
			pointingDirection[i] = pointingDirectionVec[i].get();
		pointingDirectionDim[0] = pointingDirectionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  polarizationTypes  attr.UpperCaseName: PolarizationTypes
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec = row->getPolarizationTypes();
		
		for (int i=0; i<min((int)polarizationTypesVec.size(),polarizationTypesDim[1]); i++)
			polarizationTypes[i] = polarizationTypesVec[i];
		polarizationTypesDim[0] = (int)polarizationTypesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  wereFixed  attr.UpperCaseName: WereFixed
		
		vector<bool >  wereFixedVec = row->getWereFixed();
		
		for (int i=0; i<min((int)wereFixedVec.size(),wereFixedDim[1]); i++)
			wereFixed[i] = wereFixedVec[i];
		wereFixedDim[0] = (int)wereFixedVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  offset  attr.UpperCaseName: Offset
		
		vector<vector<Length > >  offsetVec = row->getOffset();
		
		int maxDimZeroOffset = 0;
		for (int i=0; i< min((int)offsetVec.size(),offsetDim[3]) ;i++) {
			maxDimZeroOffset = max((int)offsetVec[i].size(),maxDimZeroOffset);
			for (int j=0; j<min((int)offsetVec[i].size(),offsetDim[1]) ;j++) {
				offset[i*offsetDim[1]+j] = offsetVec[i][j].get();
			}
		}
		offsetDim[0] = maxDimZeroOffset;
		offsetDim[2] = offsetVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  offsetError  attr.UpperCaseName: OffsetError
		
		vector<vector<Length > >  offsetErrorVec = row->getOffsetError();
		
		int maxDimZeroOffsetError = 0;
		for (int i=0; i< min((int)offsetErrorVec.size(),offsetErrorDim[3]) ;i++) {
			maxDimZeroOffsetError = max((int)offsetErrorVec[i].size(),maxDimZeroOffsetError);
			for (int j=0; j<min((int)offsetErrorVec[i].size(),offsetErrorDim[1]) ;j++) {
				offsetError[i*offsetErrorDim[1]+j] = offsetErrorVec[i][j].get();
			}
		}
		offsetErrorDim[0] = maxDimZeroOffsetError;
		offsetErrorDim[2] = offsetErrorVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  offsetWasTied  attr.UpperCaseName: OffsetWasTied
		
		vector<vector<bool > >  offsetWasTiedVec = row->getOffsetWasTied();
		
		int maxDimZeroOffsetWasTied = 0;
		for (int i=0;i<min((int)offsetWasTiedVec.size(),offsetWasTiedDim[3]) ;i++) {
			maxDimZeroOffsetWasTied = max((int)offsetWasTiedVec[i].size(),maxDimZeroOffsetWasTied);
			for (int j=0;j<min((int)offsetWasTiedVec[i].size(),offsetWasTiedDim[1]) ;j++) {
				offsetWasTied[i*offsetWasTiedDim[1]+j]= offsetWasTiedVec[i][j];
			}
		}
		offsetWasTiedDim[0] = maxDimZeroOffsetWasTied;
		offsetWasTiedDim[2] = offsetWasTiedVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  reducedChiSquared  attr.UpperCaseName: ReducedChiSquared
		
		vector<vector<double > >  reducedChiSquaredVec = row->getReducedChiSquared();
		
		int maxDimZeroReducedChiSquared = 0;
		for (int i=0;i<min((int)reducedChiSquaredVec.size(),reducedChiSquaredDim[3]) ;i++) {
			maxDimZeroReducedChiSquared = max((int)reducedChiSquaredVec[i].size(),maxDimZeroReducedChiSquared);
			for (int j=0;j<min((int)reducedChiSquaredVec[i].size(),reducedChiSquaredDim[1]) ;j++) {
				reducedChiSquared[i*reducedChiSquaredDim[1]+j]= reducedChiSquaredVec[i][j];
			}
		}
		reducedChiSquaredDim[0] = maxDimZeroReducedChiSquared;
		reducedChiSquaredDim[2] = reducedChiSquaredVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  position  attr.UpperCaseName: Position
		
		vector<vector<Length > >  positionVec = row->getPosition();
		
		int maxDimZeroPosition = 0;
		for (int i=0; i< min((int)positionVec.size(),positionDim[3]) ;i++) {
			maxDimZeroPosition = max((int)positionVec[i].size(),maxDimZeroPosition);
			for (int j=0; j<min((int)positionVec[i].size(),positionDim[1]) ;j++) {
				position[i*positionDim[1]+j] = positionVec[i][j].get();
			}
		}
		positionDim[0] = maxDimZeroPosition;
		positionDim[2] = positionVec.size();  // return dimension of the ASDM table
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalFocusTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalFocusTable &table = dataset->getCalFocus();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalFocusKeys(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	
	vector< CalFocusRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroAntennaName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getAntennaName().size() < antennaNameDim[1])
	  			strcpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str());
	  		else
	  			strncpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str(),antennaNameDim[1]);
	  		maxDimZeroAntennaName = max((int)row[i]->getAntennaName().size(), maxDimZeroAntennaName);
	  		receiverBand[i] = row[i]->getReceiverBand();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
antennaNameDim[0] = maxDimZeroAntennaName ;
antennaNameDim[2] = size ;
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter polarizationsAveraged, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusPolarizationsAveraged  sdm_addcalfocuspolarizationsaveraged_
extern "C" int sdm_addCalFocusPolarizationsAveraged(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * polarizationsAveraged);

int sdm_addCalFocusPolarizationsAveraged(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * polarizationsAveraged) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setPolarizationsAveraged(bool(* polarizationsAveraged ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter polarizationsAveraged, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusPolarizationsAveraged  sdm_getcalfocuspolarizationsaveraged_
extern "C" int sdm_getCalFocusPolarizationsAveraged(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * polarizationsAveraged);

int sdm_getCalFocusPolarizationsAveraged(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * polarizationsAveraged) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPolarizationsAveragedExists()) {
			*polarizationsAveraged = row->getPolarizationsAveraged();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter focusCurveWidth, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusFocusCurveWidth  sdm_addcalfocusfocuscurvewidth_
extern "C" int sdm_addCalFocusFocusCurveWidth(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * focusCurveWidth, int * focusCurveWidthDim);

int sdm_addCalFocusFocusCurveWidth(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * focusCurveWidth, int * focusCurveWidthDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par focusCurveWidth:
		vector<vector<Length > >  focusCurveWidthVec(focusCurveWidthDim[2]);
		for (int i=0;i<focusCurveWidthDim[2];i++) {
			focusCurveWidthVec[i].resize(focusCurveWidthDim[0]);
			for (int j=0;j<focusCurveWidthDim[0];j++)
				focusCurveWidthVec[i][j]= Length(focusCurveWidth[i*(focusCurveWidthDim[1])+j]);
		}
		row->setFocusCurveWidth(focusCurveWidthVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter focusCurveWidth, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusFocusCurveWidth  sdm_getcalfocusfocuscurvewidth_
extern "C" int sdm_getCalFocusFocusCurveWidth(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * focusCurveWidth, int * focusCurveWidthDim);

int sdm_getCalFocusFocusCurveWidth(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * focusCurveWidth, int * focusCurveWidthDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFocusCurveWidthExists()) {
			// attr.CppType: vector<vector<Length > > attr.isOneD: false
			int maxDimZeroFocusCurveWidth = 0;
			for (int i=0; i< min((int)row->getFocusCurveWidth().size(),focusCurveWidthDim[3]) ;i++) {
				maxDimZeroFocusCurveWidth = max((int)row->getFocusCurveWidth()[i].size(),maxDimZeroFocusCurveWidth);
				for (int j=0; j<min((int)row->getFocusCurveWidth()[i].size(),focusCurveWidthDim[1]) ;j++) {
					focusCurveWidth[i*focusCurveWidthDim[1]+j] = row->getFocusCurveWidth()[i][j].get();
				}
			}
			focusCurveWidthDim[0] = maxDimZeroFocusCurveWidth;
			focusCurveWidthDim[2] = row->getFocusCurveWidth().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter focusCurveWidthError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusFocusCurveWidthError  sdm_addcalfocusfocuscurvewidtherror_
extern "C" int sdm_addCalFocusFocusCurveWidthError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * focusCurveWidthError, int * focusCurveWidthErrorDim);

int sdm_addCalFocusFocusCurveWidthError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * focusCurveWidthError, int * focusCurveWidthErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par focusCurveWidthError:
		vector<vector<Length > >  focusCurveWidthErrorVec(focusCurveWidthErrorDim[2]);
		for (int i=0;i<focusCurveWidthErrorDim[2];i++) {
			focusCurveWidthErrorVec[i].resize(focusCurveWidthErrorDim[0]);
			for (int j=0;j<focusCurveWidthErrorDim[0];j++)
				focusCurveWidthErrorVec[i][j]= Length(focusCurveWidthError[i*(focusCurveWidthErrorDim[1])+j]);
		}
		row->setFocusCurveWidthError(focusCurveWidthErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter focusCurveWidthError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusFocusCurveWidthError  sdm_getcalfocusfocuscurvewidtherror_
extern "C" int sdm_getCalFocusFocusCurveWidthError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * focusCurveWidthError, int * focusCurveWidthErrorDim);

int sdm_getCalFocusFocusCurveWidthError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * focusCurveWidthError, int * focusCurveWidthErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFocusCurveWidthErrorExists()) {
			// attr.CppType: vector<vector<Length > > attr.isOneD: false
			int maxDimZeroFocusCurveWidthError = 0;
			for (int i=0; i< min((int)row->getFocusCurveWidthError().size(),focusCurveWidthErrorDim[3]) ;i++) {
				maxDimZeroFocusCurveWidthError = max((int)row->getFocusCurveWidthError()[i].size(),maxDimZeroFocusCurveWidthError);
				for (int j=0; j<min((int)row->getFocusCurveWidthError()[i].size(),focusCurveWidthErrorDim[1]) ;j++) {
					focusCurveWidthError[i*focusCurveWidthErrorDim[1]+j] = row->getFocusCurveWidthError()[i][j].get();
				}
			}
			focusCurveWidthErrorDim[0] = maxDimZeroFocusCurveWidthError;
			focusCurveWidthErrorDim[2] = row->getFocusCurveWidthError().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter focusCurveWasFixed, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusFocusCurveWasFixed  sdm_addcalfocusfocuscurvewasfixed_
extern "C" int sdm_addCalFocusFocusCurveWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * focusCurveWasFixed, int * focusCurveWasFixedDim);

int sdm_addCalFocusFocusCurveWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * focusCurveWasFixed, int * focusCurveWasFixedDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<bool >  focusCurveWasFixedVec(focusCurveWasFixedDim[0]);
		for (int i=0;i<focusCurveWasFixedDim[0];i++)
			focusCurveWasFixedVec[i]= bool(focusCurveWasFixed[i] );
		row->setFocusCurveWasFixed(focusCurveWasFixedVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter focusCurveWasFixed, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusFocusCurveWasFixed  sdm_getcalfocusfocuscurvewasfixed_
extern "C" int sdm_getCalFocusFocusCurveWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * focusCurveWasFixed, int * focusCurveWasFixedDim);

int sdm_getCalFocusFocusCurveWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * focusCurveWasFixed, int * focusCurveWasFixedDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFocusCurveWasFixedExists()) {
			// attr.CppType: vector<bool > attr.isOneD: true
			for (int i=0; i<min((int)row->getFocusCurveWasFixed().size(),focusCurveWasFixedDim[1]); i++)
				focusCurveWasFixed[i] = row->getFocusCurveWasFixed()[i];
			focusCurveWasFixedDim[0] = (int)row->getFocusCurveWasFixed().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter offIntensity, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusOffIntensity  sdm_addcalfocusoffintensity_
extern "C" int sdm_addCalFocusOffIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensity, int * offIntensityDim);

int sdm_addCalFocusOffIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensity, int * offIntensityDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  offIntensityVec(offIntensityDim[0]);
		for (int i=0;i<offIntensityDim[0];i++)
			offIntensityVec[i]= Temperature(offIntensity[i] );
		row->setOffIntensity(offIntensityVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter offIntensity, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusOffIntensity  sdm_getcalfocusoffintensity_
extern "C" int sdm_getCalFocusOffIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensity, int * offIntensityDim);

int sdm_getCalFocusOffIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensity, int * offIntensityDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isOffIntensityExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getOffIntensity().size(),offIntensityDim[1]); i++)
				offIntensity[i] = row->getOffIntensity()[i].get();
			offIntensityDim[0] = row->getOffIntensity().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter offIntensityError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusOffIntensityError  sdm_addcalfocusoffintensityerror_
extern "C" int sdm_addCalFocusOffIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensityError, int * offIntensityErrorDim);

int sdm_addCalFocusOffIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensityError, int * offIntensityErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  offIntensityErrorVec(offIntensityErrorDim[0]);
		for (int i=0;i<offIntensityErrorDim[0];i++)
			offIntensityErrorVec[i]= Temperature(offIntensityError[i] );
		row->setOffIntensityError(offIntensityErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter offIntensityError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusOffIntensityError  sdm_getcalfocusoffintensityerror_
extern "C" int sdm_getCalFocusOffIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensityError, int * offIntensityErrorDim);

int sdm_getCalFocusOffIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensityError, int * offIntensityErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isOffIntensityErrorExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getOffIntensityError().size(),offIntensityErrorDim[1]); i++)
				offIntensityError[i] = row->getOffIntensityError()[i].get();
			offIntensityErrorDim[0] = row->getOffIntensityError().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter offIntensityWasFixed, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusOffIntensityWasFixed  sdm_addcalfocusoffintensitywasfixed_
extern "C" int sdm_addCalFocusOffIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * offIntensityWasFixed);

int sdm_addCalFocusOffIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * offIntensityWasFixed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setOffIntensityWasFixed(bool(* offIntensityWasFixed ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter offIntensityWasFixed, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusOffIntensityWasFixed  sdm_getcalfocusoffintensitywasfixed_
extern "C" int sdm_getCalFocusOffIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * offIntensityWasFixed);

int sdm_getCalFocusOffIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * offIntensityWasFixed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isOffIntensityWasFixedExists()) {
			*offIntensityWasFixed = row->getOffIntensityWasFixed();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter peakIntensity, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusPeakIntensity  sdm_addcalfocuspeakintensity_
extern "C" int sdm_addCalFocusPeakIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensity, int * peakIntensityDim);

int sdm_addCalFocusPeakIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensity, int * peakIntensityDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  peakIntensityVec(peakIntensityDim[0]);
		for (int i=0;i<peakIntensityDim[0];i++)
			peakIntensityVec[i]= Temperature(peakIntensity[i] );
		row->setPeakIntensity(peakIntensityVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter peakIntensity, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusPeakIntensity  sdm_getcalfocuspeakintensity_
extern "C" int sdm_getCalFocusPeakIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensity, int * peakIntensityDim);

int sdm_getCalFocusPeakIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensity, int * peakIntensityDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPeakIntensityExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getPeakIntensity().size(),peakIntensityDim[1]); i++)
				peakIntensity[i] = row->getPeakIntensity()[i].get();
			peakIntensityDim[0] = row->getPeakIntensity().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter peakIntensityError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusPeakIntensityError  sdm_addcalfocuspeakintensityerror_
extern "C" int sdm_addCalFocusPeakIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensityError, int * peakIntensityErrorDim);

int sdm_addCalFocusPeakIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensityError, int * peakIntensityErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  peakIntensityErrorVec(peakIntensityErrorDim[0]);
		for (int i=0;i<peakIntensityErrorDim[0];i++)
			peakIntensityErrorVec[i]= Temperature(peakIntensityError[i] );
		row->setPeakIntensityError(peakIntensityErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter peakIntensityError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusPeakIntensityError  sdm_getcalfocuspeakintensityerror_
extern "C" int sdm_getCalFocusPeakIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensityError, int * peakIntensityErrorDim);

int sdm_getCalFocusPeakIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensityError, int * peakIntensityErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPeakIntensityErrorExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getPeakIntensityError().size(),peakIntensityErrorDim[1]); i++)
				peakIntensityError[i] = row->getPeakIntensityError()[i].get();
			peakIntensityErrorDim[0] = row->getPeakIntensityError().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter peakIntensityWasFixed, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusPeakIntensityWasFixed  sdm_addcalfocuspeakintensitywasfixed_
extern "C" int sdm_addCalFocusPeakIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * peakIntensityWasFixed);

int sdm_addCalFocusPeakIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * peakIntensityWasFixed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setPeakIntensityWasFixed(bool(* peakIntensityWasFixed ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter peakIntensityWasFixed, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusPeakIntensityWasFixed  sdm_getcalfocuspeakintensitywasfixed_
extern "C" int sdm_getCalFocusPeakIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * peakIntensityWasFixed);

int sdm_getCalFocusPeakIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * peakIntensityWasFixed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPeakIntensityWasFixedExists()) {
			*peakIntensityWasFixed = row->getPeakIntensityWasFixed();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter astigmPlus, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusAstigmPlus  sdm_addcalfocusastigmplus_
extern "C" int sdm_addCalFocusAstigmPlus(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmPlus, int * astigmPlusDim);

int sdm_addCalFocusAstigmPlus(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmPlus, int * astigmPlusDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  astigmPlusVec(astigmPlusDim[0]);
		for (int i=0;i<astigmPlusDim[0];i++)
			astigmPlusVec[i]= Length(astigmPlus[i] );
		row->setAstigmPlus(astigmPlusVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter astigmPlus, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusAstigmPlus  sdm_getcalfocusastigmplus_
extern "C" int sdm_getCalFocusAstigmPlus(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmPlus, int * astigmPlusDim);

int sdm_getCalFocusAstigmPlus(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmPlus, int * astigmPlusDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAstigmPlusExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getAstigmPlus().size(),astigmPlusDim[1]); i++)
				astigmPlus[i] = row->getAstigmPlus()[i].get();
			astigmPlusDim[0] = row->getAstigmPlus().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter astigmPlusError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusAstigmPlusError  sdm_addcalfocusastigmpluserror_
extern "C" int sdm_addCalFocusAstigmPlusError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmPlusError, int * astigmPlusErrorDim);

int sdm_addCalFocusAstigmPlusError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmPlusError, int * astigmPlusErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  astigmPlusErrorVec(astigmPlusErrorDim[0]);
		for (int i=0;i<astigmPlusErrorDim[0];i++)
			astigmPlusErrorVec[i]= Length(astigmPlusError[i] );
		row->setAstigmPlusError(astigmPlusErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter astigmPlusError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusAstigmPlusError  sdm_getcalfocusastigmpluserror_
extern "C" int sdm_getCalFocusAstigmPlusError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmPlusError, int * astigmPlusErrorDim);

int sdm_getCalFocusAstigmPlusError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmPlusError, int * astigmPlusErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAstigmPlusErrorExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getAstigmPlusError().size(),astigmPlusErrorDim[1]); i++)
				astigmPlusError[i] = row->getAstigmPlusError()[i].get();
			astigmPlusErrorDim[0] = row->getAstigmPlusError().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter astigmMult, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusAstigmMult  sdm_addcalfocusastigmmult_
extern "C" int sdm_addCalFocusAstigmMult(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmMult, int * astigmMultDim);

int sdm_addCalFocusAstigmMult(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmMult, int * astigmMultDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  astigmMultVec(astigmMultDim[0]);
		for (int i=0;i<astigmMultDim[0];i++)
			astigmMultVec[i]= Length(astigmMult[i] );
		row->setAstigmMult(astigmMultVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter astigmMult, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusAstigmMult  sdm_getcalfocusastigmmult_
extern "C" int sdm_getCalFocusAstigmMult(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmMult, int * astigmMultDim);

int sdm_getCalFocusAstigmMult(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmMult, int * astigmMultDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAstigmMultExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getAstigmMult().size(),astigmMultDim[1]); i++)
				astigmMult[i] = row->getAstigmMult()[i].get();
			astigmMultDim[0] = row->getAstigmMult().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter astigmMultError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusAstigmMultError  sdm_addcalfocusastigmmulterror_
extern "C" int sdm_addCalFocusAstigmMultError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmMultError, int * astigmMultErrorDim);

int sdm_addCalFocusAstigmMultError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmMultError, int * astigmMultErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  astigmMultErrorVec(astigmMultErrorDim[0]);
		for (int i=0;i<astigmMultErrorDim[0];i++)
			astigmMultErrorVec[i]= Length(astigmMultError[i] );
		row->setAstigmMultError(astigmMultErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter astigmMultError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusAstigmMultError  sdm_getcalfocusastigmmulterror_
extern "C" int sdm_getCalFocusAstigmMultError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmMultError, int * astigmMultErrorDim);

int sdm_getCalFocusAstigmMultError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * astigmMultError, int * astigmMultErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAstigmMultErrorExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getAstigmMultError().size(),astigmMultErrorDim[1]); i++)
				astigmMultError[i] = row->getAstigmMultError()[i].get();
			astigmMultErrorDim[0] = row->getAstigmMultError().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter illumOffset, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusIllumOffset  sdm_addcalfocusillumoffset_
extern "C" int sdm_addCalFocusIllumOffset(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * illumOffset, int * illumOffsetDim);

int sdm_addCalFocusIllumOffset(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * illumOffset, int * illumOffsetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par illumOffset:
		vector<vector<Length > >  illumOffsetVec(illumOffsetDim[2]);
		for (int i=0;i<illumOffsetDim[2];i++) {
			illumOffsetVec[i].resize(illumOffsetDim[0]);
			for (int j=0;j<illumOffsetDim[0];j++)
				illumOffsetVec[i][j]= Length(illumOffset[i*(illumOffsetDim[1])+j]);
		}
		row->setIllumOffset(illumOffsetVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter illumOffset, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusIllumOffset  sdm_getcalfocusillumoffset_
extern "C" int sdm_getCalFocusIllumOffset(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * illumOffset, int * illumOffsetDim);

int sdm_getCalFocusIllumOffset(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * illumOffset, int * illumOffsetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isIllumOffsetExists()) {
			// attr.CppType: vector<vector<Length > > attr.isOneD: false
			int maxDimZeroIllumOffset = 0;
			for (int i=0; i< min((int)row->getIllumOffset().size(),illumOffsetDim[3]) ;i++) {
				maxDimZeroIllumOffset = max((int)row->getIllumOffset()[i].size(),maxDimZeroIllumOffset);
				for (int j=0; j<min((int)row->getIllumOffset()[i].size(),illumOffsetDim[1]) ;j++) {
					illumOffset[i*illumOffsetDim[1]+j] = row->getIllumOffset()[i][j].get();
				}
			}
			illumOffsetDim[0] = maxDimZeroIllumOffset;
			illumOffsetDim[2] = row->getIllumOffset().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter illumOffsetError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusIllumOffsetError  sdm_addcalfocusillumoffseterror_
extern "C" int sdm_addCalFocusIllumOffsetError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * illumOffsetError, int * illumOffsetErrorDim);

int sdm_addCalFocusIllumOffsetError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * illumOffsetError, int * illumOffsetErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par illumOffsetError:
		vector<vector<Length > >  illumOffsetErrorVec(illumOffsetErrorDim[2]);
		for (int i=0;i<illumOffsetErrorDim[2];i++) {
			illumOffsetErrorVec[i].resize(illumOffsetErrorDim[0]);
			for (int j=0;j<illumOffsetErrorDim[0];j++)
				illumOffsetErrorVec[i][j]= Length(illumOffsetError[i*(illumOffsetErrorDim[1])+j]);
		}
		row->setIllumOffsetError(illumOffsetErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter illumOffsetError, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusIllumOffsetError  sdm_getcalfocusillumoffseterror_
extern "C" int sdm_getCalFocusIllumOffsetError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * illumOffsetError, int * illumOffsetErrorDim);

int sdm_getCalFocusIllumOffsetError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * illumOffsetError, int * illumOffsetErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isIllumOffsetErrorExists()) {
			// attr.CppType: vector<vector<Length > > attr.isOneD: false
			int maxDimZeroIllumOffsetError = 0;
			for (int i=0; i< min((int)row->getIllumOffsetError().size(),illumOffsetErrorDim[3]) ;i++) {
				maxDimZeroIllumOffsetError = max((int)row->getIllumOffsetError()[i].size(),maxDimZeroIllumOffsetError);
				for (int j=0; j<min((int)row->getIllumOffsetError()[i].size(),illumOffsetErrorDim[1]) ;j++) {
					illumOffsetError[i*illumOffsetErrorDim[1]+j] = row->getIllumOffsetError()[i][j].get();
				}
			}
			illumOffsetErrorDim[0] = maxDimZeroIllumOffsetError;
			illumOffsetErrorDim[2] = row->getIllumOffsetError().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter fitRMS, in a row of the CalFocus table, given a key
 *
 */

#define sdm_addCalFocusFitRMS  sdm_addcalfocusfitrms_
extern "C" int sdm_addCalFocusFitRMS(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * fitRMS, int * fitRMSDim);

int sdm_addCalFocusFitRMS(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * fitRMS, int * fitRMSDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalFocusTable &table = dataset->getCalFocus();
	
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  fitRMSVec(fitRMSDim[0]);
		for (int i=0;i<fitRMSDim[0];i++)
			fitRMSVec[i]= Length(fitRMS[i] );
		row->setFitRMS(fitRMSVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter fitRMS, in a row of the CalFocus table, given a key
 *
 */

#define sdm_getCalFocusFitRMS  sdm_getcalfocusfitrms_
extern "C" int sdm_getCalFocusFitRMS(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * fitRMS, int * fitRMSDim);

int sdm_getCalFocusFitRMS(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * fitRMS, int * fitRMSDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalFocusTable &table = dataset->getCalFocus();
	CalFocusRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFitRMSExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getFitRMS().size(),fitRMSDim[1]); i++)
				fitRMS[i] = row->getFitRMS()[i].get();
			fitRMSDim[0] = row->getFitRMS().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}




// =================== CalGainTable ============================

extern "C" int sdm_addCalGainRow (int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, float * gain, bool * gainValid, float * fit, float * fitWeight, bool * totalGainValid, float * totalFit, float * totalFitWeight);
extern "C" int sdm_getCalGainRow (int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, float * gain, bool * gainValid, float * fit, float * fitWeight, bool * totalGainValid, float * totalFit, float * totalFitWeight);


extern "C" int sdm_getCalGainTableSize ();

extern "C" int sdm_getCalGainKeys (int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalGainRow (int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, float * gain, bool * gainValid, float * fit, float * fitWeight, bool * totalGainValid, float * totalFit, float * totalFitWeight){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalGainTable &table = dataset->getCalGain();
	CalGainRow *row = 0;

	
	// Create new row
  
	row = table.newRow(Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), *gain, *gainValid, *fit, *fitWeight, *totalGainValid, *totalFit, *totalFitWeight);

	// Add row
	CalGainRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalGainTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalGainRow* given a key.
 */
int sdm_getCalGainRow (int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, float * gain, bool * gainValid, float * fit, float * fitWeight, bool * totalGainValid, float * totalFit, float * totalFitWeight) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalGainTable &table = dataset->getCalGain();
	CalGainRow *row = 0;
	row = table.getRowByKey( Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  gain  attr.UpperCaseName: Gain
		*gain = row->getGain();
		//  attr.NameS:  gainValid  attr.UpperCaseName: GainValid
		*gainValid = row->getGainValid();
		//  attr.NameS:  fit  attr.UpperCaseName: Fit
		*fit = row->getFit();
		//  attr.NameS:  fitWeight  attr.UpperCaseName: FitWeight
		*fitWeight = row->getFitWeight();
		//  attr.NameS:  totalGainValid  attr.UpperCaseName: TotalGainValid
		*totalGainValid = row->getTotalGainValid();
		//  attr.NameS:  totalFit  attr.UpperCaseName: TotalFit
		*totalFit = row->getTotalFit();
		//  attr.NameS:  totalFitWeight  attr.UpperCaseName: TotalFitWeight
		*totalFitWeight = row->getTotalFitWeight();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalGainTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalGainTable &table = dataset->getCalGain();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalGainKeys(int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalGainTable &table = dataset->getCalGain();
	
	vector< CalGainRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
		return size;
  	}
}





using namespace AntennaMakeMod;
using namespace PolarizationTypeMod;
using namespace ReceiverBandMod;


// =================== CalHolographyTable ============================

extern "C" int sdm_addCalHolographyRow (char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, AntennaMake * antennaMake, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, double * focusPosition, int * focusPositionDim, double * frequencyRange, int * frequencyRangeDim, double * illuminationTaper, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, int * numPanelModes, ReceiverBand * receiverBand, char * beamMapUID, int * beamMapUIDDim, double * rawRMS, double * weightedRMS, char * surfaceMapUID, int * surfaceMapUIDDim, double * direction, int * directionDim);
extern "C" int sdm_getCalHolographyRow (char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, AntennaMake * antennaMake, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, double * focusPosition, int * focusPositionDim, double * frequencyRange, int * frequencyRangeDim, double * illuminationTaper, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, int * numPanelModes, ReceiverBand * receiverBand, char * beamMapUID, int * beamMapUIDDim, double * rawRMS, double * weightedRMS, char * surfaceMapUID, int * surfaceMapUIDDim, double * direction, int * directionDim);


extern "C" int sdm_getCalHolographyTableSize ();

extern "C" int sdm_getCalHolographyKeys (char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalHolographyRow (char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, AntennaMake * antennaMake, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, double * focusPosition, int * focusPositionDim, double * frequencyRange, int * frequencyRangeDim, double * illuminationTaper, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, int * numPanelModes, ReceiverBand * receiverBand, char * beamMapUID, int * beamMapUIDDim, double * rawRMS, double * weightedRMS, char * surfaceMapUID, int * surfaceMapUIDDim, double * direction, int * directionDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalHolographyTable &table = dataset->getCalHolography();
	CalHolographyRow *row = 0;

	// antennaMake is an enumeration
	// AntennaMake * antennaMake =  (int) antennaMake;
	// focusPosition is an Array
	// focusPosition is OneD
	vector<Length >  focusPositionVec(focusPositionDim[0]);
	for (int i=0;i<focusPositionDim[0];i++)
		focusPositionVec[i]= Length(focusPosition[i]   );
	// frequencyRange is an Array
	// frequencyRange is OneD
	vector<Frequency >  frequencyRangeVec(frequencyRangeDim[0]);
	for (int i=0;i<frequencyRangeDim[0];i++)
		frequencyRangeVec[i]= Frequency(frequencyRange[i]   );
	// polarizationTypes is an Array
	// polarizationTypes is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec(polarizationTypesDim[0]);
	for (int i=0;i<polarizationTypesDim[0];i++)
		polarizationTypesVec[i]= PolarizationType(polarizationTypes[i]   );
	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// direction is an Array
	// direction is OneD
	vector<Angle >  directionVec(directionDim[0]);
	for (int i=0;i<directionDim[0];i++)
		directionVec[i]= Angle(direction[i]   );
	
	// Create new row
  
	row = table.newRow(string(antennaName), Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), *antennaMake, ArrayTime(*startValidTime), ArrayTime(*endValidTime), Temperature(*ambientTemperature), focusPositionVec, frequencyRangeVec, *illuminationTaper, *numReceptor, polarizationTypesVec, *numPanelModes, *receiverBand, EntityRef(string(beamMapUID)), Length(*rawRMS), Length(*weightedRMS), EntityRef(string(surfaceMapUID)), directionVec);

	// Add row
	CalHolographyRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalHolographyTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalHolographyRow* given a key.
 */
int sdm_getCalHolographyRow (char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, AntennaMake * antennaMake, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, double * focusPosition, int * focusPositionDim, double * frequencyRange, int * frequencyRangeDim, double * illuminationTaper, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, int * numPanelModes, ReceiverBand * receiverBand, char * beamMapUID, int * beamMapUIDDim, double * rawRMS, double * weightedRMS, char * surfaceMapUID, int * surfaceMapUIDDim, double * direction, int * directionDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalHolographyTable &table = dataset->getCalHolography();
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaName  attr.UpperCaseName: AntennaName
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  antennaMake  attr.UpperCaseName: AntennaMake
		*antennaMake = row->getAntennaMake();
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  ambientTemperature  attr.UpperCaseName: AmbientTemperature
		*ambientTemperature = row->getAmbientTemperature().get();
		//  attr.NameS:  focusPosition  attr.UpperCaseName: FocusPosition
		
		vector<Length >  focusPositionVec = row->getFocusPosition();
		
		for (int i=0; i<min((int)focusPositionVec.size(),focusPositionDim[1]); i++)
			focusPosition[i] = focusPositionVec[i].get();
		focusPositionDim[0] = focusPositionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  frequencyRange  attr.UpperCaseName: FrequencyRange
		
		vector<Frequency >  frequencyRangeVec = row->getFrequencyRange();
		
		for (int i=0; i<min((int)frequencyRangeVec.size(),frequencyRangeDim[1]); i++)
			frequencyRange[i] = frequencyRangeVec[i].get();
		frequencyRangeDim[0] = frequencyRangeVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  illuminationTaper  attr.UpperCaseName: IlluminationTaper
		*illuminationTaper = row->getIlluminationTaper();
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  polarizationTypes  attr.UpperCaseName: PolarizationTypes
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec = row->getPolarizationTypes();
		
		for (int i=0; i<min((int)polarizationTypesVec.size(),polarizationTypesDim[1]); i++)
			polarizationTypes[i] = polarizationTypesVec[i];
		polarizationTypesDim[0] = (int)polarizationTypesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  numPanelModes  attr.UpperCaseName: NumPanelModes
		*numPanelModes = row->getNumPanelModes();
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		*receiverBand = row->getReceiverBand();
		//  attr.NameS:  beamMapUID  attr.UpperCaseName: BeamMapUID
		strcpy(beamMapUID,row->getBeamMapUID().toString().c_str());
		//  attr.NameS:  rawRMS  attr.UpperCaseName: RawRMS
		*rawRMS = row->getRawRMS().get();
		//  attr.NameS:  weightedRMS  attr.UpperCaseName: WeightedRMS
		*weightedRMS = row->getWeightedRMS().get();
		//  attr.NameS:  surfaceMapUID  attr.UpperCaseName: SurfaceMapUID
		strcpy(surfaceMapUID,row->getSurfaceMapUID().toString().c_str());
		//  attr.NameS:  direction  attr.UpperCaseName: Direction
		
		vector<Angle >  directionVec = row->getDirection();
		
		for (int i=0; i<min((int)directionVec.size(),directionDim[1]); i++)
			direction[i] = directionVec[i].get();
		directionDim[0] = directionVec.size(); // return dimension of the ASDM table
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalHolographyTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalHolographyTable &table = dataset->getCalHolography();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalHolographyKeys(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalHolographyTable &table = dataset->getCalHolography();
	
	vector< CalHolographyRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroAntennaName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getAntennaName().size() < antennaNameDim[1])
	  			strcpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str());
	  		else
	  			strncpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str(),antennaNameDim[1]);
	  		maxDimZeroAntennaName = max((int)row[i]->getAntennaName().size(), maxDimZeroAntennaName);
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
antennaNameDim[0] = maxDimZeroAntennaName ;
antennaNameDim[2] = size ;
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter numScrew, in a row of the CalHolography table, given a key
 *
 */

#define sdm_addCalHolographyNumScrew  sdm_addcalholographynumscrew_
extern "C" int sdm_addCalHolographyNumScrew(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, int * numScrew);

int sdm_addCalHolographyNumScrew(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, int * numScrew) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalHolographyTable &table = dataset->getCalHolography();
	
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumScrew(int(* numScrew ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numScrew, in a row of the CalHolography table, given a key
 *
 */

#define sdm_getCalHolographyNumScrew  sdm_getcalholographynumscrew_
extern "C" int sdm_getCalHolographyNumScrew(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, int * numScrew);

int sdm_getCalHolographyNumScrew(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, int * numScrew) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalHolographyTable &table = dataset->getCalHolography();
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumScrewExists()) {
			*numScrew = row->getNumScrew();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter screwName, in a row of the CalHolography table, given a key
 *
 */

#define sdm_addCalHolographyScrewName  sdm_addcalholographyscrewname_
extern "C" int sdm_addCalHolographyScrewName(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, char * screwName, int * screwNameDim);

int sdm_addCalHolographyScrewName(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, char * screwName, int * screwNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalHolographyTable &table = dataset->getCalHolography();
	
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<string >  screwNameVec(screwNameDim[2]);
		for (int i=0;i<screwNameDim[2];i++)
			screwNameVec[i]= string(screwName+i*screwNameDim[1]  
		row->setScrewName(screwNameVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter screwName, in a row of the CalHolography table, given a key
 *
 */

#define sdm_getCalHolographyScrewName  sdm_getcalholographyscrewname_
extern "C" int sdm_getCalHolographyScrewName(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, char * screwName, int * screwNameDim);

int sdm_getCalHolographyScrewName(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, char * screwName, int * screwNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalHolographyTable &table = dataset->getCalHolography();
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isScrewNameExists()) {
			// attr.CppType: vector<string > attr.isOneD: true
			int maxDimZeroScrewName = 0;
			for (int i=0; i<min((int)row->getScrewName().size(),screwNameDim[3]); i++) {
				if ((int)row->getScrewName()[i].size()<screwNameDim[1])
					strcpy(screwName+i*screwNameDim[1],row->getScrewName()[i].c_str());
				else
					strncpy(screwName+i*screwNameDim[1],row->getScrewName()[i].c_str(),screwNameDim[1]);
				maxDimZeroScrewName = max((int)row->getScrewName()[i].size(),maxDimZeroScrewName);
			}
			screwNameDim[0] = maxDimZeroScrewName;
			screwNameDim[2] = row->getScrewName().size();  // number of strings
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter screwMotion, in a row of the CalHolography table, given a key
 *
 */

#define sdm_addCalHolographyScrewMotion  sdm_addcalholographyscrewmotion_
extern "C" int sdm_addCalHolographyScrewMotion(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * screwMotion, int * screwMotionDim);

int sdm_addCalHolographyScrewMotion(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * screwMotion, int * screwMotionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalHolographyTable &table = dataset->getCalHolography();
	
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  screwMotionVec(screwMotionDim[0]);
		for (int i=0;i<screwMotionDim[0];i++)
			screwMotionVec[i]= Length(screwMotion[i] );
		row->setScrewMotion(screwMotionVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter screwMotion, in a row of the CalHolography table, given a key
 *
 */

#define sdm_getCalHolographyScrewMotion  sdm_getcalholographyscrewmotion_
extern "C" int sdm_getCalHolographyScrewMotion(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * screwMotion, int * screwMotionDim);

int sdm_getCalHolographyScrewMotion(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * screwMotion, int * screwMotionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalHolographyTable &table = dataset->getCalHolography();
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isScrewMotionExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getScrewMotion().size(),screwMotionDim[1]); i++)
				screwMotion[i] = row->getScrewMotion()[i].get();
			screwMotionDim[0] = row->getScrewMotion().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter screwMotionError, in a row of the CalHolography table, given a key
 *
 */

#define sdm_addCalHolographyScrewMotionError  sdm_addcalholographyscrewmotionerror_
extern "C" int sdm_addCalHolographyScrewMotionError(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * screwMotionError, int * screwMotionErrorDim);

int sdm_addCalHolographyScrewMotionError(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * screwMotionError, int * screwMotionErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalHolographyTable &table = dataset->getCalHolography();
	
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  screwMotionErrorVec(screwMotionErrorDim[0]);
		for (int i=0;i<screwMotionErrorDim[0];i++)
			screwMotionErrorVec[i]= Length(screwMotionError[i] );
		row->setScrewMotionError(screwMotionErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter screwMotionError, in a row of the CalHolography table, given a key
 *
 */

#define sdm_getCalHolographyScrewMotionError  sdm_getcalholographyscrewmotionerror_
extern "C" int sdm_getCalHolographyScrewMotionError(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * screwMotionError, int * screwMotionErrorDim);

int sdm_getCalHolographyScrewMotionError(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * screwMotionError, int * screwMotionErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalHolographyTable &table = dataset->getCalHolography();
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isScrewMotionErrorExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getScrewMotionError().size(),screwMotionErrorDim[1]); i++)
				screwMotionError[i] = row->getScrewMotionError()[i].get();
			screwMotionErrorDim[0] = row->getScrewMotionError().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter gravCorrection, in a row of the CalHolography table, given a key
 *
 */

#define sdm_addCalHolographyGravCorrection  sdm_addcalholographygravcorrection_
extern "C" int sdm_addCalHolographyGravCorrection(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, bool * gravCorrection);

int sdm_addCalHolographyGravCorrection(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, bool * gravCorrection) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalHolographyTable &table = dataset->getCalHolography();
	
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setGravCorrection(bool(* gravCorrection ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter gravCorrection, in a row of the CalHolography table, given a key
 *
 */

#define sdm_getCalHolographyGravCorrection  sdm_getcalholographygravcorrection_
extern "C" int sdm_getCalHolographyGravCorrection(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, bool * gravCorrection);

int sdm_getCalHolographyGravCorrection(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, bool * gravCorrection) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalHolographyTable &table = dataset->getCalHolography();
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isGravCorrectionExists()) {
			*gravCorrection = row->getGravCorrection();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter gravOptRange, in a row of the CalHolography table, given a key
 *
 */

#define sdm_addCalHolographyGravOptRange  sdm_addcalholographygravoptrange_
extern "C" int sdm_addCalHolographyGravOptRange(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * gravOptRange, int * gravOptRangeDim);

int sdm_addCalHolographyGravOptRange(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * gravOptRange, int * gravOptRangeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalHolographyTable &table = dataset->getCalHolography();
	
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Angle >  gravOptRangeVec(gravOptRangeDim[0]);
		for (int i=0;i<gravOptRangeDim[0];i++)
			gravOptRangeVec[i]= Angle(gravOptRange[i] );
		row->setGravOptRange(gravOptRangeVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter gravOptRange, in a row of the CalHolography table, given a key
 *
 */

#define sdm_getCalHolographyGravOptRange  sdm_getcalholographygravoptrange_
extern "C" int sdm_getCalHolographyGravOptRange(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * gravOptRange, int * gravOptRangeDim);

int sdm_getCalHolographyGravOptRange(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * gravOptRange, int * gravOptRangeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalHolographyTable &table = dataset->getCalHolography();
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isGravOptRangeExists()) {
			// attr.CppType: vector<Angle > attr.isOneD: true
			for (int i=0; i<min((int)row->getGravOptRange().size(),gravOptRangeDim[1]); i++)
				gravOptRange[i] = row->getGravOptRange()[i].get();
			gravOptRangeDim[0] = row->getGravOptRange().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter tempCorrection, in a row of the CalHolography table, given a key
 *
 */

#define sdm_addCalHolographyTempCorrection  sdm_addcalholographytempcorrection_
extern "C" int sdm_addCalHolographyTempCorrection(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, bool * tempCorrection);

int sdm_addCalHolographyTempCorrection(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, bool * tempCorrection) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalHolographyTable &table = dataset->getCalHolography();
	
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTempCorrection(bool(* tempCorrection ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tempCorrection, in a row of the CalHolography table, given a key
 *
 */

#define sdm_getCalHolographyTempCorrection  sdm_getcalholographytempcorrection_
extern "C" int sdm_getCalHolographyTempCorrection(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, bool * tempCorrection);

int sdm_getCalHolographyTempCorrection(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, bool * tempCorrection) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalHolographyTable &table = dataset->getCalHolography();
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTempCorrectionExists()) {
			*tempCorrection = row->getTempCorrection();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter tempOptRange, in a row of the CalHolography table, given a key
 *
 */

#define sdm_addCalHolographyTempOptRange  sdm_addcalholographytempoptrange_
extern "C" int sdm_addCalHolographyTempOptRange(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * tempOptRange, int * tempOptRangeDim);

int sdm_addCalHolographyTempOptRange(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * tempOptRange, int * tempOptRangeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalHolographyTable &table = dataset->getCalHolography();
	
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  tempOptRangeVec(tempOptRangeDim[0]);
		for (int i=0;i<tempOptRangeDim[0];i++)
			tempOptRangeVec[i]= Temperature(tempOptRange[i] );
		row->setTempOptRange(tempOptRangeVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tempOptRange, in a row of the CalHolography table, given a key
 *
 */

#define sdm_getCalHolographyTempOptRange  sdm_getcalholographytempoptrange_
extern "C" int sdm_getCalHolographyTempOptRange(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * tempOptRange, int * tempOptRangeDim);

int sdm_getCalHolographyTempOptRange(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, double * tempOptRange, int * tempOptRangeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalHolographyTable &table = dataset->getCalHolography();
	CalHolographyRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTempOptRangeExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getTempOptRange().size(),tempOptRangeDim[1]); i++)
				tempOptRange[i] = row->getTempOptRange()[i].get();
			tempOptRangeDim[0] = row->getTempOptRange().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace BasebandNameMod;
using namespace ReceiverBandMod;
using namespace AtmPhaseCorrectionMod;
using namespace PolarizationTypeMod;


// =================== CalPhaseTable ============================

extern "C" int sdm_addCalPhaseRow (BasebandName * basebandName, ReceiverBand * receiverBand, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numBaseline, int * numReceptor, float * ampli, int * ampliDim, char * antennaNames, int * antennaNamesDim, double * baselineLengths, int * baselineLengthsDim, float * decorrelationFactor, int * decorrelationFactorDim, double * direction, int * directionDim, double * frequencyRange, int * frequencyRangeDim, int64_t * integrationTime, float * phase, int * phaseDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * phaseRMS, int * phaseRMSDim, float * statPhaseRMS, int * statPhaseRMSDim);
extern "C" int sdm_getCalPhaseRow (BasebandName * basebandName, ReceiverBand * receiverBand, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numBaseline, int * numReceptor, float * ampli, int * ampliDim, char * antennaNames, int * antennaNamesDim, double * baselineLengths, int * baselineLengthsDim, float * decorrelationFactor, int * decorrelationFactorDim, double * direction, int * directionDim, double * frequencyRange, int * frequencyRangeDim, int64_t * integrationTime, float * phase, int * phaseDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * phaseRMS, int * phaseRMSDim, float * statPhaseRMS, int * statPhaseRMSDim);


extern "C" int sdm_getCalPhaseTableSize ();

extern "C" int sdm_getCalPhaseKeys (BasebandName * basebandName, ReceiverBand * receiverBand, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalPhaseRow (BasebandName * basebandName, ReceiverBand * receiverBand, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numBaseline, int * numReceptor, float * ampli, int * ampliDim, char * antennaNames, int * antennaNamesDim, double * baselineLengths, int * baselineLengthsDim, float * decorrelationFactor, int * decorrelationFactorDim, double * direction, int * directionDim, double * frequencyRange, int * frequencyRangeDim, int64_t * integrationTime, float * phase, int * phaseDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * phaseRMS, int * phaseRMSDim, float * statPhaseRMS, int * statPhaseRMSDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalPhaseTable &table = dataset->getCalPhase();
	CalPhaseRow *row = 0;

	// basebandName is an enumeration
	// BasebandName * basebandName =  (int) basebandName;
	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// atmPhaseCorrection is an enumeration
	// AtmPhaseCorrection * atmPhaseCorrection =  (int) atmPhaseCorrection;
	// ampli is an Array
	// ampli is 2 D
	vector<vector<float > >  ampliVec(ampliDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<ampliDim[2];i++) {
		ampliVec[i].resize(ampliDim[0]);
		for (int j=0;j<ampliDim[0];j++)
			ampliVec[i][j]= float(ampli[i*ampliDim[1]+j]  );
	
	
	}
	// antennaNames is an Array
	// antennaNames is 2 D
	vector<vector<string > >  antennaNamesVec(antennaNamesDim[4]);   // Inversion of dim in fortran/C
	for (int i=0;i<antennaNamesDim[4];i++) {
		antennaNamesVec[i].resize(antennaNamesDim[2]);
		for (int j=0;j<antennaNamesDim[2];j++)
			antennaNamesVec[i][j]= string(antennaNames+(i*antennaNamesDim[3]+j)*antennaNamesDim[1] );
	
	
	}
	// baselineLengths is an Array
	// baselineLengths is OneD
	vector<Length >  baselineLengthsVec(baselineLengthsDim[0]);
	for (int i=0;i<baselineLengthsDim[0];i++)
		baselineLengthsVec[i]= Length(baselineLengths[i]   );
	// decorrelationFactor is an Array
	// decorrelationFactor is 2 D
	vector<vector<float > >  decorrelationFactorVec(decorrelationFactorDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<decorrelationFactorDim[2];i++) {
		decorrelationFactorVec[i].resize(decorrelationFactorDim[0]);
		for (int j=0;j<decorrelationFactorDim[0];j++)
			decorrelationFactorVec[i][j]= float(decorrelationFactor[i*decorrelationFactorDim[1]+j]  );
	
	
	}
	// direction is an Array
	// direction is OneD
	vector<Angle >  directionVec(directionDim[0]);
	for (int i=0;i<directionDim[0];i++)
		directionVec[i]= Angle(direction[i]   );
	// frequencyRange is an Array
	// frequencyRange is OneD
	vector<Frequency >  frequencyRangeVec(frequencyRangeDim[0]);
	for (int i=0;i<frequencyRangeDim[0];i++)
		frequencyRangeVec[i]= Frequency(frequencyRange[i]   );
	// phase is an Array
	// phase is 2 D
	vector<vector<float > >  phaseVec(phaseDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<phaseDim[2];i++) {
		phaseVec[i].resize(phaseDim[0]);
		for (int j=0;j<phaseDim[0];j++)
			phaseVec[i][j]= float(phase[i*phaseDim[1]+j]  );
	
	
	}
	// polarizationTypes is an Array
	// polarizationTypes is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec(polarizationTypesDim[0]);
	for (int i=0;i<polarizationTypesDim[0];i++)
		polarizationTypesVec[i]= PolarizationType(polarizationTypes[i]   );
	// phaseRMS is an Array
	// phaseRMS is 2 D
	vector<vector<float > >  phaseRMSVec(phaseRMSDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<phaseRMSDim[2];i++) {
		phaseRMSVec[i].resize(phaseRMSDim[0]);
		for (int j=0;j<phaseRMSDim[0];j++)
			phaseRMSVec[i][j]= float(phaseRMS[i*phaseRMSDim[1]+j]  );
	
	
	}
	// statPhaseRMS is an Array
	// statPhaseRMS is 2 D
	vector<vector<float > >  statPhaseRMSVec(statPhaseRMSDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<statPhaseRMSDim[2];i++) {
		statPhaseRMSVec[i].resize(statPhaseRMSDim[0]);
		for (int j=0;j<statPhaseRMSDim[0];j++)
			statPhaseRMSVec[i][j]= float(statPhaseRMS[i*statPhaseRMSDim[1]+j]  );
	
	
	}
	
	// Create new row
  
	row = table.newRow(*basebandName, *receiverBand, *atmPhaseCorrection, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), *numBaseline, *numReceptor, ampliVec, antennaNamesVec, baselineLengthsVec, decorrelationFactorVec, directionVec, frequencyRangeVec, Interval(*integrationTime), phaseVec, polarizationTypesVec, phaseRMSVec, statPhaseRMSVec);

	// Add row
	CalPhaseRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalPhaseTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalPhaseRow* given a key.
 */
int sdm_getCalPhaseRow (BasebandName * basebandName, ReceiverBand * receiverBand, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, int * numBaseline, int * numReceptor, float * ampli, int * ampliDim, char * antennaNames, int * antennaNamesDim, double * baselineLengths, int * baselineLengthsDim, float * decorrelationFactor, int * decorrelationFactorDim, double * direction, int * directionDim, double * frequencyRange, int * frequencyRangeDim, int64_t * integrationTime, float * phase, int * phaseDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, float * phaseRMS, int * phaseRMSDim, float * statPhaseRMS, int * statPhaseRMSDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPhaseTable &table = dataset->getCalPhase();
	CalPhaseRow *row = 0;
	row = table.getRowByKey( *basebandName, *receiverBand, *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  basebandName  attr.UpperCaseName: BasebandName
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		//  attr.NameS:  atmPhaseCorrection  attr.UpperCaseName: AtmPhaseCorrection
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  numBaseline  attr.UpperCaseName: NumBaseline
		*numBaseline = row->getNumBaseline();
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  ampli  attr.UpperCaseName: Ampli
		
		vector<vector<float > >  ampliVec = row->getAmpli();
		
		int maxDimZeroAmpli = 0;
		for (int i=0;i<min((int)ampliVec.size(),ampliDim[3]) ;i++) {
			maxDimZeroAmpli = max((int)ampliVec[i].size(),maxDimZeroAmpli);
			for (int j=0;j<min((int)ampliVec[i].size(),ampliDim[1]) ;j++) {
				ampli[i*ampliDim[1]+j]= ampliVec[i][j];
			}
		}
		ampliDim[0] = maxDimZeroAmpli;
		ampliDim[2] = ampliVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  antennaNames  attr.UpperCaseName: AntennaNames
		
		vector<vector<string > >  antennaNamesVec = row->getAntennaNames();
		
		int maxDimTwoAntennaNames = 0;
		int maxDimZeroAntennaNames = 0;
		for (int i=0; i< min((int)antennaNamesVec[i].size(),antennaNamesDim[5]) ;i++) {
			maxDimTwoAntennaNames = max((int)antennaNamesVec[i][i].size(),maxDimTwoAntennaNames);
			for (int j=0; j< min((int)antennaNamesVec[i].size(),antennaNamesDim[3]) ;j++) {
				if ((int)antennaNamesVec[i][j].size()>antennaNamesDim[1])
					strcpy(antennaNames+(i*antennaNamesDim[3]+j)*antennaNamesDim[1],antennaNamesVec[i][j].c_str());
				else
					strncpy(antennaNames+(i*antennaNamesDim[3]+j)*antennaNamesDim[1],antennaNamesVec[i][j].c_str(),antennaNamesDim[1]);
				maxDimZeroAntennaNames = max((int)antennaNamesVec[i][j].size(),maxDimZeroAntennaNames);
			}
		}
		antennaNamesDim[0] = maxDimZeroAntennaNames;
		antennaNamesDim[2] = maxDimTwoAntennaNames;
		antennaNamesDim[4] = antennaNamesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  baselineLengths  attr.UpperCaseName: BaselineLengths
		
		vector<Length >  baselineLengthsVec = row->getBaselineLengths();
		
		for (int i=0; i<min((int)baselineLengthsVec.size(),baselineLengthsDim[1]); i++)
			baselineLengths[i] = baselineLengthsVec[i].get();
		baselineLengthsDim[0] = baselineLengthsVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  decorrelationFactor  attr.UpperCaseName: DecorrelationFactor
		
		vector<vector<float > >  decorrelationFactorVec = row->getDecorrelationFactor();
		
		int maxDimZeroDecorrelationFactor = 0;
		for (int i=0;i<min((int)decorrelationFactorVec.size(),decorrelationFactorDim[3]) ;i++) {
			maxDimZeroDecorrelationFactor = max((int)decorrelationFactorVec[i].size(),maxDimZeroDecorrelationFactor);
			for (int j=0;j<min((int)decorrelationFactorVec[i].size(),decorrelationFactorDim[1]) ;j++) {
				decorrelationFactor[i*decorrelationFactorDim[1]+j]= decorrelationFactorVec[i][j];
			}
		}
		decorrelationFactorDim[0] = maxDimZeroDecorrelationFactor;
		decorrelationFactorDim[2] = decorrelationFactorVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  direction  attr.UpperCaseName: Direction
		
		vector<Angle >  directionVec = row->getDirection();
		
		for (int i=0; i<min((int)directionVec.size(),directionDim[1]); i++)
			direction[i] = directionVec[i].get();
		directionDim[0] = directionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  frequencyRange  attr.UpperCaseName: FrequencyRange
		
		vector<Frequency >  frequencyRangeVec = row->getFrequencyRange();
		
		for (int i=0; i<min((int)frequencyRangeVec.size(),frequencyRangeDim[1]); i++)
			frequencyRange[i] = frequencyRangeVec[i].get();
		frequencyRangeDim[0] = frequencyRangeVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  integrationTime  attr.UpperCaseName: IntegrationTime
		*integrationTime = row->getIntegrationTime().get();
		//  attr.NameS:  phase  attr.UpperCaseName: Phase
		
		vector<vector<float > >  phaseVec = row->getPhase();
		
		int maxDimZeroPhase = 0;
		for (int i=0;i<min((int)phaseVec.size(),phaseDim[3]) ;i++) {
			maxDimZeroPhase = max((int)phaseVec[i].size(),maxDimZeroPhase);
			for (int j=0;j<min((int)phaseVec[i].size(),phaseDim[1]) ;j++) {
				phase[i*phaseDim[1]+j]= phaseVec[i][j];
			}
		}
		phaseDim[0] = maxDimZeroPhase;
		phaseDim[2] = phaseVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  polarizationTypes  attr.UpperCaseName: PolarizationTypes
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec = row->getPolarizationTypes();
		
		for (int i=0; i<min((int)polarizationTypesVec.size(),polarizationTypesDim[1]); i++)
			polarizationTypes[i] = polarizationTypesVec[i];
		polarizationTypesDim[0] = (int)polarizationTypesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  phaseRMS  attr.UpperCaseName: PhaseRMS
		
		vector<vector<float > >  phaseRMSVec = row->getPhaseRMS();
		
		int maxDimZeroPhaseRMS = 0;
		for (int i=0;i<min((int)phaseRMSVec.size(),phaseRMSDim[3]) ;i++) {
			maxDimZeroPhaseRMS = max((int)phaseRMSVec[i].size(),maxDimZeroPhaseRMS);
			for (int j=0;j<min((int)phaseRMSVec[i].size(),phaseRMSDim[1]) ;j++) {
				phaseRMS[i*phaseRMSDim[1]+j]= phaseRMSVec[i][j];
			}
		}
		phaseRMSDim[0] = maxDimZeroPhaseRMS;
		phaseRMSDim[2] = phaseRMSVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  statPhaseRMS  attr.UpperCaseName: StatPhaseRMS
		
		vector<vector<float > >  statPhaseRMSVec = row->getStatPhaseRMS();
		
		int maxDimZeroStatPhaseRMS = 0;
		for (int i=0;i<min((int)statPhaseRMSVec.size(),statPhaseRMSDim[3]) ;i++) {
			maxDimZeroStatPhaseRMS = max((int)statPhaseRMSVec[i].size(),maxDimZeroStatPhaseRMS);
			for (int j=0;j<min((int)statPhaseRMSVec[i].size(),statPhaseRMSDim[1]) ;j++) {
				statPhaseRMS[i*statPhaseRMSDim[1]+j]= statPhaseRMSVec[i][j];
			}
		}
		statPhaseRMSDim[0] = maxDimZeroStatPhaseRMS;
		statPhaseRMSDim[2] = statPhaseRMSVec.size();  // return dimension of the ASDM
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalPhaseTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalPhaseTable &table = dataset->getCalPhase();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalPhaseKeys(BasebandName * basebandName, ReceiverBand * receiverBand, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalPhaseTable &table = dataset->getCalPhase();
	
	vector< CalPhaseRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		basebandName[i] = row[i]->getBasebandName();
	  		receiverBand[i] = row[i]->getReceiverBand();
	  		atmPhaseCorrection[i] = row[i]->getAtmPhaseCorrection();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter correctionValidity, in a row of the CalPhase table, given a key
 *
 */

#define sdm_addCalPhaseCorrectionValidity  sdm_addcalphasecorrectionvalidity_
extern "C" int sdm_addCalPhaseCorrectionValidity(BasebandName * basebandName, ReceiverBand * receiverBand, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, bool * correctionValidity, int * correctionValidityDim);

int sdm_addCalPhaseCorrectionValidity(BasebandName * basebandName, ReceiverBand * receiverBand, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, bool * correctionValidity, int * correctionValidityDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPhaseTable &table = dataset->getCalPhase();
	
	CalPhaseRow *row = 0;
	row = table.getRowByKey( *basebandName, *receiverBand, *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<bool >  correctionValidityVec(correctionValidityDim[0]);
		for (int i=0;i<correctionValidityDim[0];i++)
			correctionValidityVec[i]= bool(correctionValidity[i] );
		row->setCorrectionValidity(correctionValidityVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter correctionValidity, in a row of the CalPhase table, given a key
 *
 */

#define sdm_getCalPhaseCorrectionValidity  sdm_getcalphasecorrectionvalidity_
extern "C" int sdm_getCalPhaseCorrectionValidity(BasebandName * basebandName, ReceiverBand * receiverBand, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, bool * correctionValidity, int * correctionValidityDim);

int sdm_getCalPhaseCorrectionValidity(BasebandName * basebandName, ReceiverBand * receiverBand, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, bool * correctionValidity, int * correctionValidityDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPhaseTable &table = dataset->getCalPhase();
	CalPhaseRow *row = 0;
	row = table.getRowByKey( *basebandName, *receiverBand, *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCorrectionValidityExists()) {
			// attr.CppType: vector<bool > attr.isOneD: true
			for (int i=0; i<min((int)row->getCorrectionValidity().size(),correctionValidityDim[1]); i++)
				correctionValidity[i] = row->getCorrectionValidity()[i];
			correctionValidityDim[0] = (int)row->getCorrectionValidity().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace ReceiverBandMod;
using namespace AntennaMakeMod;
using namespace PointingModelModeMod;
using namespace PolarizationTypeMod;


// =================== CalPointingModelTable ============================

extern "C" int sdm_addCalPointingModelRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, PointingModelMode * pointingModelMode, PolarizationType * polarizationType, int * numCoeff, char * coeffName, int * coeffNameDim, float * coeffVal, int * coeffValDim, float * coeffError, int * coeffErrorDim, bool * coeffFixed, int * coeffFixedDim, double * azimuthRMS, double * elevationRms, double * skyRMS, double * reducedChiSquared);
extern "C" int sdm_getCalPointingModelRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, PointingModelMode * pointingModelMode, PolarizationType * polarizationType, int * numCoeff, char * coeffName, int * coeffNameDim, float * coeffVal, int * coeffValDim, float * coeffError, int * coeffErrorDim, bool * coeffFixed, int * coeffFixedDim, double * azimuthRMS, double * elevationRms, double * skyRMS, double * reducedChiSquared);


extern "C" int sdm_getCalPointingModelTableSize ();

extern "C" int sdm_getCalPointingModelKeys (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalPointingModelRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, PointingModelMode * pointingModelMode, PolarizationType * polarizationType, int * numCoeff, char * coeffName, int * coeffNameDim, float * coeffVal, int * coeffValDim, float * coeffError, int * coeffErrorDim, bool * coeffFixed, int * coeffFixedDim, double * azimuthRMS, double * elevationRms, double * skyRMS, double * reducedChiSquared){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalPointingModelTable &table = dataset->getCalPointingModel();
	CalPointingModelRow *row = 0;

	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// antennaMake is an enumeration
	// AntennaMake * antennaMake =  (int) antennaMake;
	// pointingModelMode is an enumeration
	// PointingModelMode * pointingModelMode =  (int) pointingModelMode;
	// polarizationType is an enumeration
	// PolarizationType * polarizationType =  (int) polarizationType;
	// coeffName is an Array
	// coeffName is OneD
	vector<string >  coeffNameVec(coeffNameDim[2]);
	for (int i=0;i<coeffNameDim[2];i++)
		coeffNameVec[i]= string(coeffName+i*coeffNameDim[1]  );
	// coeffVal is an Array
	// coeffVal is OneD
	vector<float >  coeffValVec(coeffValDim[0]);
	for (int i=0;i<coeffValDim[0];i++)
		coeffValVec[i]= float(coeffVal[i]   );
	// coeffError is an Array
	// coeffError is OneD
	vector<float >  coeffErrorVec(coeffErrorDim[0]);
	for (int i=0;i<coeffErrorDim[0];i++)
		coeffErrorVec[i]= float(coeffError[i]   );
	// coeffFixed is an Array
	// coeffFixed is OneD
	vector<bool >  coeffFixedVec(coeffFixedDim[0]);
	for (int i=0;i<coeffFixedDim[0];i++)
		coeffFixedVec[i]= bool(coeffFixed[i]   );
	
	// Create new row
  
	row = table.newRow(string(antennaName), *receiverBand, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), *antennaMake, *pointingModelMode, *polarizationType, *numCoeff, coeffNameVec, coeffValVec, coeffErrorVec, coeffFixedVec, Angle(*azimuthRMS), Angle(*elevationRms), Angle(*skyRMS), *reducedChiSquared);

	// Add row
	CalPointingModelRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalPointingModelTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalPointingModelRow* given a key.
 */
int sdm_getCalPointingModelRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, PointingModelMode * pointingModelMode, PolarizationType * polarizationType, int * numCoeff, char * coeffName, int * coeffNameDim, float * coeffVal, int * coeffValDim, float * coeffError, int * coeffErrorDim, bool * coeffFixed, int * coeffFixedDim, double * azimuthRMS, double * elevationRms, double * skyRMS, double * reducedChiSquared) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingModelTable &table = dataset->getCalPointingModel();
	CalPointingModelRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaName  attr.UpperCaseName: AntennaName
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  antennaMake  attr.UpperCaseName: AntennaMake
		*antennaMake = row->getAntennaMake();
		//  attr.NameS:  pointingModelMode  attr.UpperCaseName: PointingModelMode
		*pointingModelMode = row->getPointingModelMode();
		//  attr.NameS:  polarizationType  attr.UpperCaseName: PolarizationType
		*polarizationType = row->getPolarizationType();
		//  attr.NameS:  numCoeff  attr.UpperCaseName: NumCoeff
		*numCoeff = row->getNumCoeff();
		//  attr.NameS:  coeffName  attr.UpperCaseName: CoeffName
		
		vector<string >  coeffNameVec = row->getCoeffName();
		
		int maxDimZeroCoeffName = 0;
		for (int i=0; i<min((int)coeffNameVec.size(),coeffNameDim[3]); i++) {
			if ((int)coeffNameVec[i].size()<coeffNameDim[1])
				strcpy(coeffName+i*coeffNameDim[1],coeffNameVec[i].c_str());
			else
				strncpy(coeffName+i*coeffNameDim[1],coeffNameVec[i].c_str(),coeffNameDim[1]);
			maxDimZeroCoeffName = max((int)coeffNameVec[i].size(),maxDimZeroCoeffName);
		}
		coeffNameDim[0] = maxDimZeroCoeffName;
		coeffNameDim[2] = coeffNameVec.size();  // number of strings
		
		
		//  attr.NameS:  coeffVal  attr.UpperCaseName: CoeffVal
		
		vector<float >  coeffValVec = row->getCoeffVal();
		
		for (int i=0; i<min((int)coeffValVec.size(),coeffValDim[1]); i++)
			coeffVal[i] = coeffValVec[i];
		coeffValDim[0] = (int)coeffValVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  coeffError  attr.UpperCaseName: CoeffError
		
		vector<float >  coeffErrorVec = row->getCoeffError();
		
		for (int i=0; i<min((int)coeffErrorVec.size(),coeffErrorDim[1]); i++)
			coeffError[i] = coeffErrorVec[i];
		coeffErrorDim[0] = (int)coeffErrorVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  coeffFixed  attr.UpperCaseName: CoeffFixed
		
		vector<bool >  coeffFixedVec = row->getCoeffFixed();
		
		for (int i=0; i<min((int)coeffFixedVec.size(),coeffFixedDim[1]); i++)
			coeffFixed[i] = coeffFixedVec[i];
		coeffFixedDim[0] = (int)coeffFixedVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  azimuthRMS  attr.UpperCaseName: AzimuthRMS
		*azimuthRMS = row->getAzimuthRMS().get();
		//  attr.NameS:  elevationRms  attr.UpperCaseName: ElevationRms
		*elevationRms = row->getElevationRms().get();
		//  attr.NameS:  skyRMS  attr.UpperCaseName: SkyRMS
		*skyRMS = row->getSkyRMS().get();
		//  attr.NameS:  reducedChiSquared  attr.UpperCaseName: ReducedChiSquared
		*reducedChiSquared = row->getReducedChiSquared();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalPointingModelTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalPointingModelTable &table = dataset->getCalPointingModel();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalPointingModelKeys(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalPointingModelTable &table = dataset->getCalPointingModel();
	
	vector< CalPointingModelRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroAntennaName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getAntennaName().size() < antennaNameDim[1])
	  			strcpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str());
	  		else
	  			strncpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str(),antennaNameDim[1]);
	  		maxDimZeroAntennaName = max((int)row[i]->getAntennaName().size(), maxDimZeroAntennaName);
	  		receiverBand[i] = row[i]->getReceiverBand();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
antennaNameDim[0] = maxDimZeroAntennaName ;
antennaNameDim[2] = size ;
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter numObs, in a row of the CalPointingModel table, given a key
 *
 */

#define sdm_addCalPointingModelNumObs  sdm_addcalpointingmodelnumobs_
extern "C" int sdm_addCalPointingModelNumObs(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numObs);

int sdm_addCalPointingModelNumObs(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numObs) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingModelTable &table = dataset->getCalPointingModel();
	
	CalPointingModelRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumObs(int(* numObs ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numObs, in a row of the CalPointingModel table, given a key
 *
 */

#define sdm_getCalPointingModelNumObs  sdm_getcalpointingmodelnumobs_
extern "C" int sdm_getCalPointingModelNumObs(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numObs);

int sdm_getCalPointingModelNumObs(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int * numObs) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingModelTable &table = dataset->getCalPointingModel();
	CalPointingModelRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumObsExists()) {
			*numObs = row->getNumObs();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter coeffFormula, in a row of the CalPointingModel table, given a key
 *
 */

#define sdm_addCalPointingModelCoeffFormula  sdm_addcalpointingmodelcoeffformula_
extern "C" int sdm_addCalPointingModelCoeffFormula(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, char * coeffFormula, int * coeffFormulaDim);

int sdm_addCalPointingModelCoeffFormula(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, char * coeffFormula, int * coeffFormulaDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingModelTable &table = dataset->getCalPointingModel();
	
	CalPointingModelRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<string >  coeffFormulaVec(coeffFormulaDim[2]);
		for (int i=0;i<coeffFormulaDim[2];i++)
			coeffFormulaVec[i]= string(coeffFormula+i*coeffFormulaDim[1]  
		row->setCoeffFormula(coeffFormulaVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter coeffFormula, in a row of the CalPointingModel table, given a key
 *
 */

#define sdm_getCalPointingModelCoeffFormula  sdm_getcalpointingmodelcoeffformula_
extern "C" int sdm_getCalPointingModelCoeffFormula(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, char * coeffFormula, int * coeffFormulaDim);

int sdm_getCalPointingModelCoeffFormula(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, char * coeffFormula, int * coeffFormulaDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingModelTable &table = dataset->getCalPointingModel();
	CalPointingModelRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCoeffFormulaExists()) {
			// attr.CppType: vector<string > attr.isOneD: true
			int maxDimZeroCoeffFormula = 0;
			for (int i=0; i<min((int)row->getCoeffFormula().size(),coeffFormulaDim[3]); i++) {
				if ((int)row->getCoeffFormula()[i].size()<coeffFormulaDim[1])
					strcpy(coeffFormula+i*coeffFormulaDim[1],row->getCoeffFormula()[i].c_str());
				else
					strncpy(coeffFormula+i*coeffFormulaDim[1],row->getCoeffFormula()[i].c_str(),coeffFormulaDim[1]);
				maxDimZeroCoeffFormula = max((int)row->getCoeffFormula()[i].size(),maxDimZeroCoeffFormula);
			}
			coeffFormulaDim[0] = maxDimZeroCoeffFormula;
			coeffFormulaDim[2] = row->getCoeffFormula().size();  // number of strings
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace ReceiverBandMod;
using namespace AntennaMakeMod;
using namespace AtmPhaseCorrectionMod;
using namespace PointingModelModeMod;
using namespace PointingMethodMod;
using namespace PolarizationTypeMod;


// =================== CalPointingTable ============================

extern "C" int sdm_addCalPointingRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, AntennaMake * antennaMake, AtmPhaseCorrection * atmPhaseCorrection, double * direction, int * directionDim, double * frequencyRange, int * frequencyRangeDim, PointingModelMode * pointingModelMode, PointingMethod * pointingMethod, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * collOffsetRelative, int * collOffsetRelativeDim, double * collOffsetAbsolute, int * collOffsetAbsoluteDim, double * collError, int * collErrorDim, bool * collOffsetTied, int * collOffsetTiedDim, double * reducedChiSquared, int * reducedChiSquaredDim);
extern "C" int sdm_getCalPointingRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, AntennaMake * antennaMake, AtmPhaseCorrection * atmPhaseCorrection, double * direction, int * directionDim, double * frequencyRange, int * frequencyRangeDim, PointingModelMode * pointingModelMode, PointingMethod * pointingMethod, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * collOffsetRelative, int * collOffsetRelativeDim, double * collOffsetAbsolute, int * collOffsetAbsoluteDim, double * collError, int * collErrorDim, bool * collOffsetTied, int * collOffsetTiedDim, double * reducedChiSquared, int * reducedChiSquaredDim);


extern "C" int sdm_getCalPointingTableSize ();

extern "C" int sdm_getCalPointingKeys (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalPointingRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, AntennaMake * antennaMake, AtmPhaseCorrection * atmPhaseCorrection, double * direction, int * directionDim, double * frequencyRange, int * frequencyRangeDim, PointingModelMode * pointingModelMode, PointingMethod * pointingMethod, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * collOffsetRelative, int * collOffsetRelativeDim, double * collOffsetAbsolute, int * collOffsetAbsoluteDim, double * collError, int * collErrorDim, bool * collOffsetTied, int * collOffsetTiedDim, double * reducedChiSquared, int * reducedChiSquaredDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;

	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// antennaMake is an enumeration
	// AntennaMake * antennaMake =  (int) antennaMake;
	// atmPhaseCorrection is an enumeration
	// AtmPhaseCorrection * atmPhaseCorrection =  (int) atmPhaseCorrection;
	// direction is an Array
	// direction is OneD
	vector<Angle >  directionVec(directionDim[0]);
	for (int i=0;i<directionDim[0];i++)
		directionVec[i]= Angle(direction[i]   );
	// frequencyRange is an Array
	// frequencyRange is OneD
	vector<Frequency >  frequencyRangeVec(frequencyRangeDim[0]);
	for (int i=0;i<frequencyRangeDim[0];i++)
		frequencyRangeVec[i]= Frequency(frequencyRange[i]   );
	// pointingModelMode is an enumeration
	// PointingModelMode * pointingModelMode =  (int) pointingModelMode;
	// pointingMethod is an enumeration
	// PointingMethod * pointingMethod =  (int) pointingMethod;
	// polarizationTypes is an Array
	// polarizationTypes is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec(polarizationTypesDim[0]);
	for (int i=0;i<polarizationTypesDim[0];i++)
		polarizationTypesVec[i]= PolarizationType(polarizationTypes[i]   );
	// collOffsetRelative is an Array
	// collOffsetRelative is 2 D
	vector<vector<Angle > >  collOffsetRelativeVec(collOffsetRelativeDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<collOffsetRelativeDim[2];i++) {
		collOffsetRelativeVec[i].resize(collOffsetRelativeDim[0]);
		for (int j=0;j<collOffsetRelativeDim[0];j++)
			collOffsetRelativeVec[i][j]= Angle(collOffsetRelative[i*collOffsetRelativeDim[1]+j]  );
	
	
	}
	// collOffsetAbsolute is an Array
	// collOffsetAbsolute is 2 D
	vector<vector<Angle > >  collOffsetAbsoluteVec(collOffsetAbsoluteDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<collOffsetAbsoluteDim[2];i++) {
		collOffsetAbsoluteVec[i].resize(collOffsetAbsoluteDim[0]);
		for (int j=0;j<collOffsetAbsoluteDim[0];j++)
			collOffsetAbsoluteVec[i][j]= Angle(collOffsetAbsolute[i*collOffsetAbsoluteDim[1]+j]  );
	
	
	}
	// collError is an Array
	// collError is 2 D
	vector<vector<Angle > >  collErrorVec(collErrorDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<collErrorDim[2];i++) {
		collErrorVec[i].resize(collErrorDim[0]);
		for (int j=0;j<collErrorDim[0];j++)
			collErrorVec[i][j]= Angle(collError[i*collErrorDim[1]+j]  );
	
	
	}
	// collOffsetTied is an Array
	// collOffsetTied is 2 D
	vector<vector<bool > >  collOffsetTiedVec(collOffsetTiedDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<collOffsetTiedDim[2];i++) {
		collOffsetTiedVec[i].resize(collOffsetTiedDim[0]);
		for (int j=0;j<collOffsetTiedDim[0];j++)
			collOffsetTiedVec[i][j]= bool(collOffsetTied[i*collOffsetTiedDim[1]+j]  );
	
	
	}
	// reducedChiSquared is an Array
	// reducedChiSquared is OneD
	vector<double >  reducedChiSquaredVec(reducedChiSquaredDim[0]);
	for (int i=0;i<reducedChiSquaredDim[0];i++)
		reducedChiSquaredVec[i]= double(reducedChiSquared[i]   );
	
	// Create new row
  
	row = table.newRow(string(antennaName), *receiverBand, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), Temperature(*ambientTemperature), *antennaMake, *atmPhaseCorrection, directionVec, frequencyRangeVec, *pointingModelMode, *pointingMethod, *numReceptor, polarizationTypesVec, collOffsetRelativeVec, collOffsetAbsoluteVec, collErrorVec, collOffsetTiedVec, reducedChiSquaredVec);

	// Add row
	CalPointingRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalPointingTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalPointingRow* given a key.
 */
int sdm_getCalPointingRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * ambientTemperature, AntennaMake * antennaMake, AtmPhaseCorrection * atmPhaseCorrection, double * direction, int * directionDim, double * frequencyRange, int * frequencyRangeDim, PointingModelMode * pointingModelMode, PointingMethod * pointingMethod, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * collOffsetRelative, int * collOffsetRelativeDim, double * collOffsetAbsolute, int * collOffsetAbsoluteDim, double * collError, int * collErrorDim, bool * collOffsetTied, int * collOffsetTiedDim, double * reducedChiSquared, int * reducedChiSquaredDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaName  attr.UpperCaseName: AntennaName
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  ambientTemperature  attr.UpperCaseName: AmbientTemperature
		*ambientTemperature = row->getAmbientTemperature().get();
		//  attr.NameS:  antennaMake  attr.UpperCaseName: AntennaMake
		*antennaMake = row->getAntennaMake();
		//  attr.NameS:  atmPhaseCorrection  attr.UpperCaseName: AtmPhaseCorrection
		*atmPhaseCorrection = row->getAtmPhaseCorrection();
		//  attr.NameS:  direction  attr.UpperCaseName: Direction
		
		vector<Angle >  directionVec = row->getDirection();
		
		for (int i=0; i<min((int)directionVec.size(),directionDim[1]); i++)
			direction[i] = directionVec[i].get();
		directionDim[0] = directionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  frequencyRange  attr.UpperCaseName: FrequencyRange
		
		vector<Frequency >  frequencyRangeVec = row->getFrequencyRange();
		
		for (int i=0; i<min((int)frequencyRangeVec.size(),frequencyRangeDim[1]); i++)
			frequencyRange[i] = frequencyRangeVec[i].get();
		frequencyRangeDim[0] = frequencyRangeVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  pointingModelMode  attr.UpperCaseName: PointingModelMode
		*pointingModelMode = row->getPointingModelMode();
		//  attr.NameS:  pointingMethod  attr.UpperCaseName: PointingMethod
		*pointingMethod = row->getPointingMethod();
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  polarizationTypes  attr.UpperCaseName: PolarizationTypes
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec = row->getPolarizationTypes();
		
		for (int i=0; i<min((int)polarizationTypesVec.size(),polarizationTypesDim[1]); i++)
			polarizationTypes[i] = polarizationTypesVec[i];
		polarizationTypesDim[0] = (int)polarizationTypesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  collOffsetRelative  attr.UpperCaseName: CollOffsetRelative
		
		vector<vector<Angle > >  collOffsetRelativeVec = row->getCollOffsetRelative();
		
		int maxDimZeroCollOffsetRelative = 0;
		for (int i=0; i< min((int)collOffsetRelativeVec.size(),collOffsetRelativeDim[3]) ;i++) {
			maxDimZeroCollOffsetRelative = max((int)collOffsetRelativeVec[i].size(),maxDimZeroCollOffsetRelative);
			for (int j=0; j<min((int)collOffsetRelativeVec[i].size(),collOffsetRelativeDim[1]) ;j++) {
				collOffsetRelative[i*collOffsetRelativeDim[1]+j] = collOffsetRelativeVec[i][j].get();
			}
		}
		collOffsetRelativeDim[0] = maxDimZeroCollOffsetRelative;
		collOffsetRelativeDim[2] = collOffsetRelativeVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  collOffsetAbsolute  attr.UpperCaseName: CollOffsetAbsolute
		
		vector<vector<Angle > >  collOffsetAbsoluteVec = row->getCollOffsetAbsolute();
		
		int maxDimZeroCollOffsetAbsolute = 0;
		for (int i=0; i< min((int)collOffsetAbsoluteVec.size(),collOffsetAbsoluteDim[3]) ;i++) {
			maxDimZeroCollOffsetAbsolute = max((int)collOffsetAbsoluteVec[i].size(),maxDimZeroCollOffsetAbsolute);
			for (int j=0; j<min((int)collOffsetAbsoluteVec[i].size(),collOffsetAbsoluteDim[1]) ;j++) {
				collOffsetAbsolute[i*collOffsetAbsoluteDim[1]+j] = collOffsetAbsoluteVec[i][j].get();
			}
		}
		collOffsetAbsoluteDim[0] = maxDimZeroCollOffsetAbsolute;
		collOffsetAbsoluteDim[2] = collOffsetAbsoluteVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  collError  attr.UpperCaseName: CollError
		
		vector<vector<Angle > >  collErrorVec = row->getCollError();
		
		int maxDimZeroCollError = 0;
		for (int i=0; i< min((int)collErrorVec.size(),collErrorDim[3]) ;i++) {
			maxDimZeroCollError = max((int)collErrorVec[i].size(),maxDimZeroCollError);
			for (int j=0; j<min((int)collErrorVec[i].size(),collErrorDim[1]) ;j++) {
				collError[i*collErrorDim[1]+j] = collErrorVec[i][j].get();
			}
		}
		collErrorDim[0] = maxDimZeroCollError;
		collErrorDim[2] = collErrorVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  collOffsetTied  attr.UpperCaseName: CollOffsetTied
		
		vector<vector<bool > >  collOffsetTiedVec = row->getCollOffsetTied();
		
		int maxDimZeroCollOffsetTied = 0;
		for (int i=0;i<min((int)collOffsetTiedVec.size(),collOffsetTiedDim[3]) ;i++) {
			maxDimZeroCollOffsetTied = max((int)collOffsetTiedVec[i].size(),maxDimZeroCollOffsetTied);
			for (int j=0;j<min((int)collOffsetTiedVec[i].size(),collOffsetTiedDim[1]) ;j++) {
				collOffsetTied[i*collOffsetTiedDim[1]+j]= collOffsetTiedVec[i][j];
			}
		}
		collOffsetTiedDim[0] = maxDimZeroCollOffsetTied;
		collOffsetTiedDim[2] = collOffsetTiedVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  reducedChiSquared  attr.UpperCaseName: ReducedChiSquared
		
		vector<double >  reducedChiSquaredVec = row->getReducedChiSquared();
		
		for (int i=0; i<min((int)reducedChiSquaredVec.size(),reducedChiSquaredDim[1]); i++)
			reducedChiSquared[i] = reducedChiSquaredVec[i];
		reducedChiSquaredDim[0] = (int)reducedChiSquaredVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalPointingTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalPointingTable &table = dataset->getCalPointing();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalPointingKeys(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	
	vector< CalPointingRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroAntennaName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getAntennaName().size() < antennaNameDim[1])
	  			strcpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str());
	  		else
	  			strncpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str(),antennaNameDim[1]);
	  		maxDimZeroAntennaName = max((int)row[i]->getAntennaName().size(), maxDimZeroAntennaName);
	  		receiverBand[i] = row[i]->getReceiverBand();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
antennaNameDim[0] = maxDimZeroAntennaName ;
antennaNameDim[2] = size ;
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter averagedPolarizations, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingAveragedPolarizations  sdm_addcalpointingaveragedpolarizations_
extern "C" int sdm_addCalPointingAveragedPolarizations(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * averagedPolarizations);

int sdm_addCalPointingAveragedPolarizations(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * averagedPolarizations) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setAveragedPolarizations(bool(* averagedPolarizations ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter averagedPolarizations, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingAveragedPolarizations  sdm_getcalpointingaveragedpolarizations_
extern "C" int sdm_getCalPointingAveragedPolarizations(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * averagedPolarizations);

int sdm_getCalPointingAveragedPolarizations(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * averagedPolarizations) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAveragedPolarizationsExists()) {
			*averagedPolarizations = row->getAveragedPolarizations();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter beamPA, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingBeamPA  sdm_addcalpointingbeampa_
extern "C" int sdm_addCalPointingBeamPA(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamPA, int * beamPADim);

int sdm_addCalPointingBeamPA(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamPA, int * beamPADim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Angle >  beamPAVec(beamPADim[0]);
		for (int i=0;i<beamPADim[0];i++)
			beamPAVec[i]= Angle(beamPA[i] );
		row->setBeamPA(beamPAVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter beamPA, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingBeamPA  sdm_getcalpointingbeampa_
extern "C" int sdm_getCalPointingBeamPA(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamPA, int * beamPADim);

int sdm_getCalPointingBeamPA(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamPA, int * beamPADim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isBeamPAExists()) {
			// attr.CppType: vector<Angle > attr.isOneD: true
			for (int i=0; i<min((int)row->getBeamPA().size(),beamPADim[1]); i++)
				beamPA[i] = row->getBeamPA()[i].get();
			beamPADim[0] = row->getBeamPA().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter beamPAError, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingBeamPAError  sdm_addcalpointingbeampaerror_
extern "C" int sdm_addCalPointingBeamPAError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamPAError, int * beamPAErrorDim);

int sdm_addCalPointingBeamPAError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamPAError, int * beamPAErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Angle >  beamPAErrorVec(beamPAErrorDim[0]);
		for (int i=0;i<beamPAErrorDim[0];i++)
			beamPAErrorVec[i]= Angle(beamPAError[i] );
		row->setBeamPAError(beamPAErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter beamPAError, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingBeamPAError  sdm_getcalpointingbeampaerror_
extern "C" int sdm_getCalPointingBeamPAError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamPAError, int * beamPAErrorDim);

int sdm_getCalPointingBeamPAError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamPAError, int * beamPAErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isBeamPAErrorExists()) {
			// attr.CppType: vector<Angle > attr.isOneD: true
			for (int i=0; i<min((int)row->getBeamPAError().size(),beamPAErrorDim[1]); i++)
				beamPAError[i] = row->getBeamPAError()[i].get();
			beamPAErrorDim[0] = row->getBeamPAError().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter beamPAWasFixed, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingBeamPAWasFixed  sdm_addcalpointingbeampawasfixed_
extern "C" int sdm_addCalPointingBeamPAWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * beamPAWasFixed);

int sdm_addCalPointingBeamPAWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * beamPAWasFixed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setBeamPAWasFixed(bool(* beamPAWasFixed ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter beamPAWasFixed, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingBeamPAWasFixed  sdm_getcalpointingbeampawasfixed_
extern "C" int sdm_getCalPointingBeamPAWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * beamPAWasFixed);

int sdm_getCalPointingBeamPAWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * beamPAWasFixed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isBeamPAWasFixedExists()) {
			*beamPAWasFixed = row->getBeamPAWasFixed();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter beamWidth, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingBeamWidth  sdm_addcalpointingbeamwidth_
extern "C" int sdm_addCalPointingBeamWidth(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamWidth, int * beamWidthDim);

int sdm_addCalPointingBeamWidth(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamWidth, int * beamWidthDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par beamWidth:
		vector<vector<Angle > >  beamWidthVec(beamWidthDim[2]);
		for (int i=0;i<beamWidthDim[2];i++) {
			beamWidthVec[i].resize(beamWidthDim[0]);
			for (int j=0;j<beamWidthDim[0];j++)
				beamWidthVec[i][j]= Angle(beamWidth[i*(beamWidthDim[1])+j]);
		}
		row->setBeamWidth(beamWidthVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter beamWidth, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingBeamWidth  sdm_getcalpointingbeamwidth_
extern "C" int sdm_getCalPointingBeamWidth(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamWidth, int * beamWidthDim);

int sdm_getCalPointingBeamWidth(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamWidth, int * beamWidthDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isBeamWidthExists()) {
			// attr.CppType: vector<vector<Angle > > attr.isOneD: false
			int maxDimZeroBeamWidth = 0;
			for (int i=0; i< min((int)row->getBeamWidth().size(),beamWidthDim[3]) ;i++) {
				maxDimZeroBeamWidth = max((int)row->getBeamWidth()[i].size(),maxDimZeroBeamWidth);
				for (int j=0; j<min((int)row->getBeamWidth()[i].size(),beamWidthDim[1]) ;j++) {
					beamWidth[i*beamWidthDim[1]+j] = row->getBeamWidth()[i][j].get();
				}
			}
			beamWidthDim[0] = maxDimZeroBeamWidth;
			beamWidthDim[2] = row->getBeamWidth().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter beamWidthError, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingBeamWidthError  sdm_addcalpointingbeamwidtherror_
extern "C" int sdm_addCalPointingBeamWidthError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamWidthError, int * beamWidthErrorDim);

int sdm_addCalPointingBeamWidthError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamWidthError, int * beamWidthErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par beamWidthError:
		vector<vector<Angle > >  beamWidthErrorVec(beamWidthErrorDim[2]);
		for (int i=0;i<beamWidthErrorDim[2];i++) {
			beamWidthErrorVec[i].resize(beamWidthErrorDim[0]);
			for (int j=0;j<beamWidthErrorDim[0];j++)
				beamWidthErrorVec[i][j]= Angle(beamWidthError[i*(beamWidthErrorDim[1])+j]);
		}
		row->setBeamWidthError(beamWidthErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter beamWidthError, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingBeamWidthError  sdm_getcalpointingbeamwidtherror_
extern "C" int sdm_getCalPointingBeamWidthError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamWidthError, int * beamWidthErrorDim);

int sdm_getCalPointingBeamWidthError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * beamWidthError, int * beamWidthErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isBeamWidthErrorExists()) {
			// attr.CppType: vector<vector<Angle > > attr.isOneD: false
			int maxDimZeroBeamWidthError = 0;
			for (int i=0; i< min((int)row->getBeamWidthError().size(),beamWidthErrorDim[3]) ;i++) {
				maxDimZeroBeamWidthError = max((int)row->getBeamWidthError()[i].size(),maxDimZeroBeamWidthError);
				for (int j=0; j<min((int)row->getBeamWidthError()[i].size(),beamWidthErrorDim[1]) ;j++) {
					beamWidthError[i*beamWidthErrorDim[1]+j] = row->getBeamWidthError()[i][j].get();
				}
			}
			beamWidthErrorDim[0] = maxDimZeroBeamWidthError;
			beamWidthErrorDim[2] = row->getBeamWidthError().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter beamWidthWasFixed, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingBeamWidthWasFixed  sdm_addcalpointingbeamwidthwasfixed_
extern "C" int sdm_addCalPointingBeamWidthWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * beamWidthWasFixed, int * beamWidthWasFixedDim);

int sdm_addCalPointingBeamWidthWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * beamWidthWasFixed, int * beamWidthWasFixedDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<bool >  beamWidthWasFixedVec(beamWidthWasFixedDim[0]);
		for (int i=0;i<beamWidthWasFixedDim[0];i++)
			beamWidthWasFixedVec[i]= bool(beamWidthWasFixed[i] );
		row->setBeamWidthWasFixed(beamWidthWasFixedVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter beamWidthWasFixed, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingBeamWidthWasFixed  sdm_getcalpointingbeamwidthwasfixed_
extern "C" int sdm_getCalPointingBeamWidthWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * beamWidthWasFixed, int * beamWidthWasFixedDim);

int sdm_getCalPointingBeamWidthWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * beamWidthWasFixed, int * beamWidthWasFixedDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isBeamWidthWasFixedExists()) {
			// attr.CppType: vector<bool > attr.isOneD: true
			for (int i=0; i<min((int)row->getBeamWidthWasFixed().size(),beamWidthWasFixedDim[1]); i++)
				beamWidthWasFixed[i] = row->getBeamWidthWasFixed()[i];
			beamWidthWasFixedDim[0] = (int)row->getBeamWidthWasFixed().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter offIntensity, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingOffIntensity  sdm_addcalpointingoffintensity_
extern "C" int sdm_addCalPointingOffIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensity, int * offIntensityDim);

int sdm_addCalPointingOffIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensity, int * offIntensityDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  offIntensityVec(offIntensityDim[0]);
		for (int i=0;i<offIntensityDim[0];i++)
			offIntensityVec[i]= Temperature(offIntensity[i] );
		row->setOffIntensity(offIntensityVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter offIntensity, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingOffIntensity  sdm_getcalpointingoffintensity_
extern "C" int sdm_getCalPointingOffIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensity, int * offIntensityDim);

int sdm_getCalPointingOffIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensity, int * offIntensityDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isOffIntensityExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getOffIntensity().size(),offIntensityDim[1]); i++)
				offIntensity[i] = row->getOffIntensity()[i].get();
			offIntensityDim[0] = row->getOffIntensity().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter offIntensityError, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingOffIntensityError  sdm_addcalpointingoffintensityerror_
extern "C" int sdm_addCalPointingOffIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensityError, int * offIntensityErrorDim);

int sdm_addCalPointingOffIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensityError, int * offIntensityErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  offIntensityErrorVec(offIntensityErrorDim[0]);
		for (int i=0;i<offIntensityErrorDim[0];i++)
			offIntensityErrorVec[i]= Temperature(offIntensityError[i] );
		row->setOffIntensityError(offIntensityErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter offIntensityError, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingOffIntensityError  sdm_getcalpointingoffintensityerror_
extern "C" int sdm_getCalPointingOffIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensityError, int * offIntensityErrorDim);

int sdm_getCalPointingOffIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * offIntensityError, int * offIntensityErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isOffIntensityErrorExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getOffIntensityError().size(),offIntensityErrorDim[1]); i++)
				offIntensityError[i] = row->getOffIntensityError()[i].get();
			offIntensityErrorDim[0] = row->getOffIntensityError().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter offIntensityWasFixed, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingOffIntensityWasFixed  sdm_addcalpointingoffintensitywasfixed_
extern "C" int sdm_addCalPointingOffIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * offIntensityWasFixed);

int sdm_addCalPointingOffIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * offIntensityWasFixed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setOffIntensityWasFixed(bool(* offIntensityWasFixed ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter offIntensityWasFixed, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingOffIntensityWasFixed  sdm_getcalpointingoffintensitywasfixed_
extern "C" int sdm_getCalPointingOffIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * offIntensityWasFixed);

int sdm_getCalPointingOffIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * offIntensityWasFixed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isOffIntensityWasFixedExists()) {
			*offIntensityWasFixed = row->getOffIntensityWasFixed();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter peakIntensity, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingPeakIntensity  sdm_addcalpointingpeakintensity_
extern "C" int sdm_addCalPointingPeakIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensity, int * peakIntensityDim);

int sdm_addCalPointingPeakIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensity, int * peakIntensityDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  peakIntensityVec(peakIntensityDim[0]);
		for (int i=0;i<peakIntensityDim[0];i++)
			peakIntensityVec[i]= Temperature(peakIntensity[i] );
		row->setPeakIntensity(peakIntensityVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter peakIntensity, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingPeakIntensity  sdm_getcalpointingpeakintensity_
extern "C" int sdm_getCalPointingPeakIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensity, int * peakIntensityDim);

int sdm_getCalPointingPeakIntensity(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensity, int * peakIntensityDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPeakIntensityExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getPeakIntensity().size(),peakIntensityDim[1]); i++)
				peakIntensity[i] = row->getPeakIntensity()[i].get();
			peakIntensityDim[0] = row->getPeakIntensity().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter peakIntensityError, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingPeakIntensityError  sdm_addcalpointingpeakintensityerror_
extern "C" int sdm_addCalPointingPeakIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensityError, int * peakIntensityErrorDim);

int sdm_addCalPointingPeakIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensityError, int * peakIntensityErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  peakIntensityErrorVec(peakIntensityErrorDim[0]);
		for (int i=0;i<peakIntensityErrorDim[0];i++)
			peakIntensityErrorVec[i]= Temperature(peakIntensityError[i] );
		row->setPeakIntensityError(peakIntensityErrorVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter peakIntensityError, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingPeakIntensityError  sdm_getcalpointingpeakintensityerror_
extern "C" int sdm_getCalPointingPeakIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensityError, int * peakIntensityErrorDim);

int sdm_getCalPointingPeakIntensityError(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, double * peakIntensityError, int * peakIntensityErrorDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPeakIntensityErrorExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getPeakIntensityError().size(),peakIntensityErrorDim[1]); i++)
				peakIntensityError[i] = row->getPeakIntensityError()[i].get();
			peakIntensityErrorDim[0] = row->getPeakIntensityError().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter peakIntensityWasFixed, in a row of the CalPointing table, given a key
 *
 */

#define sdm_addCalPointingPeakIntensityWasFixed  sdm_addcalpointingpeakintensitywasfixed_
extern "C" int sdm_addCalPointingPeakIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * peakIntensityWasFixed);

int sdm_addCalPointingPeakIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * peakIntensityWasFixed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPointingTable &table = dataset->getCalPointing();
	
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setPeakIntensityWasFixed(bool(* peakIntensityWasFixed ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter peakIntensityWasFixed, in a row of the CalPointing table, given a key
 *
 */

#define sdm_getCalPointingPeakIntensityWasFixed  sdm_getcalpointingpeakintensitywasfixed_
extern "C" int sdm_getCalPointingPeakIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * peakIntensityWasFixed);

int sdm_getCalPointingPeakIntensityWasFixed(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, bool * peakIntensityWasFixed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPointingTable &table = dataset->getCalPointing();
	CalPointingRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPeakIntensityWasFixedExists()) {
			*peakIntensityWasFixed = row->getPeakIntensityWasFixed();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace AtmPhaseCorrectionMod;
using namespace PositionMethodMod;
using namespace ReceiverBandMod;


// =================== CalPositionTable ============================

extern "C" int sdm_addCalPositionRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * antennaPosition, int * antennaPositionDim, char * stationName, int * stationNameDim, double * stationPosition, int * stationPositionDim, PositionMethod * positionMethod, ReceiverBand * receiverBand, int * numAntenna, char * refAntennaNames, int * refAntennaNamesDim, double * axesOffset, double * axesOffsetErr, bool * axesOffsetFixed, double * positionOffset, int * positionOffsetDim, double * positionErr, int * positionErrDim, double * reducedChiSquared);
extern "C" int sdm_getCalPositionRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * antennaPosition, int * antennaPositionDim, char * stationName, int * stationNameDim, double * stationPosition, int * stationPositionDim, PositionMethod * positionMethod, ReceiverBand * receiverBand, int * numAntenna, char * refAntennaNames, int * refAntennaNamesDim, double * axesOffset, double * axesOffsetErr, bool * axesOffsetFixed, double * positionOffset, int * positionOffsetDim, double * positionErr, int * positionErrDim, double * reducedChiSquared);


extern "C" int sdm_getCalPositionTableSize ();

extern "C" int sdm_getCalPositionKeys (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalPositionRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * antennaPosition, int * antennaPositionDim, char * stationName, int * stationNameDim, double * stationPosition, int * stationPositionDim, PositionMethod * positionMethod, ReceiverBand * receiverBand, int * numAntenna, char * refAntennaNames, int * refAntennaNamesDim, double * axesOffset, double * axesOffsetErr, bool * axesOffsetFixed, double * positionOffset, int * positionOffsetDim, double * positionErr, int * positionErrDim, double * reducedChiSquared){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalPositionTable &table = dataset->getCalPosition();
	CalPositionRow *row = 0;

	// atmPhaseCorrection is an enumeration
	// AtmPhaseCorrection * atmPhaseCorrection =  (int) atmPhaseCorrection;
	// antennaPosition is an Array
	// antennaPosition is OneD
	vector<Length >  antennaPositionVec(antennaPositionDim[0]);
	for (int i=0;i<antennaPositionDim[0];i++)
		antennaPositionVec[i]= Length(antennaPosition[i]   );
	// stationPosition is an Array
	// stationPosition is OneD
	vector<Length >  stationPositionVec(stationPositionDim[0]);
	for (int i=0;i<stationPositionDim[0];i++)
		stationPositionVec[i]= Length(stationPosition[i]   );
	// positionMethod is an enumeration
	// PositionMethod * positionMethod =  (int) positionMethod;
	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// refAntennaNames is an Array
	// refAntennaNames is OneD
	vector<string >  refAntennaNamesVec(refAntennaNamesDim[2]);
	for (int i=0;i<refAntennaNamesDim[2];i++)
		refAntennaNamesVec[i]= string(refAntennaNames+i*refAntennaNamesDim[1]  );
	// positionOffset is an Array
	// positionOffset is OneD
	vector<Length >  positionOffsetVec(positionOffsetDim[0]);
	for (int i=0;i<positionOffsetDim[0];i++)
		positionOffsetVec[i]= Length(positionOffset[i]   );
	// positionErr is an Array
	// positionErr is OneD
	vector<Length >  positionErrVec(positionErrDim[0]);
	for (int i=0;i<positionErrDim[0];i++)
		positionErrVec[i]= Length(positionErr[i]   );
	
	// Create new row
  
	row = table.newRow(string(antennaName), *atmPhaseCorrection, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), antennaPositionVec, string(stationName), stationPositionVec, *positionMethod, *receiverBand, *numAntenna, refAntennaNamesVec, Length(*axesOffset), Length(*axesOffsetErr), *axesOffsetFixed, positionOffsetVec, positionErrVec, *reducedChiSquared);

	// Add row
	CalPositionRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalPositionTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalPositionRow* given a key.
 */
int sdm_getCalPositionRow (char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * antennaPosition, int * antennaPositionDim, char * stationName, int * stationNameDim, double * stationPosition, int * stationPositionDim, PositionMethod * positionMethod, ReceiverBand * receiverBand, int * numAntenna, char * refAntennaNames, int * refAntennaNamesDim, double * axesOffset, double * axesOffsetErr, bool * axesOffsetFixed, double * positionOffset, int * positionOffsetDim, double * positionErr, int * positionErrDim, double * reducedChiSquared) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPositionTable &table = dataset->getCalPosition();
	CalPositionRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaName  attr.UpperCaseName: AntennaName
		//  attr.NameS:  atmPhaseCorrection  attr.UpperCaseName: AtmPhaseCorrection
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  antennaPosition  attr.UpperCaseName: AntennaPosition
		
		vector<Length >  antennaPositionVec = row->getAntennaPosition();
		
		for (int i=0; i<min((int)antennaPositionVec.size(),antennaPositionDim[1]); i++)
			antennaPosition[i] = antennaPositionVec[i].get();
		antennaPositionDim[0] = antennaPositionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  stationName  attr.UpperCaseName: StationName
		if ((int)row->getStationName().size()<stationNameDim[1])
			strcpy(stationName,row->getStationName().c_str());
		else
			strncpy(stationName,row->getStationName().c_str(),stationNameDim[1]);
		stationNameDim[0] = (int)row->getStationName().size();
		//  attr.NameS:  stationPosition  attr.UpperCaseName: StationPosition
		
		vector<Length >  stationPositionVec = row->getStationPosition();
		
		for (int i=0; i<min((int)stationPositionVec.size(),stationPositionDim[1]); i++)
			stationPosition[i] = stationPositionVec[i].get();
		stationPositionDim[0] = stationPositionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  positionMethod  attr.UpperCaseName: PositionMethod
		*positionMethod = row->getPositionMethod();
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		*receiverBand = row->getReceiverBand();
		//  attr.NameS:  numAntenna  attr.UpperCaseName: NumAntenna
		*numAntenna = row->getNumAntenna();
		//  attr.NameS:  refAntennaNames  attr.UpperCaseName: RefAntennaNames
		
		vector<string >  refAntennaNamesVec = row->getRefAntennaNames();
		
		int maxDimZeroRefAntennaNames = 0;
		for (int i=0; i<min((int)refAntennaNamesVec.size(),refAntennaNamesDim[3]); i++) {
			if ((int)refAntennaNamesVec[i].size()<refAntennaNamesDim[1])
				strcpy(refAntennaNames+i*refAntennaNamesDim[1],refAntennaNamesVec[i].c_str());
			else
				strncpy(refAntennaNames+i*refAntennaNamesDim[1],refAntennaNamesVec[i].c_str(),refAntennaNamesDim[1]);
			maxDimZeroRefAntennaNames = max((int)refAntennaNamesVec[i].size(),maxDimZeroRefAntennaNames);
		}
		refAntennaNamesDim[0] = maxDimZeroRefAntennaNames;
		refAntennaNamesDim[2] = refAntennaNamesVec.size();  // number of strings
		
		
		//  attr.NameS:  axesOffset  attr.UpperCaseName: AxesOffset
		*axesOffset = row->getAxesOffset().get();
		//  attr.NameS:  axesOffsetErr  attr.UpperCaseName: AxesOffsetErr
		*axesOffsetErr = row->getAxesOffsetErr().get();
		//  attr.NameS:  axesOffsetFixed  attr.UpperCaseName: AxesOffsetFixed
		*axesOffsetFixed = row->getAxesOffsetFixed();
		//  attr.NameS:  positionOffset  attr.UpperCaseName: PositionOffset
		
		vector<Length >  positionOffsetVec = row->getPositionOffset();
		
		for (int i=0; i<min((int)positionOffsetVec.size(),positionOffsetDim[1]); i++)
			positionOffset[i] = positionOffsetVec[i].get();
		positionOffsetDim[0] = positionOffsetVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  positionErr  attr.UpperCaseName: PositionErr
		
		vector<Length >  positionErrVec = row->getPositionErr();
		
		for (int i=0; i<min((int)positionErrVec.size(),positionErrDim[1]); i++)
			positionErr[i] = positionErrVec[i].get();
		positionErrDim[0] = positionErrVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  reducedChiSquared  attr.UpperCaseName: ReducedChiSquared
		*reducedChiSquared = row->getReducedChiSquared();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalPositionTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalPositionTable &table = dataset->getCalPosition();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalPositionKeys(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalPositionTable &table = dataset->getCalPosition();
	
	vector< CalPositionRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroAntennaName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getAntennaName().size() < antennaNameDim[1])
	  			strcpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str());
	  		else
	  			strncpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str(),antennaNameDim[1]);
	  		maxDimZeroAntennaName = max((int)row[i]->getAntennaName().size(), maxDimZeroAntennaName);
	  		atmPhaseCorrection[i] = row[i]->getAtmPhaseCorrection();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
antennaNameDim[0] = maxDimZeroAntennaName ;
antennaNameDim[2] = size ;
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter delayRms, in a row of the CalPosition table, given a key
 *
 */

#define sdm_addCalPositionDelayRms  sdm_addcalpositiondelayrms_
extern "C" int sdm_addCalPositionDelayRms(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * delayRms);

int sdm_addCalPositionDelayRms(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * delayRms) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPositionTable &table = dataset->getCalPosition();
	
	CalPositionRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDelayRms(double(* delayRms ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter delayRms, in a row of the CalPosition table, given a key
 *
 */

#define sdm_getCalPositionDelayRms  sdm_getcalpositiondelayrms_
extern "C" int sdm_getCalPositionDelayRms(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * delayRms);

int sdm_getCalPositionDelayRms(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * delayRms) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPositionTable &table = dataset->getCalPosition();
	CalPositionRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDelayRmsExists()) {
			*delayRms = row->getDelayRms();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter phaseRms, in a row of the CalPosition table, given a key
 *
 */

#define sdm_addCalPositionPhaseRms  sdm_addcalpositionphaserms_
extern "C" int sdm_addCalPositionPhaseRms(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * phaseRms);

int sdm_addCalPositionPhaseRms(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * phaseRms) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPositionTable &table = dataset->getCalPosition();
	
	CalPositionRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setPhaseRms(Angle(* phaseRms ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter phaseRms, in a row of the CalPosition table, given a key
 *
 */

#define sdm_getCalPositionPhaseRms  sdm_getcalpositionphaserms_
extern "C" int sdm_getCalPositionPhaseRms(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * phaseRms);

int sdm_getCalPositionPhaseRms(char * antennaName, int * antennaNameDim, AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * phaseRms) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalPositionTable &table = dataset->getCalPosition();
	CalPositionRow *row = 0;
	row = table.getRowByKey( string(antennaName), *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPhaseRmsExists()) {
			*phaseRms = row->getPhaseRms().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace ReceiverBandMod;
using namespace AntennaMakeMod;
using namespace PolarizationTypeMod;
using namespace PrimaryBeamDescriptionMod;


// =================== CalPrimaryBeamTable ============================

extern "C" int sdm_addCalPrimaryBeamRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, int * numSubband, double * frequencyRange, int * frequencyRangeDim, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * mainBeamEfficiency, int * mainBeamEfficiencyDim, char * beamDescriptionUID, int * beamDescriptionUIDDim, float * relativeAmplitudeRms, double * direction, int * directionDim, double * minValidDirection, int * minValidDirectionDim, double * maxValidDirection, int * maxValidDirectionDim, PrimaryBeamDescription * descriptionType, int * imageChannelNumber, int * imageChannelNumberDim, double * imageNominalFrequency, int * imageNominalFrequencyDim);
extern "C" int sdm_getCalPrimaryBeamRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, int * numSubband, double * frequencyRange, int * frequencyRangeDim, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * mainBeamEfficiency, int * mainBeamEfficiencyDim, char * beamDescriptionUID, int * beamDescriptionUIDDim, float * relativeAmplitudeRms, double * direction, int * directionDim, double * minValidDirection, int * minValidDirectionDim, double * maxValidDirection, int * maxValidDirectionDim, PrimaryBeamDescription * descriptionType, int * imageChannelNumber, int * imageChannelNumberDim, double * imageNominalFrequency, int * imageNominalFrequencyDim);


extern "C" int sdm_getCalPrimaryBeamTableSize ();

extern "C" int sdm_getCalPrimaryBeamKeys (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalPrimaryBeamRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, int * numSubband, double * frequencyRange, int * frequencyRangeDim, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * mainBeamEfficiency, int * mainBeamEfficiencyDim, char * beamDescriptionUID, int * beamDescriptionUIDDim, float * relativeAmplitudeRms, double * direction, int * directionDim, double * minValidDirection, int * minValidDirectionDim, double * maxValidDirection, int * maxValidDirectionDim, PrimaryBeamDescription * descriptionType, int * imageChannelNumber, int * imageChannelNumberDim, double * imageNominalFrequency, int * imageNominalFrequencyDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalPrimaryBeamTable &table = dataset->getCalPrimaryBeam();
	CalPrimaryBeamRow *row = 0;

	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// antennaMake is an enumeration
	// AntennaMake * antennaMake =  (int) antennaMake;
	// frequencyRange is an Array
	// frequencyRange is 2 D
	vector<vector<Frequency > >  frequencyRangeVec(frequencyRangeDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<frequencyRangeDim[2];i++) {
		frequencyRangeVec[i].resize(frequencyRangeDim[0]);
		for (int j=0;j<frequencyRangeDim[0];j++)
			frequencyRangeVec[i][j]= Frequency(frequencyRange[i*frequencyRangeDim[1]+j]  );
	
	
	}
	// polarizationTypes is an Array
	// polarizationTypes is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec(polarizationTypesDim[0]);
	for (int i=0;i<polarizationTypesDim[0];i++)
		polarizationTypesVec[i]= PolarizationType(polarizationTypes[i]   );
	// mainBeamEfficiency is an Array
	// mainBeamEfficiency is OneD
	vector<double >  mainBeamEfficiencyVec(mainBeamEfficiencyDim[0]);
	for (int i=0;i<mainBeamEfficiencyDim[0];i++)
		mainBeamEfficiencyVec[i]= double(mainBeamEfficiency[i]   );
	// direction is an Array
	// direction is OneD
	vector<Angle >  directionVec(directionDim[0]);
	for (int i=0;i<directionDim[0];i++)
		directionVec[i]= Angle(direction[i]   );
	// minValidDirection is an Array
	// minValidDirection is OneD
	vector<Angle >  minValidDirectionVec(minValidDirectionDim[0]);
	for (int i=0;i<minValidDirectionDim[0];i++)
		minValidDirectionVec[i]= Angle(minValidDirection[i]   );
	// maxValidDirection is an Array
	// maxValidDirection is OneD
	vector<Angle >  maxValidDirectionVec(maxValidDirectionDim[0]);
	for (int i=0;i<maxValidDirectionDim[0];i++)
		maxValidDirectionVec[i]= Angle(maxValidDirection[i]   );
	// descriptionType is an enumeration
	// PrimaryBeamDescription * descriptionType =  (int) descriptionType;
	// imageChannelNumber is an Array
	// imageChannelNumber is OneD
	vector<int >  imageChannelNumberVec(imageChannelNumberDim[0]);
	for (int i=0;i<imageChannelNumberDim[0];i++)
		imageChannelNumberVec[i]= int(imageChannelNumber[i]   );
	// imageNominalFrequency is an Array
	// imageNominalFrequency is OneD
	vector<Frequency >  imageNominalFrequencyVec(imageNominalFrequencyDim[0]);
	for (int i=0;i<imageNominalFrequencyDim[0];i++)
		imageNominalFrequencyVec[i]= Frequency(imageNominalFrequency[i]   );
	
	// Create new row
  
	row = table.newRow(string(antennaName), *receiverBand, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), *antennaMake, *numSubband, frequencyRangeVec, *numReceptor, polarizationTypesVec, mainBeamEfficiencyVec, EntityRef(string(beamDescriptionUID)), *relativeAmplitudeRms, directionVec, minValidDirectionVec, maxValidDirectionVec, *descriptionType, imageChannelNumberVec, imageNominalFrequencyVec);

	// Add row
	CalPrimaryBeamRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalPrimaryBeamTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalPrimaryBeamRow* given a key.
 */
int sdm_getCalPrimaryBeamRow (char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, AntennaMake * antennaMake, int * numSubband, double * frequencyRange, int * frequencyRangeDim, int * numReceptor, PolarizationType * polarizationTypes, int * polarizationTypesDim, double * mainBeamEfficiency, int * mainBeamEfficiencyDim, char * beamDescriptionUID, int * beamDescriptionUIDDim, float * relativeAmplitudeRms, double * direction, int * directionDim, double * minValidDirection, int * minValidDirectionDim, double * maxValidDirection, int * maxValidDirectionDim, PrimaryBeamDescription * descriptionType, int * imageChannelNumber, int * imageChannelNumberDim, double * imageNominalFrequency, int * imageNominalFrequencyDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalPrimaryBeamTable &table = dataset->getCalPrimaryBeam();
	CalPrimaryBeamRow *row = 0;
	row = table.getRowByKey( string(antennaName), *receiverBand, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaName  attr.UpperCaseName: AntennaName
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  antennaMake  attr.UpperCaseName: AntennaMake
		*antennaMake = row->getAntennaMake();
		//  attr.NameS:  numSubband  attr.UpperCaseName: NumSubband
		*numSubband = row->getNumSubband();
		//  attr.NameS:  frequencyRange  attr.UpperCaseName: FrequencyRange
		
		vector<vector<Frequency > >  frequencyRangeVec = row->getFrequencyRange();
		
		int maxDimZeroFrequencyRange = 0;
		for (int i=0; i< min((int)frequencyRangeVec.size(),frequencyRangeDim[3]) ;i++) {
			maxDimZeroFrequencyRange = max((int)frequencyRangeVec[i].size(),maxDimZeroFrequencyRange);
			for (int j=0; j<min((int)frequencyRangeVec[i].size(),frequencyRangeDim[1]) ;j++) {
				frequencyRange[i*frequencyRangeDim[1]+j] = frequencyRangeVec[i][j].get();
			}
		}
		frequencyRangeDim[0] = maxDimZeroFrequencyRange;
		frequencyRangeDim[2] = frequencyRangeVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  polarizationTypes  attr.UpperCaseName: PolarizationTypes
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec = row->getPolarizationTypes();
		
		for (int i=0; i<min((int)polarizationTypesVec.size(),polarizationTypesDim[1]); i++)
			polarizationTypes[i] = polarizationTypesVec[i];
		polarizationTypesDim[0] = (int)polarizationTypesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  mainBeamEfficiency  attr.UpperCaseName: MainBeamEfficiency
		
		vector<double >  mainBeamEfficiencyVec = row->getMainBeamEfficiency();
		
		for (int i=0; i<min((int)mainBeamEfficiencyVec.size(),mainBeamEfficiencyDim[1]); i++)
			mainBeamEfficiency[i] = mainBeamEfficiencyVec[i];
		mainBeamEfficiencyDim[0] = (int)mainBeamEfficiencyVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  beamDescriptionUID  attr.UpperCaseName: BeamDescriptionUID
		strcpy(beamDescriptionUID,row->getBeamDescriptionUID().toString().c_str());
		//  attr.NameS:  relativeAmplitudeRms  attr.UpperCaseName: RelativeAmplitudeRms
		*relativeAmplitudeRms = row->getRelativeAmplitudeRms();
		//  attr.NameS:  direction  attr.UpperCaseName: Direction
		
		vector<Angle >  directionVec = row->getDirection();
		
		for (int i=0; i<min((int)directionVec.size(),directionDim[1]); i++)
			direction[i] = directionVec[i].get();
		directionDim[0] = directionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  minValidDirection  attr.UpperCaseName: MinValidDirection
		
		vector<Angle >  minValidDirectionVec = row->getMinValidDirection();
		
		for (int i=0; i<min((int)minValidDirectionVec.size(),minValidDirectionDim[1]); i++)
			minValidDirection[i] = minValidDirectionVec[i].get();
		minValidDirectionDim[0] = minValidDirectionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  maxValidDirection  attr.UpperCaseName: MaxValidDirection
		
		vector<Angle >  maxValidDirectionVec = row->getMaxValidDirection();
		
		for (int i=0; i<min((int)maxValidDirectionVec.size(),maxValidDirectionDim[1]); i++)
			maxValidDirection[i] = maxValidDirectionVec[i].get();
		maxValidDirectionDim[0] = maxValidDirectionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  descriptionType  attr.UpperCaseName: DescriptionType
		*descriptionType = row->getDescriptionType();
		//  attr.NameS:  imageChannelNumber  attr.UpperCaseName: ImageChannelNumber
		
		vector<int >  imageChannelNumberVec = row->getImageChannelNumber();
		
		for (int i=0; i<min((int)imageChannelNumberVec.size(),imageChannelNumberDim[1]); i++)
			imageChannelNumber[i] = imageChannelNumberVec[i];
		imageChannelNumberDim[0] = (int)imageChannelNumberVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  imageNominalFrequency  attr.UpperCaseName: ImageNominalFrequency
		
		vector<Frequency >  imageNominalFrequencyVec = row->getImageNominalFrequency();
		
		for (int i=0; i<min((int)imageNominalFrequencyVec.size(),imageNominalFrequencyDim[1]); i++)
			imageNominalFrequency[i] = imageNominalFrequencyVec[i].get();
		imageNominalFrequencyDim[0] = imageNominalFrequencyVec.size(); // return dimension of the ASDM table
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalPrimaryBeamTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalPrimaryBeamTable &table = dataset->getCalPrimaryBeam();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalPrimaryBeamKeys(char * antennaName, int * antennaNameDim, ReceiverBand * receiverBand, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalPrimaryBeamTable &table = dataset->getCalPrimaryBeam();
	
	vector< CalPrimaryBeamRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroAntennaName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getAntennaName().size() < antennaNameDim[1])
	  			strcpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str());
	  		else
	  			strncpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str(),antennaNameDim[1]);
	  		maxDimZeroAntennaName = max((int)row[i]->getAntennaName().size(), maxDimZeroAntennaName);
	  		receiverBand[i] = row[i]->getReceiverBand();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
antennaNameDim[0] = maxDimZeroAntennaName ;
antennaNameDim[2] = size ;
		return size;
  	}
}





using namespace InvalidatingConditionMod;


// =================== CalReductionTable ============================

extern "C" int sdm_addCalReductionRow (int * numApplied, char * appliedCalibrations, int * appliedCalibrationsDim, int * numParam, char * paramSet, int * paramSetDim, int * numInvalidConditions, InvalidatingCondition * invalidConditions, int * invalidConditionsDim, int64_t * timeReduced, char * messages, int * messagesDim, char * software, int * softwareDim, char * softwareVersion, int * softwareVersionDim);
extern "C" int sdm_getCalReductionRow (int * calReductionId, int * numApplied, char * appliedCalibrations, int * appliedCalibrationsDim, int * numParam, char * paramSet, int * paramSetDim, int * numInvalidConditions, InvalidatingCondition * invalidConditions, int * invalidConditionsDim, int64_t * timeReduced, char * messages, int * messagesDim, char * software, int * softwareDim, char * softwareVersion, int * softwareVersionDim);


extern "C" int sdm_getCalReductionTableSize ();

extern "C" int sdm_getCalReductionKeys (int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalReductionRow (int * numApplied, char * appliedCalibrations, int * appliedCalibrationsDim, int * numParam, char * paramSet, int * paramSetDim, int * numInvalidConditions, InvalidatingCondition * invalidConditions, int * invalidConditionsDim, int64_t * timeReduced, char * messages, int * messagesDim, char * software, int * softwareDim, char * softwareVersion, int * softwareVersionDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalReductionTable &table = dataset->getCalReduction();
	CalReductionRow *row = 0;

	// appliedCalibrations is an Array
	// appliedCalibrations is OneD
	vector<string >  appliedCalibrationsVec(appliedCalibrationsDim[2]);
	for (int i=0;i<appliedCalibrationsDim[2];i++)
		appliedCalibrationsVec[i]= string(appliedCalibrations+i*appliedCalibrationsDim[1]  );
	// paramSet is an Array
	// paramSet is OneD
	vector<string >  paramSetVec(paramSetDim[2]);
	for (int i=0;i<paramSetDim[2];i++)
		paramSetVec[i]= string(paramSet+i*paramSetDim[1]  );
	// invalidConditions is an Array
	// invalidConditions is OneD
	vector<InvalidatingConditionMod::InvalidatingCondition >  invalidConditionsVec(invalidConditionsDim[0]);
	for (int i=0;i<invalidConditionsDim[0];i++)
		invalidConditionsVec[i]= InvalidatingCondition(invalidConditions[i]   );
	
	// Create new row
  
	row = table.newRow(*numApplied, appliedCalibrationsVec, *numParam, paramSetVec, *numInvalidConditions, invalidConditionsVec, ArrayTime(*timeReduced), string(messages), string(software), string(softwareVersion));

	// Add row
	CalReductionRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalReductionTable" << endl;
	}
	
	// return atoi((retRow->getCalReductionId().getId()).c_str());
	return retRow->getCalReductionId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalReductionRow* given a key.
 */
int sdm_getCalReductionRow (int * calReductionId, int * numApplied, char * appliedCalibrations, int * appliedCalibrationsDim, int * numParam, char * paramSet, int * paramSetDim, int * numInvalidConditions, InvalidatingCondition * invalidConditions, int * invalidConditionsDim, int64_t * timeReduced, char * messages, int * messagesDim, char * software, int * softwareDim, char * softwareVersion, int * softwareVersionDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalReductionTable &table = dataset->getCalReduction();
	CalReductionRow *row = 0;
	row = table.getRowByKey( Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  numApplied  attr.UpperCaseName: NumApplied
		*numApplied = row->getNumApplied();
		//  attr.NameS:  appliedCalibrations  attr.UpperCaseName: AppliedCalibrations
		
		vector<string >  appliedCalibrationsVec = row->getAppliedCalibrations();
		
		int maxDimZeroAppliedCalibrations = 0;
		for (int i=0; i<min((int)appliedCalibrationsVec.size(),appliedCalibrationsDim[3]); i++) {
			if ((int)appliedCalibrationsVec[i].size()<appliedCalibrationsDim[1])
				strcpy(appliedCalibrations+i*appliedCalibrationsDim[1],appliedCalibrationsVec[i].c_str());
			else
				strncpy(appliedCalibrations+i*appliedCalibrationsDim[1],appliedCalibrationsVec[i].c_str(),appliedCalibrationsDim[1]);
			maxDimZeroAppliedCalibrations = max((int)appliedCalibrationsVec[i].size(),maxDimZeroAppliedCalibrations);
		}
		appliedCalibrationsDim[0] = maxDimZeroAppliedCalibrations;
		appliedCalibrationsDim[2] = appliedCalibrationsVec.size();  // number of strings
		
		
		//  attr.NameS:  numParam  attr.UpperCaseName: NumParam
		*numParam = row->getNumParam();
		//  attr.NameS:  paramSet  attr.UpperCaseName: ParamSet
		
		vector<string >  paramSetVec = row->getParamSet();
		
		int maxDimZeroParamSet = 0;
		for (int i=0; i<min((int)paramSetVec.size(),paramSetDim[3]); i++) {
			if ((int)paramSetVec[i].size()<paramSetDim[1])
				strcpy(paramSet+i*paramSetDim[1],paramSetVec[i].c_str());
			else
				strncpy(paramSet+i*paramSetDim[1],paramSetVec[i].c_str(),paramSetDim[1]);
			maxDimZeroParamSet = max((int)paramSetVec[i].size(),maxDimZeroParamSet);
		}
		paramSetDim[0] = maxDimZeroParamSet;
		paramSetDim[2] = paramSetVec.size();  // number of strings
		
		
		//  attr.NameS:  numInvalidConditions  attr.UpperCaseName: NumInvalidConditions
		*numInvalidConditions = row->getNumInvalidConditions();
		//  attr.NameS:  invalidConditions  attr.UpperCaseName: InvalidConditions
		
		vector<InvalidatingConditionMod::InvalidatingCondition >  invalidConditionsVec = row->getInvalidConditions();
		
		for (int i=0; i<min((int)invalidConditionsVec.size(),invalidConditionsDim[1]); i++)
			invalidConditions[i] = invalidConditionsVec[i];
		invalidConditionsDim[0] = (int)invalidConditionsVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  timeReduced  attr.UpperCaseName: TimeReduced
		*timeReduced     = row->getTimeReduced().get();
		//  attr.NameS:  messages  attr.UpperCaseName: Messages
		if ((int)row->getMessages().size()<messagesDim[1])
			strcpy(messages,row->getMessages().c_str());
		else
			strncpy(messages,row->getMessages().c_str(),messagesDim[1]);
		messagesDim[0] = (int)row->getMessages().size();
		//  attr.NameS:  software  attr.UpperCaseName: Software
		if ((int)row->getSoftware().size()<softwareDim[1])
			strcpy(software,row->getSoftware().c_str());
		else
			strncpy(software,row->getSoftware().c_str(),softwareDim[1]);
		softwareDim[0] = (int)row->getSoftware().size();
		//  attr.NameS:  softwareVersion  attr.UpperCaseName: SoftwareVersion
		if ((int)row->getSoftwareVersion().size()<softwareVersionDim[1])
			strcpy(softwareVersion,row->getSoftwareVersion().c_str());
		else
			strncpy(softwareVersion,row->getSoftwareVersion().c_str(),softwareVersionDim[1]);
		softwareVersionDim[0] = (int)row->getSoftwareVersion().size();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalReductionTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalReductionTable &table = dataset->getCalReduction();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalReductionKeys(int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalReductionTable &table = dataset->getCalReduction();
	
	vector< CalReductionRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
		return size;
  	}
}





using namespace AtmPhaseCorrectionMod;


// =================== CalSeeingTable ============================

extern "C" int sdm_addCalSeeingRow (AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, int64_t * integrationTime, int * numBaseLengths, double * baselineLengths, int * baselineLengthsDim, double * phaseRMS, int * phaseRMSDim, double * seeing, double * seeingError);
extern "C" int sdm_getCalSeeingRow (AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, int64_t * integrationTime, int * numBaseLengths, double * baselineLengths, int * baselineLengthsDim, double * phaseRMS, int * phaseRMSDim, double * seeing, double * seeingError);


extern "C" int sdm_getCalSeeingTableSize ();

extern "C" int sdm_getCalSeeingKeys (AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalSeeingRow (AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, int64_t * integrationTime, int * numBaseLengths, double * baselineLengths, int * baselineLengthsDim, double * phaseRMS, int * phaseRMSDim, double * seeing, double * seeingError){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalSeeingTable &table = dataset->getCalSeeing();
	CalSeeingRow *row = 0;

	// atmPhaseCorrection is an enumeration
	// AtmPhaseCorrection * atmPhaseCorrection =  (int) atmPhaseCorrection;
	// frequencyRange is an Array
	// frequencyRange is OneD
	vector<Frequency >  frequencyRangeVec(frequencyRangeDim[0]);
	for (int i=0;i<frequencyRangeDim[0];i++)
		frequencyRangeVec[i]= Frequency(frequencyRange[i]   );
	// baselineLengths is an Array
	// baselineLengths is OneD
	vector<Length >  baselineLengthsVec(baselineLengthsDim[0]);
	for (int i=0;i<baselineLengthsDim[0];i++)
		baselineLengthsVec[i]= Length(baselineLengths[i]   );
	// phaseRMS is an Array
	// phaseRMS is OneD
	vector<Angle >  phaseRMSVec(phaseRMSDim[0]);
	for (int i=0;i<phaseRMSDim[0];i++)
		phaseRMSVec[i]= Angle(phaseRMS[i]   );
	
	// Create new row
  
	row = table.newRow(*atmPhaseCorrection, Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), frequencyRangeVec, Interval(*integrationTime), *numBaseLengths, baselineLengthsVec, phaseRMSVec, Angle(*seeing), Angle(*seeingError));

	// Add row
	CalSeeingRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalSeeingTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalSeeingRow* given a key.
 */
int sdm_getCalSeeingRow (AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, double * frequencyRange, int * frequencyRangeDim, int64_t * integrationTime, int * numBaseLengths, double * baselineLengths, int * baselineLengthsDim, double * phaseRMS, int * phaseRMSDim, double * seeing, double * seeingError) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalSeeingTable &table = dataset->getCalSeeing();
	CalSeeingRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  atmPhaseCorrection  attr.UpperCaseName: AtmPhaseCorrection
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  frequencyRange  attr.UpperCaseName: FrequencyRange
		
		vector<Frequency >  frequencyRangeVec = row->getFrequencyRange();
		
		for (int i=0; i<min((int)frequencyRangeVec.size(),frequencyRangeDim[1]); i++)
			frequencyRange[i] = frequencyRangeVec[i].get();
		frequencyRangeDim[0] = frequencyRangeVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  integrationTime  attr.UpperCaseName: IntegrationTime
		*integrationTime = row->getIntegrationTime().get();
		//  attr.NameS:  numBaseLengths  attr.UpperCaseName: NumBaseLengths
		*numBaseLengths = row->getNumBaseLengths();
		//  attr.NameS:  baselineLengths  attr.UpperCaseName: BaselineLengths
		
		vector<Length >  baselineLengthsVec = row->getBaselineLengths();
		
		for (int i=0; i<min((int)baselineLengthsVec.size(),baselineLengthsDim[1]); i++)
			baselineLengths[i] = baselineLengthsVec[i].get();
		baselineLengthsDim[0] = baselineLengthsVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  phaseRMS  attr.UpperCaseName: PhaseRMS
		
		vector<Angle >  phaseRMSVec = row->getPhaseRMS();
		
		for (int i=0; i<min((int)phaseRMSVec.size(),phaseRMSDim[1]); i++)
			phaseRMS[i] = phaseRMSVec[i].get();
		phaseRMSDim[0] = phaseRMSVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  seeing  attr.UpperCaseName: Seeing
		*seeing = row->getSeeing().get();
		//  attr.NameS:  seeingError  attr.UpperCaseName: SeeingError
		*seeingError = row->getSeeingError().get();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalSeeingTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalSeeingTable &table = dataset->getCalSeeing();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalSeeingKeys(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalSeeingTable &table = dataset->getCalSeeing();
	
	vector< CalSeeingRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		atmPhaseCorrection[i] = row[i]->getAtmPhaseCorrection();
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter exponent, in a row of the CalSeeing table, given a key
 *
 */

#define sdm_addCalSeeingExponent  sdm_addcalseeingexponent_
extern "C" int sdm_addCalSeeingExponent(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, float * exponent);

int sdm_addCalSeeingExponent(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, float * exponent) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalSeeingTable &table = dataset->getCalSeeing();
	
	CalSeeingRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setExponent(float(* exponent ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter exponent, in a row of the CalSeeing table, given a key
 *
 */

#define sdm_getCalSeeingExponent  sdm_getcalseeingexponent_
extern "C" int sdm_getCalSeeingExponent(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, float * exponent);

int sdm_getCalSeeingExponent(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, float * exponent) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalSeeingTable &table = dataset->getCalSeeing();
	CalSeeingRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isExponentExists()) {
			*exponent = row->getExponent();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter outerScale, in a row of the CalSeeing table, given a key
 *
 */

#define sdm_addCalSeeingOuterScale  sdm_addcalseeingouterscale_
extern "C" int sdm_addCalSeeingOuterScale(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * outerScale);

int sdm_addCalSeeingOuterScale(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * outerScale) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalSeeingTable &table = dataset->getCalSeeing();
	
	CalSeeingRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setOuterScale(Length(* outerScale ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter outerScale, in a row of the CalSeeing table, given a key
 *
 */

#define sdm_getCalSeeingOuterScale  sdm_getcalseeingouterscale_
extern "C" int sdm_getCalSeeingOuterScale(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * outerScale);

int sdm_getCalSeeingOuterScale(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * outerScale) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalSeeingTable &table = dataset->getCalSeeing();
	CalSeeingRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isOuterScaleExists()) {
			*outerScale = row->getOuterScale().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter outerScaleRMS, in a row of the CalSeeing table, given a key
 *
 */

#define sdm_addCalSeeingOuterScaleRMS  sdm_addcalseeingouterscalerms_
extern "C" int sdm_addCalSeeingOuterScaleRMS(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * outerScaleRMS);

int sdm_addCalSeeingOuterScaleRMS(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * outerScaleRMS) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalSeeingTable &table = dataset->getCalSeeing();
	
	CalSeeingRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setOuterScaleRMS(Angle(* outerScaleRMS ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter outerScaleRMS, in a row of the CalSeeing table, given a key
 *
 */

#define sdm_getCalSeeingOuterScaleRMS  sdm_getcalseeingouterscalerms_
extern "C" int sdm_getCalSeeingOuterScaleRMS(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * outerScaleRMS);

int sdm_getCalSeeingOuterScaleRMS(AtmPhaseCorrection * atmPhaseCorrection, int * calDataId, int * calReductionId, double * outerScaleRMS) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	CalSeeingTable &table = dataset->getCalSeeing();
	CalSeeingRow *row = 0;
	row = table.getRowByKey( *atmPhaseCorrection, Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isOuterScaleRMSExists()) {
			*outerScaleRMS = row->getOuterScaleRMS().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace WVRMethodMod;


// =================== CalWVRTable ============================

extern "C" int sdm_addCalWVRRow (char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, WVRMethod * wvrMethod, int * numInputAntennas, char * inputAntennaNames, int * inputAntennaNamesDim, int * numChan, double * chanFreq, int * chanFreqDim, double * chanWidth, int * chanWidthDim, double * refTemp, int * refTempDim, int * numPoly, float * pathCoeff, int * pathCoeffDim, double * polyFreqLimits, int * polyFreqLimitsDim, float * wetPath, int * wetPathDim, float * dryPath, int * dryPathDim, double * water);
extern "C" int sdm_getCalWVRRow (char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, WVRMethod * wvrMethod, int * numInputAntennas, char * inputAntennaNames, int * inputAntennaNamesDim, int * numChan, double * chanFreq, int * chanFreqDim, double * chanWidth, int * chanWidthDim, double * refTemp, int * refTempDim, int * numPoly, float * pathCoeff, int * pathCoeffDim, double * polyFreqLimits, int * polyFreqLimitsDim, float * wetPath, int * wetPathDim, float * dryPath, int * dryPathDim, double * water);


extern "C" int sdm_getCalWVRTableSize ();

extern "C" int sdm_getCalWVRKeys (char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCalWVRRow (char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, WVRMethod * wvrMethod, int * numInputAntennas, char * inputAntennaNames, int * inputAntennaNamesDim, int * numChan, double * chanFreq, int * chanFreqDim, double * chanWidth, int * chanWidthDim, double * refTemp, int * refTempDim, int * numPoly, float * pathCoeff, int * pathCoeffDim, double * polyFreqLimits, int * polyFreqLimitsDim, float * wetPath, int * wetPathDim, float * dryPath, int * dryPathDim, double * water){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CalWVRTable &table = dataset->getCalWVR();
	CalWVRRow *row = 0;

	// wvrMethod is an enumeration
	// WVRMethod * wvrMethod =  (int) wvrMethod;
	// inputAntennaNames is an Array
	// inputAntennaNames is OneD
	vector<string >  inputAntennaNamesVec(inputAntennaNamesDim[2]);
	for (int i=0;i<inputAntennaNamesDim[2];i++)
		inputAntennaNamesVec[i]= string(inputAntennaNames+i*inputAntennaNamesDim[1]  );
	// chanFreq is an Array
	// chanFreq is OneD
	vector<Frequency >  chanFreqVec(chanFreqDim[0]);
	for (int i=0;i<chanFreqDim[0];i++)
		chanFreqVec[i]= Frequency(chanFreq[i]   );
	// chanWidth is an Array
	// chanWidth is OneD
	vector<Frequency >  chanWidthVec(chanWidthDim[0]);
	for (int i=0;i<chanWidthDim[0];i++)
		chanWidthVec[i]= Frequency(chanWidth[i]   );
	// refTemp is an Array
	// refTemp is 2 D
	vector<vector<Temperature > >  refTempVec(refTempDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<refTempDim[2];i++) {
		refTempVec[i].resize(refTempDim[0]);
		for (int j=0;j<refTempDim[0];j++)
			refTempVec[i][j]= Temperature(refTemp[i*refTempDim[1]+j]  );
	
	
	}
	// pathCoeff is an Array
	// pathCoeff is 3 D
	vector<vector<vector<float > > >  pathCoeffVec(pathCoeffDim[4]);   // Inversion of dim in fortran/C
	for (int i=0;i<pathCoeffDim[4];i++) {
		pathCoeffVec[i].resize(pathCoeffDim[2]);
		for (int j=0;j<pathCoeffDim[2];j++) {
			pathCoeffVec[i][j].resize(pathCoeffDim[0]);
			for (int k=0;k<pathCoeffDim[0];k++)
		    pathCoeffVec[i][j][k]= float(pathCoeff[(i*pathCoeffDim[3]+j)*pathCoeffDim[1]+k] );
		}
	}
	// polyFreqLimits is an Array
	// polyFreqLimits is OneD
	vector<Frequency >  polyFreqLimitsVec(polyFreqLimitsDim[0]);
	for (int i=0;i<polyFreqLimitsDim[0];i++)
		polyFreqLimitsVec[i]= Frequency(polyFreqLimits[i]   );
	// wetPath is an Array
	// wetPath is OneD
	vector<float >  wetPathVec(wetPathDim[0]);
	for (int i=0;i<wetPathDim[0];i++)
		wetPathVec[i]= float(wetPath[i]   );
	// dryPath is an Array
	// dryPath is OneD
	vector<float >  dryPathVec(dryPathDim[0]);
	for (int i=0;i<dryPathDim[0];i++)
		dryPathVec[i]= float(dryPath[i]   );
	
	// Create new row
  
	row = table.newRow(string(antennaName), Tag(*calDataId,TagType::CalData), Tag(*calReductionId,TagType::CalReduction), ArrayTime(*startValidTime), ArrayTime(*endValidTime), *wvrMethod, *numInputAntennas, inputAntennaNamesVec, *numChan, chanFreqVec, chanWidthVec, refTempVec, *numPoly, pathCoeffVec, polyFreqLimitsVec, wetPathVec, dryPathVec, Length(*water));

	// Add row
	CalWVRRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CalWVRTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CalWVRRow* given a key.
 */
int sdm_getCalWVRRow (char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId, int64_t * startValidTime, int64_t * endValidTime, WVRMethod * wvrMethod, int * numInputAntennas, char * inputAntennaNames, int * inputAntennaNamesDim, int * numChan, double * chanFreq, int * chanFreqDim, double * chanWidth, int * chanWidthDim, double * refTemp, int * refTempDim, int * numPoly, float * pathCoeff, int * pathCoeffDim, double * polyFreqLimits, int * polyFreqLimitsDim, float * wetPath, int * wetPathDim, float * dryPath, int * dryPathDim, double * water) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CalWVRTable &table = dataset->getCalWVR();
	CalWVRRow *row = 0;
	row = table.getRowByKey( string(antennaName), Tag(*calDataId, TagType::CalData), Tag(*calReductionId, TagType::CalReduction));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaName  attr.UpperCaseName: AntennaName
		//  attr.NameS:  calDataId  attr.UpperCaseName: CalDataId
		//  attr.NameS:  calReductionId  attr.UpperCaseName: CalReductionId
		//  attr.NameS:  startValidTime  attr.UpperCaseName: StartValidTime
		*startValidTime     = row->getStartValidTime().get();
		//  attr.NameS:  endValidTime  attr.UpperCaseName: EndValidTime
		*endValidTime     = row->getEndValidTime().get();
		//  attr.NameS:  wvrMethod  attr.UpperCaseName: WvrMethod
		*wvrMethod = row->getWvrMethod();
		//  attr.NameS:  numInputAntennas  attr.UpperCaseName: NumInputAntennas
		*numInputAntennas = row->getNumInputAntennas();
		//  attr.NameS:  inputAntennaNames  attr.UpperCaseName: InputAntennaNames
		
		vector<string >  inputAntennaNamesVec = row->getInputAntennaNames();
		
		int maxDimZeroInputAntennaNames = 0;
		for (int i=0; i<min((int)inputAntennaNamesVec.size(),inputAntennaNamesDim[3]); i++) {
			if ((int)inputAntennaNamesVec[i].size()<inputAntennaNamesDim[1])
				strcpy(inputAntennaNames+i*inputAntennaNamesDim[1],inputAntennaNamesVec[i].c_str());
			else
				strncpy(inputAntennaNames+i*inputAntennaNamesDim[1],inputAntennaNamesVec[i].c_str(),inputAntennaNamesDim[1]);
			maxDimZeroInputAntennaNames = max((int)inputAntennaNamesVec[i].size(),maxDimZeroInputAntennaNames);
		}
		inputAntennaNamesDim[0] = maxDimZeroInputAntennaNames;
		inputAntennaNamesDim[2] = inputAntennaNamesVec.size();  // number of strings
		
		
		//  attr.NameS:  numChan  attr.UpperCaseName: NumChan
		*numChan = row->getNumChan();
		//  attr.NameS:  chanFreq  attr.UpperCaseName: ChanFreq
		
		vector<Frequency >  chanFreqVec = row->getChanFreq();
		
		for (int i=0; i<min((int)chanFreqVec.size(),chanFreqDim[1]); i++)
			chanFreq[i] = chanFreqVec[i].get();
		chanFreqDim[0] = chanFreqVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  chanWidth  attr.UpperCaseName: ChanWidth
		
		vector<Frequency >  chanWidthVec = row->getChanWidth();
		
		for (int i=0; i<min((int)chanWidthVec.size(),chanWidthDim[1]); i++)
			chanWidth[i] = chanWidthVec[i].get();
		chanWidthDim[0] = chanWidthVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  refTemp  attr.UpperCaseName: RefTemp
		
		vector<vector<Temperature > >  refTempVec = row->getRefTemp();
		
		int maxDimZeroRefTemp = 0;
		for (int i=0; i< min((int)refTempVec.size(),refTempDim[3]) ;i++) {
			maxDimZeroRefTemp = max((int)refTempVec[i].size(),maxDimZeroRefTemp);
			for (int j=0; j<min((int)refTempVec[i].size(),refTempDim[1]) ;j++) {
				refTemp[i*refTempDim[1]+j] = refTempVec[i][j].get();
			}
		}
		refTempDim[0] = maxDimZeroRefTemp;
		refTempDim[2] = refTempVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  numPoly  attr.UpperCaseName: NumPoly
		*numPoly = row->getNumPoly();
		//  attr.NameS:  pathCoeff  attr.UpperCaseName: PathCoeff
		
		vector<vector<vector<float > > >  pathCoeffVec = row->getPathCoeff();
		int maxDimTwoPathCoeff = 0;
		int maxDimZeroPathCoeff = 0;
		for (int i=0; i<  min((int)pathCoeffVec.size(),pathCoeffDim[5]) ;i++) {
			maxDimTwoPathCoeff = max((int)pathCoeffVec[i].size(),maxDimTwoPathCoeff);
			for (int j=0;j< min((int)pathCoeffVec[i].size(),pathCoeffDim[3]) ;j++) {
				maxDimZeroPathCoeff = max((int)pathCoeffVec[i][j].size(),maxDimZeroPathCoeff);
				for (int k=0; k< min((int)pathCoeffVec[i][j].size(),pathCoeffDim[1]) ;k++) {
pathCoeff[(i*pathCoeffDim[3]+j)*pathCoeffDim[1]+k]= pathCoeffVec[i][j][k];
				}
			}
		}
		pathCoeffDim[0] = maxDimZeroPathCoeff;
		pathCoeffDim[2] = maxDimTwoPathCoeff;
		pathCoeffDim[4] = pathCoeffVec.size();  // return dimension of the ASDM table
		//  attr.NameS:  polyFreqLimits  attr.UpperCaseName: PolyFreqLimits
		
		vector<Frequency >  polyFreqLimitsVec = row->getPolyFreqLimits();
		
		for (int i=0; i<min((int)polyFreqLimitsVec.size(),polyFreqLimitsDim[1]); i++)
			polyFreqLimits[i] = polyFreqLimitsVec[i].get();
		polyFreqLimitsDim[0] = polyFreqLimitsVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  wetPath  attr.UpperCaseName: WetPath
		
		vector<float >  wetPathVec = row->getWetPath();
		
		for (int i=0; i<min((int)wetPathVec.size(),wetPathDim[1]); i++)
			wetPath[i] = wetPathVec[i];
		wetPathDim[0] = (int)wetPathVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  dryPath  attr.UpperCaseName: DryPath
		
		vector<float >  dryPathVec = row->getDryPath();
		
		for (int i=0; i<min((int)dryPathVec.size(),dryPathDim[1]); i++)
			dryPath[i] = dryPathVec[i];
		dryPathDim[0] = (int)dryPathVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  water  attr.UpperCaseName: Water
		*water = row->getWater().get();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCalWVRTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CalWVRTable &table = dataset->getCalWVR();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCalWVRKeys(char * antennaName, int * antennaNameDim, int * calDataId, int * calReductionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CalWVRTable &table = dataset->getCalWVR();
	
	vector< CalWVRRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
		int maxDimZeroAntennaName = 0;
  		for (int i=0;i<size;i++) {
	  		if ((int) row[i]->getAntennaName().size() < antennaNameDim[1])
	  			strcpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str());
	  		else
	  			strncpy(antennaName+i*antennaNameDim[1],row[i]->getAntennaName().c_str(),antennaNameDim[1]);
	  		maxDimZeroAntennaName = max((int)row[i]->getAntennaName().size(), maxDimZeroAntennaName);
	  		// calDataId[i] = atoi((row[i]->getCalDataId().getId()).c_str());
				calDataId[i] = row[i]->getCalDataId().getTagValue();
	  		// calReductionId[i] = atoi((row[i]->getCalReductionId().getId()).c_str());
				calReductionId[i] = row[i]->getCalReductionId().getTagValue();
  		}
  		
antennaNameDim[0] = maxDimZeroAntennaName ;
antennaNameDim[2] = size ;
		return size;
  	}
}





using namespace CorrelationModeMod;
using namespace AtmPhaseCorrectionMod;
using namespace ProcessorTypeMod;
using namespace SpectralResolutionTypeMod;
using namespace SpectralResolutionTypeMod;


// =================== ConfigDescriptionTable ============================

extern "C" int sdm_addConfigDescriptionRow (int * numAntenna, int * numDataDescription, int * numFeed, CorrelationMode * correlationMode, int * numAtmPhaseCorrection, AtmPhaseCorrection * atmPhaseCorrection, int * atmPhaseCorrectionDim, ProcessorType * processorType, SpectralResolutionType * spectralType, int * antennaId, int * antennaIdDim, int * feedId, int * feedIdDim, int * switchCycleId, int * switchCycleIdDim, int * dataDescriptionId, int * dataDescriptionIdDim, int * processorId);
extern "C" int sdm_getConfigDescriptionRow (int * configDescriptionId, int * numAntenna, int * numDataDescription, int * numFeed, CorrelationMode * correlationMode, int * numAtmPhaseCorrection, AtmPhaseCorrection * atmPhaseCorrection, int * atmPhaseCorrectionDim, ProcessorType * processorType, SpectralResolutionType * spectralType, int * antennaId, int * antennaIdDim, int * feedId, int * feedIdDim, int * switchCycleId, int * switchCycleIdDim, int * dataDescriptionId, int * dataDescriptionIdDim, int * processorId);


extern "C" int sdm_getConfigDescriptionTableSize ();

extern "C" int sdm_getConfigDescriptionKeys (int * configDescriptionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addConfigDescriptionRow (int * numAntenna, int * numDataDescription, int * numFeed, CorrelationMode * correlationMode, int * numAtmPhaseCorrection, AtmPhaseCorrection * atmPhaseCorrection, int * atmPhaseCorrectionDim, ProcessorType * processorType, SpectralResolutionType * spectralType, int * antennaId, int * antennaIdDim, int * feedId, int * feedIdDim, int * switchCycleId, int * switchCycleIdDim, int * dataDescriptionId, int * dataDescriptionIdDim, int * processorId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	ConfigDescriptionTable &table = dataset->getConfigDescription();
	ConfigDescriptionRow *row = 0;

	// correlationMode is an enumeration
	// CorrelationMode * correlationMode =  (int) correlationMode;
	// atmPhaseCorrection is an Array
	// atmPhaseCorrection is OneD
	vector<AtmPhaseCorrectionMod::AtmPhaseCorrection >  atmPhaseCorrectionVec(atmPhaseCorrectionDim[0]);
	for (int i=0;i<atmPhaseCorrectionDim[0];i++)
		atmPhaseCorrectionVec[i]= AtmPhaseCorrection(atmPhaseCorrection[i]   );
	// processorType is an enumeration
	// ProcessorType * processorType =  (int) processorType;
	// spectralType is an enumeration
	// SpectralResolutionType * spectralType =  (int) spectralType;
	// antennaId is an Array
	// antennaId is OneD
	vector<Tag>   antennaIdVec(antennaIdDim[0]);
	for (int i=0;i<antennaIdDim[0];i++)
		antennaIdVec[i]= Tag(antennaId[i]   , TagType::Antenna);
	// feedId is an Array
	// feedId is OneD
	vector<int>   feedIdVec(feedIdDim[0]);
	for (int i=0;i<feedIdDim[0];i++)
		feedIdVec[i]= int(feedId[i]   );
	// switchCycleId is an Array
	// switchCycleId is OneD
	vector<Tag>   switchCycleIdVec(switchCycleIdDim[0]);
	for (int i=0;i<switchCycleIdDim[0];i++)
		switchCycleIdVec[i]= Tag(switchCycleId[i]   , TagType::SwitchCycle);
	// dataDescriptionId is an Array
	// dataDescriptionId is OneD
	vector<Tag>   dataDescriptionIdVec(dataDescriptionIdDim[0]);
	for (int i=0;i<dataDescriptionIdDim[0];i++)
		dataDescriptionIdVec[i]= Tag(dataDescriptionId[i]   , TagType::DataDescription);
	
	// Create new row
  
	row = table.newRow(*numAntenna, *numDataDescription, *numFeed, *correlationMode, *numAtmPhaseCorrection, atmPhaseCorrectionVec, *processorType, *spectralType, antennaIdVec, feedIdVec, switchCycleIdVec, dataDescriptionIdVec, Tag(*processorId,TagType::Processor));

	// Add row
	ConfigDescriptionRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the ConfigDescriptionTable" << endl;
	}
	
	// return atoi((retRow->getConfigDescriptionId().getId()).c_str());
	return retRow->getConfigDescriptionId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a ConfigDescriptionRow* given a key.
 */
int sdm_getConfigDescriptionRow (int * configDescriptionId, int * numAntenna, int * numDataDescription, int * numFeed, CorrelationMode * correlationMode, int * numAtmPhaseCorrection, AtmPhaseCorrection * atmPhaseCorrection, int * atmPhaseCorrectionDim, ProcessorType * processorType, SpectralResolutionType * spectralType, int * antennaId, int * antennaIdDim, int * feedId, int * feedIdDim, int * switchCycleId, int * switchCycleIdDim, int * dataDescriptionId, int * dataDescriptionIdDim, int * processorId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ConfigDescriptionTable &table = dataset->getConfigDescription();
	ConfigDescriptionRow *row = 0;
	row = table.getRowByKey( Tag(*configDescriptionId, TagType::ConfigDescription));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  configDescriptionId  attr.UpperCaseName: ConfigDescriptionId
		//  attr.NameS:  numAntenna  attr.UpperCaseName: NumAntenna
		*numAntenna = row->getNumAntenna();
		//  attr.NameS:  numDataDescription  attr.UpperCaseName: NumDataDescription
		*numDataDescription = row->getNumDataDescription();
		//  attr.NameS:  numFeed  attr.UpperCaseName: NumFeed
		*numFeed = row->getNumFeed();
		//  attr.NameS:  correlationMode  attr.UpperCaseName: CorrelationMode
		*correlationMode = row->getCorrelationMode();
		//  attr.NameS:  numAtmPhaseCorrection  attr.UpperCaseName: NumAtmPhaseCorrection
		*numAtmPhaseCorrection = row->getNumAtmPhaseCorrection();
		//  attr.NameS:  atmPhaseCorrection  attr.UpperCaseName: AtmPhaseCorrection
		
		vector<AtmPhaseCorrectionMod::AtmPhaseCorrection >  atmPhaseCorrectionVec = row->getAtmPhaseCorrection();
		
		for (int i=0; i<min((int)atmPhaseCorrectionVec.size(),atmPhaseCorrectionDim[1]); i++)
			atmPhaseCorrection[i] = atmPhaseCorrectionVec[i];
		atmPhaseCorrectionDim[0] = (int)atmPhaseCorrectionVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  processorType  attr.UpperCaseName: ProcessorType
		*processorType = row->getProcessorType();
		//  attr.NameS:  spectralType  attr.UpperCaseName: SpectralType
		*spectralType = row->getSpectralType();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		
		vector<Tag>   antennaIdVec = row->getAntennaId();
		
		for (int i=0; i<min((int)antennaIdVec.size(),antennaIdDim[1]); i++)
			//antennaId[i] = atoi((row->getAntennaId()[i]).getId().c_str());
		antennaId[i] = antennaIdVec[i].getTagValue();
		antennaIdDim[0] = (int)antennaIdVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  feedId  attr.UpperCaseName: FeedId
		
		vector<int>   feedIdVec = row->getFeedId();
		
		for (int i=0; i<min((int)feedIdVec.size(),feedIdDim[1]); i++)
			feedId[i] = feedIdVec[i];
		feedIdDim[0] = (int)feedIdVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  switchCycleId  attr.UpperCaseName: SwitchCycleId
		
		vector<Tag>   switchCycleIdVec = row->getSwitchCycleId();
		
		for (int i=0; i<min((int)switchCycleIdVec.size(),switchCycleIdDim[1]); i++)
			//switchCycleId[i] = atoi((row->getSwitchCycleId()[i]).getId().c_str());
		switchCycleId[i] = switchCycleIdVec[i].getTagValue();
		switchCycleIdDim[0] = (int)switchCycleIdVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  dataDescriptionId  attr.UpperCaseName: DataDescriptionId
		
		vector<Tag>   dataDescriptionIdVec = row->getDataDescriptionId();
		
		for (int i=0; i<min((int)dataDescriptionIdVec.size(),dataDescriptionIdDim[1]); i++)
			//dataDescriptionId[i] = atoi((row->getDataDescriptionId()[i]).getId().c_str());
		dataDescriptionId[i] = dataDescriptionIdVec[i].getTagValue();
		dataDescriptionIdDim[0] = (int)dataDescriptionIdVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  processorId  attr.UpperCaseName: ProcessorId
		// *processorId = atoi((row->getProcessorId().getId()).c_str());
		*processorId = row->getProcessorId().getTagValue();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getConfigDescriptionTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
ConfigDescriptionTable &table = dataset->getConfigDescription();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getConfigDescriptionKeys(int * configDescriptionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	ConfigDescriptionTable &table = dataset->getConfigDescription();
	
	vector< ConfigDescriptionRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// configDescriptionId[i] = atoi((row[i]->getConfigDescriptionId().getId()).c_str());
				configDescriptionId[i] = row[i]->getConfigDescriptionId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter phasedArrayList, in a row of the ConfigDescription table, given a key
 *
 */

#define sdm_addConfigDescriptionPhasedArrayList  sdm_addconfigdescriptionphasedarraylist_
extern "C" int sdm_addConfigDescriptionPhasedArrayList(int * configDescriptionId, int * phasedArrayList, int * phasedArrayListDim);

int sdm_addConfigDescriptionPhasedArrayList(int * configDescriptionId, int * phasedArrayList, int * phasedArrayListDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ConfigDescriptionTable &table = dataset->getConfigDescription();
	
	ConfigDescriptionRow *row = 0;
	row = table.getRowByKey( Tag(*configDescriptionId, TagType::ConfigDescription));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<int >  phasedArrayListVec(phasedArrayListDim[0]);
		for (int i=0;i<phasedArrayListDim[0];i++)
			phasedArrayListVec[i]= int(phasedArrayList[i] );
		row->setPhasedArrayList(phasedArrayListVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter phasedArrayList, in a row of the ConfigDescription table, given a key
 *
 */

#define sdm_getConfigDescriptionPhasedArrayList  sdm_getconfigdescriptionphasedarraylist_
extern "C" int sdm_getConfigDescriptionPhasedArrayList(int * configDescriptionId, int * phasedArrayList, int * phasedArrayListDim);

int sdm_getConfigDescriptionPhasedArrayList(int * configDescriptionId, int * phasedArrayList, int * phasedArrayListDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ConfigDescriptionTable &table = dataset->getConfigDescription();
	ConfigDescriptionRow *row = 0;
	row = table.getRowByKey( Tag(*configDescriptionId, TagType::ConfigDescription));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPhasedArrayListExists()) {
			// attr.CppType: vector<int > attr.isOneD: true
			for (int i=0; i<min((int)row->getPhasedArrayList().size(),phasedArrayListDim[1]); i++)
				phasedArrayList[i] = row->getPhasedArrayList()[i];
			phasedArrayListDim[0] = (int)row->getPhasedArrayList().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numAssocValues, in a row of the ConfigDescription table, given a key
 *
 */

#define sdm_addConfigDescriptionNumAssocValues  sdm_addconfigdescriptionnumassocvalues_
extern "C" int sdm_addConfigDescriptionNumAssocValues(int * configDescriptionId, int * numAssocValues);

int sdm_addConfigDescriptionNumAssocValues(int * configDescriptionId, int * numAssocValues) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ConfigDescriptionTable &table = dataset->getConfigDescription();
	
	ConfigDescriptionRow *row = 0;
	row = table.getRowByKey( Tag(*configDescriptionId, TagType::ConfigDescription));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumAssocValues(int(* numAssocValues ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numAssocValues, in a row of the ConfigDescription table, given a key
 *
 */

#define sdm_getConfigDescriptionNumAssocValues  sdm_getconfigdescriptionnumassocvalues_
extern "C" int sdm_getConfigDescriptionNumAssocValues(int * configDescriptionId, int * numAssocValues);

int sdm_getConfigDescriptionNumAssocValues(int * configDescriptionId, int * numAssocValues) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ConfigDescriptionTable &table = dataset->getConfigDescription();
	ConfigDescriptionRow *row = 0;
	row = table.getRowByKey( Tag(*configDescriptionId, TagType::ConfigDescription));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumAssocValuesExists()) {
			*numAssocValues = row->getNumAssocValues();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter assocNature, in a row of the ConfigDescription table, given a key
 *
 */

#define sdm_addConfigDescriptionAssocNature  sdm_addconfigdescriptionassocnature_
extern "C" int sdm_addConfigDescriptionAssocNature(int * configDescriptionId, SpectralResolutionType * assocNature, int * assocNatureDim);

int sdm_addConfigDescriptionAssocNature(int * configDescriptionId, SpectralResolutionType * assocNature, int * assocNatureDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ConfigDescriptionTable &table = dataset->getConfigDescription();
	
	ConfigDescriptionRow *row = 0;
	row = table.getRowByKey( Tag(*configDescriptionId, TagType::ConfigDescription));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<SpectralResolutionTypeMod::SpectralResolutionType >  assocNatureVec(assocNatureDim[0]);
		for (int i=0;i<assocNatureDim[0];i++)
			assocNatureVec[i]= SpectralResolutionType(assocNature[i] );
		row->setAssocNature(assocNatureVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter assocNature, in a row of the ConfigDescription table, given a key
 *
 */

#define sdm_getConfigDescriptionAssocNature  sdm_getconfigdescriptionassocnature_
extern "C" int sdm_getConfigDescriptionAssocNature(int * configDescriptionId, SpectralResolutionType * assocNature, int * assocNatureDim);

int sdm_getConfigDescriptionAssocNature(int * configDescriptionId, SpectralResolutionType * assocNature, int * assocNatureDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ConfigDescriptionTable &table = dataset->getConfigDescription();
	ConfigDescriptionRow *row = 0;
	row = table.getRowByKey( Tag(*configDescriptionId, TagType::ConfigDescription));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAssocNatureExists()) {
			// attr.CppType: vector<SpectralResolutionTypeMod::SpectralResolutionType > attr.isOneD: true
			for (int i=0; i<min((int)row->getAssocNature().size(),assocNatureDim[1]); i++)
				assocNature[i] = row->getAssocNature()[i];
			assocNatureDim[0] = (int)row->getAssocNature().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter assocConfigDescriptionId, in a row of the ConfigDescription table, given a key
 *
 */

#define sdm_addConfigDescriptionAssocConfigDescriptionId  sdm_addconfigdescriptionassocconfigdescriptionid_
extern "C" int sdm_addConfigDescriptionAssocConfigDescriptionId(int * configDescriptionId, int * assocConfigDescriptionId, int * assocConfigDescriptionIdDim);

int sdm_addConfigDescriptionAssocConfigDescriptionId(int * configDescriptionId, int * assocConfigDescriptionId, int * assocConfigDescriptionIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ConfigDescriptionTable &table = dataset->getConfigDescription();
	
	ConfigDescriptionRow *row = 0;
	row = table.getRowByKey( Tag(*configDescriptionId, TagType::ConfigDescription));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Tag>   assocConfigDescriptionIdVec(assocConfigDescriptionIdDim[0]);
		for (int i=0;i<assocConfigDescriptionIdDim[0];i++)
			assocConfigDescriptionIdVec[i]= Tag(assocConfigDescriptionId[i] , TagType::ConfigDescription);
		row->setAssocConfigDescriptionId(assocConfigDescriptionIdVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter assocConfigDescriptionId, in a row of the ConfigDescription table, given a key
 *
 */

#define sdm_getConfigDescriptionAssocConfigDescriptionId  sdm_getconfigdescriptionassocconfigdescriptionid_
extern "C" int sdm_getConfigDescriptionAssocConfigDescriptionId(int * configDescriptionId, int * assocConfigDescriptionId, int * assocConfigDescriptionIdDim);

int sdm_getConfigDescriptionAssocConfigDescriptionId(int * configDescriptionId, int * assocConfigDescriptionId, int * assocConfigDescriptionIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ConfigDescriptionTable &table = dataset->getConfigDescription();
	ConfigDescriptionRow *row = 0;
	row = table.getRowByKey( Tag(*configDescriptionId, TagType::ConfigDescription));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAssocConfigDescriptionIdExists()) {
			// attr.CppType: vector<Tag>  attr.isOneD: true
			for (int i=0; i<min((int)row->getAssocConfigDescriptionId().size(),assocConfigDescriptionIdDim[1]); i++)
			// assocConfigDescriptionId[i] = atoi((row->getAssocConfigDescriptionId()[i]).getId().c_str());
			assocConfigDescriptionId[i] = row->getAssocConfigDescriptionId()[i].getTagValue();
			assocConfigDescriptionIdDim[0] = (int)row->getAssocConfigDescriptionId().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace BasebandNameMod;
using namespace AccumModeMod;
using namespace AxisNameMod;
using namespace FilterModeMod;
using namespace CorrelatorNameMod;


// =================== CorrelatorModeTable ============================

extern "C" int sdm_addCorrelatorModeRow (int * numBaseband, BasebandName * basebandNames, int * basebandNamesDim, int * basebandConfig, int * basebandConfigDim, AccumMode * accumMode, int * binMode, int * numAxes, AxisName * axesOrderArray, int * axesOrderArrayDim, FilterMode * filterMode, int * filterModeDim, CorrelatorName * correlatorName);
extern "C" int sdm_getCorrelatorModeRow (int * correlatorModeId, int * numBaseband, BasebandName * basebandNames, int * basebandNamesDim, int * basebandConfig, int * basebandConfigDim, AccumMode * accumMode, int * binMode, int * numAxes, AxisName * axesOrderArray, int * axesOrderArrayDim, FilterMode * filterMode, int * filterModeDim, CorrelatorName * correlatorName);


extern "C" int sdm_getCorrelatorModeTableSize ();

extern "C" int sdm_getCorrelatorModeKeys (int * correlatorModeId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addCorrelatorModeRow (int * numBaseband, BasebandName * basebandNames, int * basebandNamesDim, int * basebandConfig, int * basebandConfigDim, AccumMode * accumMode, int * binMode, int * numAxes, AxisName * axesOrderArray, int * axesOrderArrayDim, FilterMode * filterMode, int * filterModeDim, CorrelatorName * correlatorName){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	CorrelatorModeTable &table = dataset->getCorrelatorMode();
	CorrelatorModeRow *row = 0;

	// basebandNames is an Array
	// basebandNames is OneD
	vector<BasebandNameMod::BasebandName >  basebandNamesVec(basebandNamesDim[0]);
	for (int i=0;i<basebandNamesDim[0];i++)
		basebandNamesVec[i]= BasebandName(basebandNames[i]   );
	// basebandConfig is an Array
	// basebandConfig is OneD
	vector<int >  basebandConfigVec(basebandConfigDim[0]);
	for (int i=0;i<basebandConfigDim[0];i++)
		basebandConfigVec[i]= int(basebandConfig[i]   );
	// accumMode is an enumeration
	// AccumMode * accumMode =  (int) accumMode;
	// axesOrderArray is an Array
	// axesOrderArray is OneD
	vector<AxisNameMod::AxisName >  axesOrderArrayVec(axesOrderArrayDim[0]);
	for (int i=0;i<axesOrderArrayDim[0];i++)
		axesOrderArrayVec[i]= AxisName(axesOrderArray[i]   );
	// filterMode is an Array
	// filterMode is OneD
	vector<FilterModeMod::FilterMode >  filterModeVec(filterModeDim[0]);
	for (int i=0;i<filterModeDim[0];i++)
		filterModeVec[i]= FilterMode(filterMode[i]   );
	// correlatorName is an enumeration
	// CorrelatorName * correlatorName =  (int) correlatorName;
	
	// Create new row
  
	row = table.newRow(*numBaseband, basebandNamesVec, basebandConfigVec, *accumMode, *binMode, *numAxes, axesOrderArrayVec, filterModeVec, *correlatorName);

	// Add row
	CorrelatorModeRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the CorrelatorModeTable" << endl;
	}
	
	// return atoi((retRow->getCorrelatorModeId().getId()).c_str());
	return retRow->getCorrelatorModeId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a CorrelatorModeRow* given a key.
 */
int sdm_getCorrelatorModeRow (int * correlatorModeId, int * numBaseband, BasebandName * basebandNames, int * basebandNamesDim, int * basebandConfig, int * basebandConfigDim, AccumMode * accumMode, int * binMode, int * numAxes, AxisName * axesOrderArray, int * axesOrderArrayDim, FilterMode * filterMode, int * filterModeDim, CorrelatorName * correlatorName) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	CorrelatorModeTable &table = dataset->getCorrelatorMode();
	CorrelatorModeRow *row = 0;
	row = table.getRowByKey( Tag(*correlatorModeId, TagType::CorrelatorMode));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  correlatorModeId  attr.UpperCaseName: CorrelatorModeId
		//  attr.NameS:  numBaseband  attr.UpperCaseName: NumBaseband
		*numBaseband = row->getNumBaseband();
		//  attr.NameS:  basebandNames  attr.UpperCaseName: BasebandNames
		
		vector<BasebandNameMod::BasebandName >  basebandNamesVec = row->getBasebandNames();
		
		for (int i=0; i<min((int)basebandNamesVec.size(),basebandNamesDim[1]); i++)
			basebandNames[i] = basebandNamesVec[i];
		basebandNamesDim[0] = (int)basebandNamesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  basebandConfig  attr.UpperCaseName: BasebandConfig
		
		vector<int >  basebandConfigVec = row->getBasebandConfig();
		
		for (int i=0; i<min((int)basebandConfigVec.size(),basebandConfigDim[1]); i++)
			basebandConfig[i] = basebandConfigVec[i];
		basebandConfigDim[0] = (int)basebandConfigVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  accumMode  attr.UpperCaseName: AccumMode
		*accumMode = row->getAccumMode();
		//  attr.NameS:  binMode  attr.UpperCaseName: BinMode
		*binMode = row->getBinMode();
		//  attr.NameS:  numAxes  attr.UpperCaseName: NumAxes
		*numAxes = row->getNumAxes();
		//  attr.NameS:  axesOrderArray  attr.UpperCaseName: AxesOrderArray
		
		vector<AxisNameMod::AxisName >  axesOrderArrayVec = row->getAxesOrderArray();
		
		for (int i=0; i<min((int)axesOrderArrayVec.size(),axesOrderArrayDim[1]); i++)
			axesOrderArray[i] = axesOrderArrayVec[i];
		axesOrderArrayDim[0] = (int)axesOrderArrayVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  filterMode  attr.UpperCaseName: FilterMode
		
		vector<FilterModeMod::FilterMode >  filterModeVec = row->getFilterMode();
		
		for (int i=0; i<min((int)filterModeVec.size(),filterModeDim[1]); i++)
			filterMode[i] = filterModeVec[i];
		filterModeDim[0] = (int)filterModeVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  correlatorName  attr.UpperCaseName: CorrelatorName
		*correlatorName = row->getCorrelatorName();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getCorrelatorModeTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
CorrelatorModeTable &table = dataset->getCorrelatorMode();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getCorrelatorModeKeys(int * correlatorModeId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	CorrelatorModeTable &table = dataset->getCorrelatorMode();
	
	vector< CorrelatorModeRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// correlatorModeId[i] = atoi((row[i]->getCorrelatorModeId().getId()).c_str());
				correlatorModeId[i] = row[i]->getCorrelatorModeId().getTagValue();
  		}
  		
		return size;
  	}
}







// =================== DataDescriptionTable ============================

extern "C" int sdm_addDataDescriptionRow (int * polOrHoloId, int * spectralWindowId, bool * holoType);
extern "C" int sdm_getDataDescriptionRow (int * dataDescriptionId, int * polOrHoloId, int * spectralWindowId);


extern "C" int sdm_getDataDescriptionTableSize ();

extern "C" int sdm_getDataDescriptionKeys (int * dataDescriptionId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addDataDescriptionRow (int * polOrHoloId, int * spectralWindowId, bool * holoType){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	DataDescriptionTable &table = dataset->getDataDescription();
	DataDescriptionRow *row = 0;

	
	// Create new row
  
	if (*holoType) {
		row = table.newRow(Tag(*polOrHoloId,TagType::Holography), Tag(*spectralWindowId,TagType::SpectralWindow));
	} else {
		row = table.newRow(Tag(*polOrHoloId,TagType::Polarization), Tag(*spectralWindowId,TagType::SpectralWindow));
	}	

	// Add row
	DataDescriptionRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the DataDescriptionTable" << endl;
	}
	
	// return atoi((retRow->getDataDescriptionId().getId()).c_str());
	return retRow->getDataDescriptionId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a DataDescriptionRow* given a key.
 */
int sdm_getDataDescriptionRow (int * dataDescriptionId, int * polOrHoloId, int * spectralWindowId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DataDescriptionTable &table = dataset->getDataDescription();
	DataDescriptionRow *row = 0;
	row = table.getRowByKey( Tag(*dataDescriptionId, TagType::DataDescription));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  dataDescriptionId  attr.UpperCaseName: DataDescriptionId
		//  attr.NameS:  polOrHoloId  attr.UpperCaseName: PolOrHoloId
		// *polOrHoloId = atoi((row->getPolOrHoloId().getId()).c_str());
		*polOrHoloId = row->getPolOrHoloId().getTagValue();
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		// *spectralWindowId = atoi((row->getSpectralWindowId().getId()).c_str());
		*spectralWindowId = row->getSpectralWindowId().getTagValue();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getDataDescriptionTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
DataDescriptionTable &table = dataset->getDataDescription();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getDataDescriptionKeys(int * dataDescriptionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	DataDescriptionTable &table = dataset->getDataDescription();
	
	vector< DataDescriptionRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// dataDescriptionId[i] = atoi((row[i]->getDataDescriptionId().getId()).c_str());
				dataDescriptionId[i] = row[i]->getDataDescriptionId().getTagValue();
  		}
  		
		return size;
  	}
}







// =================== DelayModelFixedParametersTable ============================

extern "C" int sdm_addDelayModelFixedParametersRow (char * delayModelVersion, int * delayModelVersionDim, int * execBlockId);
extern "C" int sdm_getDelayModelFixedParametersRow (int * delayModelFixedParametersId, char * delayModelVersion, int * delayModelVersionDim, int * execBlockId);


extern "C" int sdm_getDelayModelFixedParametersTableSize ();

extern "C" int sdm_getDelayModelFixedParametersKeys (int * delayModelFixedParametersId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addDelayModelFixedParametersRow (char * delayModelVersion, int * delayModelVersionDim, int * execBlockId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;

	
	// Create new row
  
	row = table.newRow(string(delayModelVersion), Tag(*execBlockId,TagType::ExecBlock));

	// Add row
	DelayModelFixedParametersRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the DelayModelFixedParametersTable" << endl;
	}
	
	// return atoi((retRow->getDelayModelFixedParametersId().getId()).c_str());
	return retRow->getDelayModelFixedParametersId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a DelayModelFixedParametersRow* given a key.
 */
int sdm_getDelayModelFixedParametersRow (int * delayModelFixedParametersId, char * delayModelVersion, int * delayModelVersionDim, int * execBlockId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  delayModelFixedParametersId  attr.UpperCaseName: DelayModelFixedParametersId
		//  attr.NameS:  delayModelVersion  attr.UpperCaseName: DelayModelVersion
		if ((int)row->getDelayModelVersion().size()<delayModelVersionDim[1])
			strcpy(delayModelVersion,row->getDelayModelVersion().c_str());
		else
			strncpy(delayModelVersion,row->getDelayModelVersion().c_str(),delayModelVersionDim[1]);
		delayModelVersionDim[0] = (int)row->getDelayModelVersion().size();
		//  attr.NameS:  execBlockId  attr.UpperCaseName: ExecBlockId
		// *execBlockId = atoi((row->getExecBlockId().getId()).c_str());
		*execBlockId = row->getExecBlockId().getTagValue();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getDelayModelFixedParametersTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getDelayModelFixedParametersKeys(int * delayModelFixedParametersId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	vector< DelayModelFixedParametersRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// delayModelFixedParametersId[i] = atoi((row[i]->getDelayModelFixedParametersId().getId()).c_str());
				delayModelFixedParametersId[i] = row[i]->getDelayModelFixedParametersId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter gaussConstant, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersGaussConstant  sdm_adddelaymodelfixedparametersgaussconstant_
extern "C" int sdm_addDelayModelFixedParametersGaussConstant(int * delayModelFixedParametersId, double * gaussConstant);

int sdm_addDelayModelFixedParametersGaussConstant(int * delayModelFixedParametersId, double * gaussConstant) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setGaussConstant(AngularRate(* gaussConstant ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter gaussConstant, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersGaussConstant  sdm_getdelaymodelfixedparametersgaussconstant_
extern "C" int sdm_getDelayModelFixedParametersGaussConstant(int * delayModelFixedParametersId, double * gaussConstant);

int sdm_getDelayModelFixedParametersGaussConstant(int * delayModelFixedParametersId, double * gaussConstant) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isGaussConstantExists()) {
			*gaussConstant = row->getGaussConstant().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter newtonianConstant, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersNewtonianConstant  sdm_adddelaymodelfixedparametersnewtonianconstant_
extern "C" int sdm_addDelayModelFixedParametersNewtonianConstant(int * delayModelFixedParametersId, double * newtonianConstant);

int sdm_addDelayModelFixedParametersNewtonianConstant(int * delayModelFixedParametersId, double * newtonianConstant) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNewtonianConstant(double(* newtonianConstant ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter newtonianConstant, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersNewtonianConstant  sdm_getdelaymodelfixedparametersnewtonianconstant_
extern "C" int sdm_getDelayModelFixedParametersNewtonianConstant(int * delayModelFixedParametersId, double * newtonianConstant);

int sdm_getDelayModelFixedParametersNewtonianConstant(int * delayModelFixedParametersId, double * newtonianConstant) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNewtonianConstantExists()) {
			*newtonianConstant = row->getNewtonianConstant();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter gravity, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersGravity  sdm_adddelaymodelfixedparametersgravity_
extern "C" int sdm_addDelayModelFixedParametersGravity(int * delayModelFixedParametersId, double * gravity);

int sdm_addDelayModelFixedParametersGravity(int * delayModelFixedParametersId, double * gravity) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setGravity(double(* gravity ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter gravity, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersGravity  sdm_getdelaymodelfixedparametersgravity_
extern "C" int sdm_getDelayModelFixedParametersGravity(int * delayModelFixedParametersId, double * gravity);

int sdm_getDelayModelFixedParametersGravity(int * delayModelFixedParametersId, double * gravity) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isGravityExists()) {
			*gravity = row->getGravity();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter earthFlattening, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersEarthFlattening  sdm_adddelaymodelfixedparametersearthflattening_
extern "C" int sdm_addDelayModelFixedParametersEarthFlattening(int * delayModelFixedParametersId, double * earthFlattening);

int sdm_addDelayModelFixedParametersEarthFlattening(int * delayModelFixedParametersId, double * earthFlattening) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setEarthFlattening(double(* earthFlattening ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter earthFlattening, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersEarthFlattening  sdm_getdelaymodelfixedparametersearthflattening_
extern "C" int sdm_getDelayModelFixedParametersEarthFlattening(int * delayModelFixedParametersId, double * earthFlattening);

int sdm_getDelayModelFixedParametersEarthFlattening(int * delayModelFixedParametersId, double * earthFlattening) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isEarthFlatteningExists()) {
			*earthFlattening = row->getEarthFlattening();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter earthRadius, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersEarthRadius  sdm_adddelaymodelfixedparametersearthradius_
extern "C" int sdm_addDelayModelFixedParametersEarthRadius(int * delayModelFixedParametersId, double * earthRadius);

int sdm_addDelayModelFixedParametersEarthRadius(int * delayModelFixedParametersId, double * earthRadius) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setEarthRadius(Length(* earthRadius ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter earthRadius, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersEarthRadius  sdm_getdelaymodelfixedparametersearthradius_
extern "C" int sdm_getDelayModelFixedParametersEarthRadius(int * delayModelFixedParametersId, double * earthRadius);

int sdm_getDelayModelFixedParametersEarthRadius(int * delayModelFixedParametersId, double * earthRadius) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isEarthRadiusExists()) {
			*earthRadius = row->getEarthRadius().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter moonEarthMassRatio, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersMoonEarthMassRatio  sdm_adddelaymodelfixedparametersmoonearthmassratio_
extern "C" int sdm_addDelayModelFixedParametersMoonEarthMassRatio(int * delayModelFixedParametersId, double * moonEarthMassRatio);

int sdm_addDelayModelFixedParametersMoonEarthMassRatio(int * delayModelFixedParametersId, double * moonEarthMassRatio) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setMoonEarthMassRatio(double(* moonEarthMassRatio ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter moonEarthMassRatio, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersMoonEarthMassRatio  sdm_getdelaymodelfixedparametersmoonearthmassratio_
extern "C" int sdm_getDelayModelFixedParametersMoonEarthMassRatio(int * delayModelFixedParametersId, double * moonEarthMassRatio);

int sdm_getDelayModelFixedParametersMoonEarthMassRatio(int * delayModelFixedParametersId, double * moonEarthMassRatio) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isMoonEarthMassRatioExists()) {
			*moonEarthMassRatio = row->getMoonEarthMassRatio();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter ephemerisEpoch, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersEphemerisEpoch  sdm_adddelaymodelfixedparametersephemerisepoch_
extern "C" int sdm_addDelayModelFixedParametersEphemerisEpoch(int * delayModelFixedParametersId, char * ephemerisEpoch, int * ephemerisEpochDim);

int sdm_addDelayModelFixedParametersEphemerisEpoch(int * delayModelFixedParametersId, char * ephemerisEpoch, int * ephemerisEpochDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setEphemerisEpoch(string(ephemerisEpoch));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter ephemerisEpoch, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersEphemerisEpoch  sdm_getdelaymodelfixedparametersephemerisepoch_
extern "C" int sdm_getDelayModelFixedParametersEphemerisEpoch(int * delayModelFixedParametersId, char * ephemerisEpoch, int * ephemerisEpochDim);

int sdm_getDelayModelFixedParametersEphemerisEpoch(int * delayModelFixedParametersId, char * ephemerisEpoch, int * ephemerisEpochDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isEphemerisEpochExists()) {
			if ((int)row->getEphemerisEpoch().size()<ephemerisEpochDim[1])
				strcpy(ephemerisEpoch,row->getEphemerisEpoch().c_str());
			else
				strncpy(ephemerisEpoch,row->getEphemerisEpoch().c_str(),ephemerisEpochDim[1]);
			ephemerisEpochDim[0] = (int)row->getEphemerisEpoch().size();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter earthTideLag, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersEarthTideLag  sdm_adddelaymodelfixedparametersearthtidelag_
extern "C" int sdm_addDelayModelFixedParametersEarthTideLag(int * delayModelFixedParametersId, double * earthTideLag);

int sdm_addDelayModelFixedParametersEarthTideLag(int * delayModelFixedParametersId, double * earthTideLag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setEarthTideLag(double(* earthTideLag ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter earthTideLag, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersEarthTideLag  sdm_getdelaymodelfixedparametersearthtidelag_
extern "C" int sdm_getDelayModelFixedParametersEarthTideLag(int * delayModelFixedParametersId, double * earthTideLag);

int sdm_getDelayModelFixedParametersEarthTideLag(int * delayModelFixedParametersId, double * earthTideLag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isEarthTideLagExists()) {
			*earthTideLag = row->getEarthTideLag();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter earthGM, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersEarthGM  sdm_adddelaymodelfixedparametersearthgm_
extern "C" int sdm_addDelayModelFixedParametersEarthGM(int * delayModelFixedParametersId, double * earthGM);

int sdm_addDelayModelFixedParametersEarthGM(int * delayModelFixedParametersId, double * earthGM) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setEarthGM(double(* earthGM ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter earthGM, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersEarthGM  sdm_getdelaymodelfixedparametersearthgm_
extern "C" int sdm_getDelayModelFixedParametersEarthGM(int * delayModelFixedParametersId, double * earthGM);

int sdm_getDelayModelFixedParametersEarthGM(int * delayModelFixedParametersId, double * earthGM) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isEarthGMExists()) {
			*earthGM = row->getEarthGM();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter moonGM, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersMoonGM  sdm_adddelaymodelfixedparametersmoongm_
extern "C" int sdm_addDelayModelFixedParametersMoonGM(int * delayModelFixedParametersId, double * moonGM);

int sdm_addDelayModelFixedParametersMoonGM(int * delayModelFixedParametersId, double * moonGM) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setMoonGM(double(* moonGM ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter moonGM, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersMoonGM  sdm_getdelaymodelfixedparametersmoongm_
extern "C" int sdm_getDelayModelFixedParametersMoonGM(int * delayModelFixedParametersId, double * moonGM);

int sdm_getDelayModelFixedParametersMoonGM(int * delayModelFixedParametersId, double * moonGM) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isMoonGMExists()) {
			*moonGM = row->getMoonGM();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sunGM, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersSunGM  sdm_adddelaymodelfixedparameterssungm_
extern "C" int sdm_addDelayModelFixedParametersSunGM(int * delayModelFixedParametersId, double * sunGM);

int sdm_addDelayModelFixedParametersSunGM(int * delayModelFixedParametersId, double * sunGM) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSunGM(double(* sunGM ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sunGM, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersSunGM  sdm_getdelaymodelfixedparameterssungm_
extern "C" int sdm_getDelayModelFixedParametersSunGM(int * delayModelFixedParametersId, double * sunGM);

int sdm_getDelayModelFixedParametersSunGM(int * delayModelFixedParametersId, double * sunGM) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSunGMExists()) {
			*sunGM = row->getSunGM();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter loveNumberH, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersLoveNumberH  sdm_adddelaymodelfixedparameterslovenumberh_
extern "C" int sdm_addDelayModelFixedParametersLoveNumberH(int * delayModelFixedParametersId, double * loveNumberH);

int sdm_addDelayModelFixedParametersLoveNumberH(int * delayModelFixedParametersId, double * loveNumberH) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setLoveNumberH(double(* loveNumberH ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter loveNumberH, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersLoveNumberH  sdm_getdelaymodelfixedparameterslovenumberh_
extern "C" int sdm_getDelayModelFixedParametersLoveNumberH(int * delayModelFixedParametersId, double * loveNumberH);

int sdm_getDelayModelFixedParametersLoveNumberH(int * delayModelFixedParametersId, double * loveNumberH) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isLoveNumberHExists()) {
			*loveNumberH = row->getLoveNumberH();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter loveNumberL, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersLoveNumberL  sdm_adddelaymodelfixedparameterslovenumberl_
extern "C" int sdm_addDelayModelFixedParametersLoveNumberL(int * delayModelFixedParametersId, double * loveNumberL);

int sdm_addDelayModelFixedParametersLoveNumberL(int * delayModelFixedParametersId, double * loveNumberL) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setLoveNumberL(double(* loveNumberL ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter loveNumberL, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersLoveNumberL  sdm_getdelaymodelfixedparameterslovenumberl_
extern "C" int sdm_getDelayModelFixedParametersLoveNumberL(int * delayModelFixedParametersId, double * loveNumberL);

int sdm_getDelayModelFixedParametersLoveNumberL(int * delayModelFixedParametersId, double * loveNumberL) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isLoveNumberLExists()) {
			*loveNumberL = row->getLoveNumberL();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter precessionConstant, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersPrecessionConstant  sdm_adddelaymodelfixedparametersprecessionconstant_
extern "C" int sdm_addDelayModelFixedParametersPrecessionConstant(int * delayModelFixedParametersId, double * precessionConstant);

int sdm_addDelayModelFixedParametersPrecessionConstant(int * delayModelFixedParametersId, double * precessionConstant) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setPrecessionConstant(AngularRate(* precessionConstant ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter precessionConstant, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersPrecessionConstant  sdm_getdelaymodelfixedparametersprecessionconstant_
extern "C" int sdm_getDelayModelFixedParametersPrecessionConstant(int * delayModelFixedParametersId, double * precessionConstant);

int sdm_getDelayModelFixedParametersPrecessionConstant(int * delayModelFixedParametersId, double * precessionConstant) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPrecessionConstantExists()) {
			*precessionConstant = row->getPrecessionConstant().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter lightTime1AU, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersLightTime1AU  sdm_adddelaymodelfixedparameterslighttime1au_
extern "C" int sdm_addDelayModelFixedParametersLightTime1AU(int * delayModelFixedParametersId, double * lightTime1AU);

int sdm_addDelayModelFixedParametersLightTime1AU(int * delayModelFixedParametersId, double * lightTime1AU) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setLightTime1AU(double(* lightTime1AU ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter lightTime1AU, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersLightTime1AU  sdm_getdelaymodelfixedparameterslighttime1au_
extern "C" int sdm_getDelayModelFixedParametersLightTime1AU(int * delayModelFixedParametersId, double * lightTime1AU);

int sdm_getDelayModelFixedParametersLightTime1AU(int * delayModelFixedParametersId, double * lightTime1AU) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isLightTime1AUExists()) {
			*lightTime1AU = row->getLightTime1AU();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter speedOfLight, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersSpeedOfLight  sdm_adddelaymodelfixedparametersspeedoflight_
extern "C" int sdm_addDelayModelFixedParametersSpeedOfLight(int * delayModelFixedParametersId, double * speedOfLight);

int sdm_addDelayModelFixedParametersSpeedOfLight(int * delayModelFixedParametersId, double * speedOfLight) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSpeedOfLight(Speed(* speedOfLight ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter speedOfLight, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersSpeedOfLight  sdm_getdelaymodelfixedparametersspeedoflight_
extern "C" int sdm_getDelayModelFixedParametersSpeedOfLight(int * delayModelFixedParametersId, double * speedOfLight);

int sdm_getDelayModelFixedParametersSpeedOfLight(int * delayModelFixedParametersId, double * speedOfLight) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSpeedOfLightExists()) {
			*speedOfLight = row->getSpeedOfLight().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter delayModelFlags, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_addDelayModelFixedParametersDelayModelFlags  sdm_adddelaymodelfixedparametersdelaymodelflags_
extern "C" int sdm_addDelayModelFixedParametersDelayModelFlags(int * delayModelFixedParametersId, char * delayModelFlags, int * delayModelFlagsDim);

int sdm_addDelayModelFixedParametersDelayModelFlags(int * delayModelFixedParametersId, char * delayModelFlags, int * delayModelFlagsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDelayModelFlags(string(delayModelFlags));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter delayModelFlags, in a row of the DelayModelFixedParameters table, given a key
 *
 */

#define sdm_getDelayModelFixedParametersDelayModelFlags  sdm_getdelaymodelfixedparametersdelaymodelflags_
extern "C" int sdm_getDelayModelFixedParametersDelayModelFlags(int * delayModelFixedParametersId, char * delayModelFlags, int * delayModelFlagsDim);

int sdm_getDelayModelFixedParametersDelayModelFlags(int * delayModelFixedParametersId, char * delayModelFlags, int * delayModelFlagsDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelFixedParametersTable &table = dataset->getDelayModelFixedParameters();
	DelayModelFixedParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelFixedParametersId, TagType::DelayModelFixedParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDelayModelFlagsExists()) {
			if ((int)row->getDelayModelFlags().size()<delayModelFlagsDim[1])
				strcpy(delayModelFlags,row->getDelayModelFlags().c_str());
			else
				strncpy(delayModelFlags,row->getDelayModelFlags().c_str(),delayModelFlagsDim[1]);
			delayModelFlagsDim[0] = (int)row->getDelayModelFlags().size();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace PolarizationTypeMod;


// =================== DelayModelTable ============================

extern "C" int sdm_addDelayModelRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numPoly, double * phaseDelay, int * phaseDelayDim, double * phaseDelayRate, int * phaseDelayRateDim, double * groupDelay, int * groupDelayDim, double * groupDelayRate, int * groupDelayRateDim, int * fieldId);
extern "C" int sdm_getDelayModelRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numPoly, double * phaseDelay, int * phaseDelayDim, double * phaseDelayRate, int * phaseDelayRateDim, double * groupDelay, int * groupDelayDim, double * groupDelayRate, int * groupDelayRateDim, int * fieldId);


extern "C" int sdm_getDelayModelTableSize ();

extern "C" int sdm_getDelayModelKeys (int * antennaId, int * spectralWindowId, int64_t * timeInterval);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addDelayModelRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numPoly, double * phaseDelay, int * phaseDelayDim, double * phaseDelayRate, int * phaseDelayRateDim, double * groupDelay, int * groupDelayDim, double * groupDelayRate, int * groupDelayRateDim, int * fieldId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;

	// phaseDelay is an Array
	// phaseDelay is OneD
	vector<double >  phaseDelayVec(phaseDelayDim[0]);
	for (int i=0;i<phaseDelayDim[0];i++)
		phaseDelayVec[i]= double(phaseDelay[i]   );
	// phaseDelayRate is an Array
	// phaseDelayRate is OneD
	vector<double >  phaseDelayRateVec(phaseDelayRateDim[0]);
	for (int i=0;i<phaseDelayRateDim[0];i++)
		phaseDelayRateVec[i]= double(phaseDelayRate[i]   );
	// groupDelay is an Array
	// groupDelay is OneD
	vector<double >  groupDelayVec(groupDelayDim[0]);
	for (int i=0;i<groupDelayDim[0];i++)
		groupDelayVec[i]= double(groupDelay[i]   );
	// groupDelayRate is an Array
	// groupDelayRate is OneD
	vector<double >  groupDelayRateVec(groupDelayRateDim[0]);
	for (int i=0;i<groupDelayRateDim[0];i++)
		groupDelayRateVec[i]= double(groupDelayRate[i]   );
	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *numPoly, phaseDelayVec, phaseDelayRateVec, groupDelayVec, groupDelayRateVec, Tag(*fieldId,TagType::Field));
	} else {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *numPoly, phaseDelayVec, phaseDelayRateVec, groupDelayVec, groupDelayRateVec, Tag(*fieldId,TagType::Field));
	}

	// Add row
	DelayModelRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the DelayModelTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a DelayModelRow* given a key.
 */
int sdm_getDelayModelRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numPoly, double * phaseDelay, int * phaseDelayDim, double * phaseDelayRate, int * phaseDelayRateDim, double * groupDelay, int * groupDelayDim, double * groupDelayRate, int * groupDelayRateDim, int * fieldId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  numPoly  attr.UpperCaseName: NumPoly
		*numPoly = row->getNumPoly();
		//  attr.NameS:  phaseDelay  attr.UpperCaseName: PhaseDelay
		
		vector<double >  phaseDelayVec = row->getPhaseDelay();
		
		for (int i=0; i<min((int)phaseDelayVec.size(),phaseDelayDim[1]); i++)
			phaseDelay[i] = phaseDelayVec[i];
		phaseDelayDim[0] = (int)phaseDelayVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  phaseDelayRate  attr.UpperCaseName: PhaseDelayRate
		
		vector<double >  phaseDelayRateVec = row->getPhaseDelayRate();
		
		for (int i=0; i<min((int)phaseDelayRateVec.size(),phaseDelayRateDim[1]); i++)
			phaseDelayRate[i] = phaseDelayRateVec[i];
		phaseDelayRateDim[0] = (int)phaseDelayRateVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  groupDelay  attr.UpperCaseName: GroupDelay
		
		vector<double >  groupDelayVec = row->getGroupDelay();
		
		for (int i=0; i<min((int)groupDelayVec.size(),groupDelayDim[1]); i++)
			groupDelay[i] = groupDelayVec[i];
		groupDelayDim[0] = (int)groupDelayVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  groupDelayRate  attr.UpperCaseName: GroupDelayRate
		
		vector<double >  groupDelayRateVec = row->getGroupDelayRate();
		
		for (int i=0; i<min((int)groupDelayRateVec.size(),groupDelayRateDim[1]); i++)
			groupDelayRate[i] = groupDelayRateVec[i];
		groupDelayRateDim[0] = (int)groupDelayRateVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  fieldId  attr.UpperCaseName: FieldId
		// *fieldId = atoi((row->getFieldId().getId()).c_str());
		*fieldId = row->getFieldId().getTagValue();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getDelayModelTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
DelayModelTable &table = dataset->getDelayModel();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getDelayModelKeys(int * antennaId, int * spectralWindowId, int64_t * timeInterval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	
	vector< DelayModelRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		// spectralWindowId[i] = atoi((row[i]->getSpectralWindowId().getId()).c_str());
				spectralWindowId[i] = row[i]->getSpectralWindowId().getTagValue();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter timeOrigin, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelTimeOrigin  sdm_adddelaymodeltimeorigin_
extern "C" int sdm_addDelayModelTimeOrigin(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int64_t * timeOrigin);

int sdm_addDelayModelTimeOrigin(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int64_t * timeOrigin) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTimeOrigin(ArrayTime(* timeOrigin ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter timeOrigin, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelTimeOrigin  sdm_getdelaymodeltimeorigin_
extern "C" int sdm_getDelayModelTimeOrigin(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int64_t * timeOrigin);

int sdm_getDelayModelTimeOrigin(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int64_t * timeOrigin) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTimeOriginExists()) {
			*timeOrigin     = row->getTimeOrigin().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter atmosphericGroupDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelAtmosphericGroupDelay  sdm_adddelaymodelatmosphericgroupdelay_
extern "C" int sdm_addDelayModelAtmosphericGroupDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericGroupDelay);

int sdm_addDelayModelAtmosphericGroupDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericGroupDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setAtmosphericGroupDelay(double(* atmosphericGroupDelay ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter atmosphericGroupDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelAtmosphericGroupDelay  sdm_getdelaymodelatmosphericgroupdelay_
extern "C" int sdm_getDelayModelAtmosphericGroupDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericGroupDelay);

int sdm_getDelayModelAtmosphericGroupDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericGroupDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAtmosphericGroupDelayExists()) {
			*atmosphericGroupDelay = row->getAtmosphericGroupDelay();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter atmosphericGroupDelayRate, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelAtmosphericGroupDelayRate  sdm_adddelaymodelatmosphericgroupdelayrate_
extern "C" int sdm_addDelayModelAtmosphericGroupDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericGroupDelayRate);

int sdm_addDelayModelAtmosphericGroupDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericGroupDelayRate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setAtmosphericGroupDelayRate(double(* atmosphericGroupDelayRate ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter atmosphericGroupDelayRate, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelAtmosphericGroupDelayRate  sdm_getdelaymodelatmosphericgroupdelayrate_
extern "C" int sdm_getDelayModelAtmosphericGroupDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericGroupDelayRate);

int sdm_getDelayModelAtmosphericGroupDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericGroupDelayRate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAtmosphericGroupDelayRateExists()) {
			*atmosphericGroupDelayRate = row->getAtmosphericGroupDelayRate();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter geometricDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelGeometricDelay  sdm_adddelaymodelgeometricdelay_
extern "C" int sdm_addDelayModelGeometricDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * geometricDelay);

int sdm_addDelayModelGeometricDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * geometricDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setGeometricDelay(double(* geometricDelay ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter geometricDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelGeometricDelay  sdm_getdelaymodelgeometricdelay_
extern "C" int sdm_getDelayModelGeometricDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * geometricDelay);

int sdm_getDelayModelGeometricDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * geometricDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isGeometricDelayExists()) {
			*geometricDelay = row->getGeometricDelay();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter geometricDelayRate, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelGeometricDelayRate  sdm_adddelaymodelgeometricdelayrate_
extern "C" int sdm_addDelayModelGeometricDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * geometricDelayRate);

int sdm_addDelayModelGeometricDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * geometricDelayRate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setGeometricDelayRate(double(* geometricDelayRate ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter geometricDelayRate, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelGeometricDelayRate  sdm_getdelaymodelgeometricdelayrate_
extern "C" int sdm_getDelayModelGeometricDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * geometricDelayRate);

int sdm_getDelayModelGeometricDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * geometricDelayRate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isGeometricDelayRateExists()) {
			*geometricDelayRate = row->getGeometricDelayRate();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numLO, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelNumLO  sdm_adddelaymodelnumlo_
extern "C" int sdm_addDelayModelNumLO(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numLO);

int sdm_addDelayModelNumLO(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numLO) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumLO(int(* numLO ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numLO, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelNumLO  sdm_getdelaymodelnumlo_
extern "C" int sdm_getDelayModelNumLO(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numLO);

int sdm_getDelayModelNumLO(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numLO) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumLOExists()) {
			*numLO = row->getNumLO();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter LOOffset, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelLOOffset  sdm_adddelaymodellooffset_
extern "C" int sdm_addDelayModelLOOffset(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LOOffset, int * LOOffsetDim);

int sdm_addDelayModelLOOffset(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LOOffset, int * LOOffsetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Frequency >  LOOffsetVec(LOOffsetDim[0]);
		for (int i=0;i<LOOffsetDim[0];i++)
			LOOffsetVec[i]= Frequency(LOOffset[i] );
		row->setLOOffset(LOOffsetVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter LOOffset, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelLOOffset  sdm_getdelaymodellooffset_
extern "C" int sdm_getDelayModelLOOffset(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LOOffset, int * LOOffsetDim);

int sdm_getDelayModelLOOffset(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LOOffset, int * LOOffsetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isLOOffsetExists()) {
			// attr.CppType: vector<Frequency > attr.isOneD: true
			for (int i=0; i<min((int)row->getLOOffset().size(),LOOffsetDim[1]); i++)
				LOOffset[i] = row->getLOOffset()[i].get();
			LOOffsetDim[0] = row->getLOOffset().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter LOOffsetRate, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelLOOffsetRate  sdm_adddelaymodellooffsetrate_
extern "C" int sdm_addDelayModelLOOffsetRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LOOffsetRate, int * LOOffsetRateDim);

int sdm_addDelayModelLOOffsetRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LOOffsetRate, int * LOOffsetRateDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Frequency >  LOOffsetRateVec(LOOffsetRateDim[0]);
		for (int i=0;i<LOOffsetRateDim[0];i++)
			LOOffsetRateVec[i]= Frequency(LOOffsetRate[i] );
		row->setLOOffsetRate(LOOffsetRateVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter LOOffsetRate, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelLOOffsetRate  sdm_getdelaymodellooffsetrate_
extern "C" int sdm_getDelayModelLOOffsetRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LOOffsetRate, int * LOOffsetRateDim);

int sdm_getDelayModelLOOffsetRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LOOffsetRate, int * LOOffsetRateDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isLOOffsetRateExists()) {
			// attr.CppType: vector<Frequency > attr.isOneD: true
			for (int i=0; i<min((int)row->getLOOffsetRate().size(),LOOffsetRateDim[1]); i++)
				LOOffsetRate[i] = row->getLOOffsetRate()[i].get();
			LOOffsetRateDim[0] = row->getLOOffsetRate().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter dispersiveDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelDispersiveDelay  sdm_adddelaymodeldispersivedelay_
extern "C" int sdm_addDelayModelDispersiveDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * dispersiveDelay);

int sdm_addDelayModelDispersiveDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * dispersiveDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDispersiveDelay(double(* dispersiveDelay ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter dispersiveDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelDispersiveDelay  sdm_getdelaymodeldispersivedelay_
extern "C" int sdm_getDelayModelDispersiveDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * dispersiveDelay);

int sdm_getDelayModelDispersiveDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * dispersiveDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDispersiveDelayExists()) {
			*dispersiveDelay = row->getDispersiveDelay();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter dispersiveDelayRate, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelDispersiveDelayRate  sdm_adddelaymodeldispersivedelayrate_
extern "C" int sdm_addDelayModelDispersiveDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * dispersiveDelayRate);

int sdm_addDelayModelDispersiveDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * dispersiveDelayRate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDispersiveDelayRate(double(* dispersiveDelayRate ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter dispersiveDelayRate, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelDispersiveDelayRate  sdm_getdelaymodeldispersivedelayrate_
extern "C" int sdm_getDelayModelDispersiveDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * dispersiveDelayRate);

int sdm_getDelayModelDispersiveDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * dispersiveDelayRate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDispersiveDelayRateExists()) {
			*dispersiveDelayRate = row->getDispersiveDelayRate();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter atmosphericDryDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelAtmosphericDryDelay  sdm_adddelaymodelatmosphericdrydelay_
extern "C" int sdm_addDelayModelAtmosphericDryDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericDryDelay);

int sdm_addDelayModelAtmosphericDryDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericDryDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setAtmosphericDryDelay(double(* atmosphericDryDelay ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter atmosphericDryDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelAtmosphericDryDelay  sdm_getdelaymodelatmosphericdrydelay_
extern "C" int sdm_getDelayModelAtmosphericDryDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericDryDelay);

int sdm_getDelayModelAtmosphericDryDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericDryDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAtmosphericDryDelayExists()) {
			*atmosphericDryDelay = row->getAtmosphericDryDelay();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter atmosphericWetDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelAtmosphericWetDelay  sdm_adddelaymodelatmosphericwetdelay_
extern "C" int sdm_addDelayModelAtmosphericWetDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericWetDelay);

int sdm_addDelayModelAtmosphericWetDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericWetDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setAtmosphericWetDelay(double(* atmosphericWetDelay ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter atmosphericWetDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelAtmosphericWetDelay  sdm_getdelaymodelatmosphericwetdelay_
extern "C" int sdm_getDelayModelAtmosphericWetDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericWetDelay);

int sdm_getDelayModelAtmosphericWetDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * atmosphericWetDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAtmosphericWetDelayExists()) {
			*atmosphericWetDelay = row->getAtmosphericWetDelay();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter padDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelPadDelay  sdm_adddelaymodelpaddelay_
extern "C" int sdm_addDelayModelPadDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * padDelay);

int sdm_addDelayModelPadDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * padDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setPadDelay(double(* padDelay ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter padDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelPadDelay  sdm_getdelaymodelpaddelay_
extern "C" int sdm_getDelayModelPadDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * padDelay);

int sdm_getDelayModelPadDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * padDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPadDelayExists()) {
			*padDelay = row->getPadDelay();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter antennaDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelAntennaDelay  sdm_adddelaymodelantennadelay_
extern "C" int sdm_addDelayModelAntennaDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * antennaDelay);

int sdm_addDelayModelAntennaDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * antennaDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setAntennaDelay(double(* antennaDelay ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter antennaDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelAntennaDelay  sdm_getdelaymodelantennadelay_
extern "C" int sdm_getDelayModelAntennaDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * antennaDelay);

int sdm_getDelayModelAntennaDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * antennaDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAntennaDelayExists()) {
			*antennaDelay = row->getAntennaDelay();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numReceptor, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelNumReceptor  sdm_adddelaymodelnumreceptor_
extern "C" int sdm_addDelayModelNumReceptor(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numReceptor);

int sdm_addDelayModelNumReceptor(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numReceptor) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumReceptor(int(* numReceptor ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numReceptor, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelNumReceptor  sdm_getdelaymodelnumreceptor_
extern "C" int sdm_getDelayModelNumReceptor(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numReceptor);

int sdm_getDelayModelNumReceptor(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numReceptor) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumReceptorExists()) {
			*numReceptor = row->getNumReceptor();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter polarizationType, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelPolarizationType  sdm_adddelaymodelpolarizationtype_
extern "C" int sdm_addDelayModelPolarizationType(int * antennaId, int * spectralWindowId, int64_t * timeInterval, PolarizationType * polarizationType, int * polarizationTypeDim);

int sdm_addDelayModelPolarizationType(int * antennaId, int * spectralWindowId, int64_t * timeInterval, PolarizationType * polarizationType, int * polarizationTypeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypeVec(polarizationTypeDim[0]);
		for (int i=0;i<polarizationTypeDim[0];i++)
			polarizationTypeVec[i]= PolarizationType(polarizationType[i] );
		row->setPolarizationType(polarizationTypeVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter polarizationType, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelPolarizationType  sdm_getdelaymodelpolarizationtype_
extern "C" int sdm_getDelayModelPolarizationType(int * antennaId, int * spectralWindowId, int64_t * timeInterval, PolarizationType * polarizationType, int * polarizationTypeDim);

int sdm_getDelayModelPolarizationType(int * antennaId, int * spectralWindowId, int64_t * timeInterval, PolarizationType * polarizationType, int * polarizationTypeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPolarizationTypeExists()) {
			// attr.CppType: vector<PolarizationTypeMod::PolarizationType > attr.isOneD: true
			for (int i=0; i<min((int)row->getPolarizationType().size(),polarizationTypeDim[1]); i++)
				polarizationType[i] = row->getPolarizationType()[i];
			polarizationTypeDim[0] = (int)row->getPolarizationType().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter electronicDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelElectronicDelay  sdm_adddelaymodelelectronicdelay_
extern "C" int sdm_addDelayModelElectronicDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * electronicDelay, int * electronicDelayDim);

int sdm_addDelayModelElectronicDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * electronicDelay, int * electronicDelayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<double >  electronicDelayVec(electronicDelayDim[0]);
		for (int i=0;i<electronicDelayDim[0];i++)
			electronicDelayVec[i]= double(electronicDelay[i] );
		row->setElectronicDelay(electronicDelayVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter electronicDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelElectronicDelay  sdm_getdelaymodelelectronicdelay_
extern "C" int sdm_getDelayModelElectronicDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * electronicDelay, int * electronicDelayDim);

int sdm_getDelayModelElectronicDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * electronicDelay, int * electronicDelayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isElectronicDelayExists()) {
			// attr.CppType: vector<double > attr.isOneD: true
			for (int i=0; i<min((int)row->getElectronicDelay().size(),electronicDelayDim[1]); i++)
				electronicDelay[i] = row->getElectronicDelay()[i];
			electronicDelayDim[0] = (int)row->getElectronicDelay().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter electronicDelayRate, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelElectronicDelayRate  sdm_adddelaymodelelectronicdelayrate_
extern "C" int sdm_addDelayModelElectronicDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * electronicDelayRate, int * electronicDelayRateDim);

int sdm_addDelayModelElectronicDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * electronicDelayRate, int * electronicDelayRateDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<double >  electronicDelayRateVec(electronicDelayRateDim[0]);
		for (int i=0;i<electronicDelayRateDim[0];i++)
			electronicDelayRateVec[i]= double(electronicDelayRate[i] );
		row->setElectronicDelayRate(electronicDelayRateVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter electronicDelayRate, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelElectronicDelayRate  sdm_getdelaymodelelectronicdelayrate_
extern "C" int sdm_getDelayModelElectronicDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * electronicDelayRate, int * electronicDelayRateDim);

int sdm_getDelayModelElectronicDelayRate(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * electronicDelayRate, int * electronicDelayRateDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isElectronicDelayRateExists()) {
			// attr.CppType: vector<double > attr.isOneD: true
			for (int i=0; i<min((int)row->getElectronicDelayRate().size(),electronicDelayRateDim[1]); i++)
				electronicDelayRate[i] = row->getElectronicDelayRate()[i];
			electronicDelayRateDim[0] = (int)row->getElectronicDelayRate().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter receiverDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelReceiverDelay  sdm_adddelaymodelreceiverdelay_
extern "C" int sdm_addDelayModelReceiverDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * receiverDelay, int * receiverDelayDim);

int sdm_addDelayModelReceiverDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * receiverDelay, int * receiverDelayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<double >  receiverDelayVec(receiverDelayDim[0]);
		for (int i=0;i<receiverDelayDim[0];i++)
			receiverDelayVec[i]= double(receiverDelay[i] );
		row->setReceiverDelay(receiverDelayVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter receiverDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelReceiverDelay  sdm_getdelaymodelreceiverdelay_
extern "C" int sdm_getDelayModelReceiverDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * receiverDelay, int * receiverDelayDim);

int sdm_getDelayModelReceiverDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * receiverDelay, int * receiverDelayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isReceiverDelayExists()) {
			// attr.CppType: vector<double > attr.isOneD: true
			for (int i=0; i<min((int)row->getReceiverDelay().size(),receiverDelayDim[1]); i++)
				receiverDelay[i] = row->getReceiverDelay()[i];
			receiverDelayDim[0] = (int)row->getReceiverDelay().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter IFDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelIFDelay  sdm_adddelaymodelifdelay_
extern "C" int sdm_addDelayModelIFDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * IFDelay, int * IFDelayDim);

int sdm_addDelayModelIFDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * IFDelay, int * IFDelayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<double >  IFDelayVec(IFDelayDim[0]);
		for (int i=0;i<IFDelayDim[0];i++)
			IFDelayVec[i]= double(IFDelay[i] );
		row->setIFDelay(IFDelayVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter IFDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelIFDelay  sdm_getdelaymodelifdelay_
extern "C" int sdm_getDelayModelIFDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * IFDelay, int * IFDelayDim);

int sdm_getDelayModelIFDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * IFDelay, int * IFDelayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isIFDelayExists()) {
			// attr.CppType: vector<double > attr.isOneD: true
			for (int i=0; i<min((int)row->getIFDelay().size(),IFDelayDim[1]); i++)
				IFDelay[i] = row->getIFDelay()[i];
			IFDelayDim[0] = (int)row->getIFDelay().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter LODelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelLODelay  sdm_adddelaymodellodelay_
extern "C" int sdm_addDelayModelLODelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LODelay, int * LODelayDim);

int sdm_addDelayModelLODelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LODelay, int * LODelayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<double >  LODelayVec(LODelayDim[0]);
		for (int i=0;i<LODelayDim[0];i++)
			LODelayVec[i]= double(LODelay[i] );
		row->setLODelay(LODelayVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter LODelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelLODelay  sdm_getdelaymodellodelay_
extern "C" int sdm_getDelayModelLODelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LODelay, int * LODelayDim);

int sdm_getDelayModelLODelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * LODelay, int * LODelayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isLODelayExists()) {
			// attr.CppType: vector<double > attr.isOneD: true
			for (int i=0; i<min((int)row->getLODelay().size(),LODelayDim[1]); i++)
				LODelay[i] = row->getLODelay()[i];
			LODelayDim[0] = (int)row->getLODelay().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter crossPolarizationDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_addDelayModelCrossPolarizationDelay  sdm_adddelaymodelcrosspolarizationdelay_
extern "C" int sdm_addDelayModelCrossPolarizationDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * crossPolarizationDelay);

int sdm_addDelayModelCrossPolarizationDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * crossPolarizationDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelTable &table = dataset->getDelayModel();
	
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCrossPolarizationDelay(double(* crossPolarizationDelay ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter crossPolarizationDelay, in a row of the DelayModel table, given a key
 *
 */

#define sdm_getDelayModelCrossPolarizationDelay  sdm_getdelaymodelcrosspolarizationdelay_
extern "C" int sdm_getDelayModelCrossPolarizationDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * crossPolarizationDelay);

int sdm_getDelayModelCrossPolarizationDelay(int * antennaId, int * spectralWindowId, int64_t * timeInterval, double * crossPolarizationDelay) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelTable &table = dataset->getDelayModel();
	DelayModelRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCrossPolarizationDelayExists()) {
			*crossPolarizationDelay = row->getCrossPolarizationDelay();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace DifferenceTypeMod;
using namespace DifferenceTypeMod;


// =================== DelayModelVariableParametersTable ============================

extern "C" int sdm_addDelayModelVariableParametersRow (int64_t * time, double * ut1_utc, double * iat_utc, DifferenceType * timeType, double * gstAtUt0, double * earthRotationRate, double * polarOffsets, int * polarOffsetsDim, DifferenceType * polarOffsetsType, int * delayModelFixedParametersId);
extern "C" int sdm_getDelayModelVariableParametersRow (int * delayModelVariableParametersId, int64_t * time, double * ut1_utc, double * iat_utc, DifferenceType * timeType, double * gstAtUt0, double * earthRotationRate, double * polarOffsets, int * polarOffsetsDim, DifferenceType * polarOffsetsType, int * delayModelFixedParametersId);


extern "C" int sdm_getDelayModelVariableParametersTableSize ();

extern "C" int sdm_getDelayModelVariableParametersKeys (int * delayModelVariableParametersId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addDelayModelVariableParametersRow (int64_t * time, double * ut1_utc, double * iat_utc, DifferenceType * timeType, double * gstAtUt0, double * earthRotationRate, double * polarOffsets, int * polarOffsetsDim, DifferenceType * polarOffsetsType, int * delayModelFixedParametersId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	DelayModelVariableParametersRow *row = 0;

	// timeType is an enumeration
	// DifferenceType * timeType =  (int) timeType;
	// polarOffsets is an Array
	// polarOffsets is OneD
	vector<double >  polarOffsetsVec(polarOffsetsDim[0]);
	for (int i=0;i<polarOffsetsDim[0];i++)
		polarOffsetsVec[i]= double(polarOffsets[i]   );
	// polarOffsetsType is an enumeration
	// DifferenceType * polarOffsetsType =  (int) polarOffsetsType;
	
	// Create new row
  
	row = table.newRow(ArrayTime(*time), *ut1_utc, *iat_utc, *timeType, Angle(*gstAtUt0), AngularRate(*earthRotationRate), polarOffsetsVec, *polarOffsetsType, Tag(*delayModelFixedParametersId,TagType::DelayModelFixedParameters));

	// Add row
	DelayModelVariableParametersRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the DelayModelVariableParametersTable" << endl;
	}
	
	// return atoi((retRow->getDelayModelVariableParametersId().getId()).c_str());
	return retRow->getDelayModelVariableParametersId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a DelayModelVariableParametersRow* given a key.
 */
int sdm_getDelayModelVariableParametersRow (int * delayModelVariableParametersId, int64_t * time, double * ut1_utc, double * iat_utc, DifferenceType * timeType, double * gstAtUt0, double * earthRotationRate, double * polarOffsets, int * polarOffsetsDim, DifferenceType * polarOffsetsType, int * delayModelFixedParametersId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	DelayModelVariableParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelVariableParametersId, TagType::DelayModelVariableParameters));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  delayModelVariableParametersId  attr.UpperCaseName: DelayModelVariableParametersId
		//  attr.NameS:  time  attr.UpperCaseName: Time
		*time     = row->getTime().get();
		//  attr.NameS:  ut1_utc  attr.UpperCaseName: Ut1_utc
		*ut1_utc = row->getUt1_utc();
		//  attr.NameS:  iat_utc  attr.UpperCaseName: Iat_utc
		*iat_utc = row->getIat_utc();
		//  attr.NameS:  timeType  attr.UpperCaseName: TimeType
		*timeType = row->getTimeType();
		//  attr.NameS:  gstAtUt0  attr.UpperCaseName: GstAtUt0
		*gstAtUt0 = row->getGstAtUt0().get();
		//  attr.NameS:  earthRotationRate  attr.UpperCaseName: EarthRotationRate
		*earthRotationRate = row->getEarthRotationRate().get();
		//  attr.NameS:  polarOffsets  attr.UpperCaseName: PolarOffsets
		
		vector<double >  polarOffsetsVec = row->getPolarOffsets();
		
		for (int i=0; i<min((int)polarOffsetsVec.size(),polarOffsetsDim[1]); i++)
			polarOffsets[i] = polarOffsetsVec[i];
		polarOffsetsDim[0] = (int)polarOffsetsVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  polarOffsetsType  attr.UpperCaseName: PolarOffsetsType
		*polarOffsetsType = row->getPolarOffsetsType();
		//  attr.NameS:  delayModelFixedParametersId  attr.UpperCaseName: DelayModelFixedParametersId
		// *delayModelFixedParametersId = atoi((row->getDelayModelFixedParametersId().getId()).c_str());
		*delayModelFixedParametersId = row->getDelayModelFixedParametersId().getTagValue();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getDelayModelVariableParametersTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getDelayModelVariableParametersKeys(int * delayModelVariableParametersId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	
	vector< DelayModelVariableParametersRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// delayModelVariableParametersId[i] = atoi((row[i]->getDelayModelVariableParametersId().getId()).c_str());
				delayModelVariableParametersId[i] = row[i]->getDelayModelVariableParametersId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter nutationInLongitude, in a row of the DelayModelVariableParameters table, given a key
 *
 */

#define sdm_addDelayModelVariableParametersNutationInLongitude  sdm_adddelaymodelvariableparametersnutationinlongitude_
extern "C" int sdm_addDelayModelVariableParametersNutationInLongitude(int * delayModelVariableParametersId, double * nutationInLongitude);

int sdm_addDelayModelVariableParametersNutationInLongitude(int * delayModelVariableParametersId, double * nutationInLongitude) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	
	DelayModelVariableParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelVariableParametersId, TagType::DelayModelVariableParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNutationInLongitude(Angle(* nutationInLongitude ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter nutationInLongitude, in a row of the DelayModelVariableParameters table, given a key
 *
 */

#define sdm_getDelayModelVariableParametersNutationInLongitude  sdm_getdelaymodelvariableparametersnutationinlongitude_
extern "C" int sdm_getDelayModelVariableParametersNutationInLongitude(int * delayModelVariableParametersId, double * nutationInLongitude);

int sdm_getDelayModelVariableParametersNutationInLongitude(int * delayModelVariableParametersId, double * nutationInLongitude) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	DelayModelVariableParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelVariableParametersId, TagType::DelayModelVariableParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNutationInLongitudeExists()) {
			*nutationInLongitude = row->getNutationInLongitude().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter nutationInLongitudeRate, in a row of the DelayModelVariableParameters table, given a key
 *
 */

#define sdm_addDelayModelVariableParametersNutationInLongitudeRate  sdm_adddelaymodelvariableparametersnutationinlongituderate_
extern "C" int sdm_addDelayModelVariableParametersNutationInLongitudeRate(int * delayModelVariableParametersId, double * nutationInLongitudeRate);

int sdm_addDelayModelVariableParametersNutationInLongitudeRate(int * delayModelVariableParametersId, double * nutationInLongitudeRate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	
	DelayModelVariableParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelVariableParametersId, TagType::DelayModelVariableParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNutationInLongitudeRate(AngularRate(* nutationInLongitudeRate ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter nutationInLongitudeRate, in a row of the DelayModelVariableParameters table, given a key
 *
 */

#define sdm_getDelayModelVariableParametersNutationInLongitudeRate  sdm_getdelaymodelvariableparametersnutationinlongituderate_
extern "C" int sdm_getDelayModelVariableParametersNutationInLongitudeRate(int * delayModelVariableParametersId, double * nutationInLongitudeRate);

int sdm_getDelayModelVariableParametersNutationInLongitudeRate(int * delayModelVariableParametersId, double * nutationInLongitudeRate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	DelayModelVariableParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelVariableParametersId, TagType::DelayModelVariableParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNutationInLongitudeRateExists()) {
			*nutationInLongitudeRate = row->getNutationInLongitudeRate().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter nutationInObliquity, in a row of the DelayModelVariableParameters table, given a key
 *
 */

#define sdm_addDelayModelVariableParametersNutationInObliquity  sdm_adddelaymodelvariableparametersnutationinobliquity_
extern "C" int sdm_addDelayModelVariableParametersNutationInObliquity(int * delayModelVariableParametersId, double * nutationInObliquity);

int sdm_addDelayModelVariableParametersNutationInObliquity(int * delayModelVariableParametersId, double * nutationInObliquity) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	
	DelayModelVariableParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelVariableParametersId, TagType::DelayModelVariableParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNutationInObliquity(Angle(* nutationInObliquity ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter nutationInObliquity, in a row of the DelayModelVariableParameters table, given a key
 *
 */

#define sdm_getDelayModelVariableParametersNutationInObliquity  sdm_getdelaymodelvariableparametersnutationinobliquity_
extern "C" int sdm_getDelayModelVariableParametersNutationInObliquity(int * delayModelVariableParametersId, double * nutationInObliquity);

int sdm_getDelayModelVariableParametersNutationInObliquity(int * delayModelVariableParametersId, double * nutationInObliquity) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	DelayModelVariableParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelVariableParametersId, TagType::DelayModelVariableParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNutationInObliquityExists()) {
			*nutationInObliquity = row->getNutationInObliquity().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter nutationInObliquityRate, in a row of the DelayModelVariableParameters table, given a key
 *
 */

#define sdm_addDelayModelVariableParametersNutationInObliquityRate  sdm_adddelaymodelvariableparametersnutationinobliquityrate_
extern "C" int sdm_addDelayModelVariableParametersNutationInObliquityRate(int * delayModelVariableParametersId, double * nutationInObliquityRate);

int sdm_addDelayModelVariableParametersNutationInObliquityRate(int * delayModelVariableParametersId, double * nutationInObliquityRate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	
	DelayModelVariableParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelVariableParametersId, TagType::DelayModelVariableParameters));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNutationInObliquityRate(AngularRate(* nutationInObliquityRate ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter nutationInObliquityRate, in a row of the DelayModelVariableParameters table, given a key
 *
 */

#define sdm_getDelayModelVariableParametersNutationInObliquityRate  sdm_getdelaymodelvariableparametersnutationinobliquityrate_
extern "C" int sdm_getDelayModelVariableParametersNutationInObliquityRate(int * delayModelVariableParametersId, double * nutationInObliquityRate);

int sdm_getDelayModelVariableParametersNutationInObliquityRate(int * delayModelVariableParametersId, double * nutationInObliquityRate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	DelayModelVariableParametersTable &table = dataset->getDelayModelVariableParameters();
	DelayModelVariableParametersRow *row = 0;
	row = table.getRowByKey( Tag(*delayModelVariableParametersId, TagType::DelayModelVariableParameters));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNutationInObliquityRateExists()) {
			*nutationInObliquityRate = row->getNutationInObliquityRate().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace DopplerReferenceCodeMod;


// =================== DopplerTable ============================

extern "C" int sdm_addDopplerRow (int * sourceId, int * transitionIndex, DopplerReferenceCode * velDef);
extern "C" int sdm_getDopplerRow (int * dopplerId, int * sourceId, int * transitionIndex, DopplerReferenceCode * velDef);


extern "C" int sdm_getDopplerTableSize ();

extern "C" int sdm_getDopplerKeys (int * dopplerId, int * sourceId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addDopplerRow (int * sourceId, int * transitionIndex, DopplerReferenceCode * velDef){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	DopplerTable &table = dataset->getDoppler();
	DopplerRow *row = 0;

	// velDef is an enumeration
	// DopplerReferenceCode * velDef =  (int) velDef;
	
	// Create new row
  
	row = table.newRow(*sourceId, *transitionIndex, *velDef);

	// Add row
	DopplerRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the DopplerTable" << endl;
	}
	
	return retRow->getDopplerId();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a DopplerRow* given a key.
 */
int sdm_getDopplerRow (int * dopplerId, int * sourceId, int * transitionIndex, DopplerReferenceCode * velDef) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	DopplerTable &table = dataset->getDoppler();
	DopplerRow *row = 0;
	row = table.getRowByKey( *dopplerId, *sourceId);
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  dopplerId  attr.UpperCaseName: DopplerId
		//  attr.NameS:  sourceId  attr.UpperCaseName: SourceId
		//  attr.NameS:  transitionIndex  attr.UpperCaseName: TransitionIndex
		*transitionIndex = row->getTransitionIndex();
		//  attr.NameS:  velDef  attr.UpperCaseName: VelDef
		*velDef = row->getVelDef();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getDopplerTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
DopplerTable &table = dataset->getDoppler();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getDopplerKeys(int * dopplerId, int * sourceId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	DopplerTable &table = dataset->getDoppler();
	
	vector< DopplerRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		dopplerId[i] = row[i]->getDopplerId();
	  		sourceId[i] = row[i]->getSourceId();
  		}
  		
		return size;
  	}
}







// =================== EphemerisTable ============================

extern "C" int sdm_addEphemerisRow (int64_t * timeInterval, int * ephemerisId, double * observerLocation, int * observerLocationDim, double * equinoxEquator, int * numPolyDir, double * dir, int * dirDim, int * numPolyDist, double * distance, int * distanceDim, int64_t * timeOrigin, char * origin, int * originDim);
extern "C" int sdm_getEphemerisRow (int64_t * timeInterval, int * ephemerisId, double * observerLocation, int * observerLocationDim, double * equinoxEquator, int * numPolyDir, double * dir, int * dirDim, int * numPolyDist, double * distance, int * distanceDim, int64_t * timeOrigin, char * origin, int * originDim);


extern "C" int sdm_getEphemerisTableSize ();

extern "C" int sdm_getEphemerisKeys (int64_t * timeInterval, int * ephemerisId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addEphemerisRow (int64_t * timeInterval, int * ephemerisId, double * observerLocation, int * observerLocationDim, double * equinoxEquator, int * numPolyDir, double * dir, int * dirDim, int * numPolyDist, double * distance, int * distanceDim, int64_t * timeOrigin, char * origin, int * originDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	EphemerisTable &table = dataset->getEphemeris();
	EphemerisRow *row = 0;

	// observerLocation is an Array
	// observerLocation is OneD
	vector<double >  observerLocationVec(observerLocationDim[0]);
	for (int i=0;i<observerLocationDim[0];i++)
		observerLocationVec[i]= double(observerLocation[i]   );
	// dir is an Array
	// dir is 2 D
	vector<vector<double > >  dirVec(dirDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<dirDim[2];i++) {
		dirVec[i].resize(dirDim[0]);
		for (int j=0;j<dirDim[0];j++)
			dirVec[i][j]= double(dir[i*dirDim[1]+j]  );
	
	
	}
	// distance is an Array
	// distance is OneD
	vector<double >  distanceVec(distanceDim[0]);
	for (int i=0;i<distanceDim[0];i++)
		distanceVec[i]= double(distance[i]   );
	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *ephemerisId, observerLocationVec, *equinoxEquator, *numPolyDir, dirVec, *numPolyDist, distanceVec, ArrayTime(*timeOrigin), string(origin));
	} else {
		row = table.newRow(ArrayTimeInterval(*timeInterval), *ephemerisId, observerLocationVec, *equinoxEquator, *numPolyDir, dirVec, *numPolyDist, distanceVec, ArrayTime(*timeOrigin), string(origin));
	}

	// Add row
	EphemerisRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the EphemerisTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a EphemerisRow* given a key.
 */
int sdm_getEphemerisRow (int64_t * timeInterval, int * ephemerisId, double * observerLocation, int * observerLocationDim, double * equinoxEquator, int * numPolyDir, double * dir, int * dirDim, int * numPolyDist, double * distance, int * distanceDim, int64_t * timeOrigin, char * origin, int * originDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	EphemerisTable &table = dataset->getEphemeris();
	EphemerisRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *ephemerisId);
	else
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval), *ephemerisId);
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  ephemerisId  attr.UpperCaseName: EphemerisId
		//  attr.NameS:  observerLocation  attr.UpperCaseName: ObserverLocation
		
		vector<double >  observerLocationVec = row->getObserverLocation();
		
		for (int i=0; i<min((int)observerLocationVec.size(),observerLocationDim[1]); i++)
			observerLocation[i] = observerLocationVec[i];
		observerLocationDim[0] = (int)observerLocationVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  equinoxEquator  attr.UpperCaseName: EquinoxEquator
		*equinoxEquator = row->getEquinoxEquator();
		//  attr.NameS:  numPolyDir  attr.UpperCaseName: NumPolyDir
		*numPolyDir = row->getNumPolyDir();
		//  attr.NameS:  dir  attr.UpperCaseName: Dir
		
		vector<vector<double > >  dirVec = row->getDir();
		
		int maxDimZeroDir = 0;
		for (int i=0;i<min((int)dirVec.size(),dirDim[3]) ;i++) {
			maxDimZeroDir = max((int)dirVec[i].size(),maxDimZeroDir);
			for (int j=0;j<min((int)dirVec[i].size(),dirDim[1]) ;j++) {
				dir[i*dirDim[1]+j]= dirVec[i][j];
			}
		}
		dirDim[0] = maxDimZeroDir;
		dirDim[2] = dirVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  numPolyDist  attr.UpperCaseName: NumPolyDist
		*numPolyDist = row->getNumPolyDist();
		//  attr.NameS:  distance  attr.UpperCaseName: Distance
		
		vector<double >  distanceVec = row->getDistance();
		
		for (int i=0; i<min((int)distanceVec.size(),distanceDim[1]); i++)
			distance[i] = distanceVec[i];
		distanceDim[0] = (int)distanceVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  timeOrigin  attr.UpperCaseName: TimeOrigin
		*timeOrigin     = row->getTimeOrigin().get();
		//  attr.NameS:  origin  attr.UpperCaseName: Origin
		if ((int)row->getOrigin().size()<originDim[1])
			strcpy(origin,row->getOrigin().c_str());
		else
			strncpy(origin,row->getOrigin().c_str(),originDim[1]);
		originDim[0] = (int)row->getOrigin().size();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getEphemerisTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
EphemerisTable &table = dataset->getEphemeris();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getEphemerisKeys(int64_t * timeInterval, int * ephemerisId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	EphemerisTable &table = dataset->getEphemeris();
	
	vector< EphemerisRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
	  		ephemerisId[i] = row[i]->getEphemerisId();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter numPolyRadVel, in a row of the Ephemeris table, given a key
 *
 */

#define sdm_addEphemerisNumPolyRadVel  sdm_addephemerisnumpolyradvel_
extern "C" int sdm_addEphemerisNumPolyRadVel(int64_t * timeInterval, int * ephemerisId, int * numPolyRadVel);

int sdm_addEphemerisNumPolyRadVel(int64_t * timeInterval, int * ephemerisId, int * numPolyRadVel) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	EphemerisTable &table = dataset->getEphemeris();
	
	EphemerisRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *ephemerisId);
	else
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval), *ephemerisId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumPolyRadVel(int(* numPolyRadVel ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numPolyRadVel, in a row of the Ephemeris table, given a key
 *
 */

#define sdm_getEphemerisNumPolyRadVel  sdm_getephemerisnumpolyradvel_
extern "C" int sdm_getEphemerisNumPolyRadVel(int64_t * timeInterval, int * ephemerisId, int * numPolyRadVel);

int sdm_getEphemerisNumPolyRadVel(int64_t * timeInterval, int * ephemerisId, int * numPolyRadVel) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	EphemerisTable &table = dataset->getEphemeris();
	EphemerisRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *ephemerisId);
	else
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval), *ephemerisId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumPolyRadVelExists()) {
			*numPolyRadVel = row->getNumPolyRadVel();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter radVel, in a row of the Ephemeris table, given a key
 *
 */

#define sdm_addEphemerisRadVel  sdm_addephemerisradvel_
extern "C" int sdm_addEphemerisRadVel(int64_t * timeInterval, int * ephemerisId, double * radVel, int * radVelDim);

int sdm_addEphemerisRadVel(int64_t * timeInterval, int * ephemerisId, double * radVel, int * radVelDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	EphemerisTable &table = dataset->getEphemeris();
	
	EphemerisRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *ephemerisId);
	else
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval), *ephemerisId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<double >  radVelVec(radVelDim[0]);
		for (int i=0;i<radVelDim[0];i++)
			radVelVec[i]= double(radVel[i] );
		row->setRadVel(radVelVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter radVel, in a row of the Ephemeris table, given a key
 *
 */

#define sdm_getEphemerisRadVel  sdm_getephemerisradvel_
extern "C" int sdm_getEphemerisRadVel(int64_t * timeInterval, int * ephemerisId, double * radVel, int * radVelDim);

int sdm_getEphemerisRadVel(int64_t * timeInterval, int * ephemerisId, double * radVel, int * radVelDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	EphemerisTable &table = dataset->getEphemeris();
	EphemerisRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *ephemerisId);
	else
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval), *ephemerisId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isRadVelExists()) {
			// attr.CppType: vector<double > attr.isOneD: true
			for (int i=0; i<min((int)row->getRadVel().size(),radVelDim[1]); i++)
				radVel[i] = row->getRadVel()[i];
			radVelDim[0] = (int)row->getRadVel().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}




// =================== ExecBlockTable ============================

extern "C" int sdm_addExecBlockRow (int64_t * startTime, int64_t * endTime, int * execBlockNum, char * execBlockUID, int * execBlockUIDDim, char * projectUID, int * projectUIDDim, char * configName, int * configNameDim, char * telescopeName, int * telescopeNameDim, char * observerName, int * observerNameDim, int * numObservingLog, char * observingLog, int * observingLogDim, char * sessionReference, int * sessionReferenceDim, double * baseRangeMin, double * baseRangeMax, double * baseRmsMinor, double * baseRmsMajor, double * basePa, bool * aborted, int * numAntenna, int * antennaId, int * antennaIdDim, int * sBSummaryId);
extern "C" int sdm_getExecBlockRow (int * execBlockId, int64_t * startTime, int64_t * endTime, int * execBlockNum, char * execBlockUID, int * execBlockUIDDim, char * projectUID, int * projectUIDDim, char * configName, int * configNameDim, char * telescopeName, int * telescopeNameDim, char * observerName, int * observerNameDim, int * numObservingLog, char * observingLog, int * observingLogDim, char * sessionReference, int * sessionReferenceDim, double * baseRangeMin, double * baseRangeMax, double * baseRmsMinor, double * baseRmsMajor, double * basePa, bool * aborted, int * numAntenna, int * antennaId, int * antennaIdDim, int * sBSummaryId);


extern "C" int sdm_getExecBlockTableSize ();

extern "C" int sdm_getExecBlockKeys (int * execBlockId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addExecBlockRow (int64_t * startTime, int64_t * endTime, int * execBlockNum, char * execBlockUID, int * execBlockUIDDim, char * projectUID, int * projectUIDDim, char * configName, int * configNameDim, char * telescopeName, int * telescopeNameDim, char * observerName, int * observerNameDim, int * numObservingLog, char * observingLog, int * observingLogDim, char * sessionReference, int * sessionReferenceDim, double * baseRangeMin, double * baseRangeMax, double * baseRmsMinor, double * baseRmsMajor, double * basePa, bool * aborted, int * numAntenna, int * antennaId, int * antennaIdDim, int * sBSummaryId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	ExecBlockTable &table = dataset->getExecBlock();
	ExecBlockRow *row = 0;

	// observingLog is an Array
	// observingLog is OneD
	vector<string >  observingLogVec(observingLogDim[2]);
	for (int i=0;i<observingLogDim[2];i++)
		observingLogVec[i]= string(observingLog+i*observingLogDim[1]  );
	// antennaId is an Array
	// antennaId is OneD
	vector<Tag>   antennaIdVec(antennaIdDim[0]);
	for (int i=0;i<antennaIdDim[0];i++)
		antennaIdVec[i]= Tag(antennaId[i]   , TagType::Antenna);
	
	// Create new row
  
	row = table.newRow(ArrayTime(*startTime), ArrayTime(*endTime), *execBlockNum, EntityRef(string(execBlockUID)), EntityRef(string(projectUID)), string(configName), string(telescopeName), string(observerName), *numObservingLog, observingLogVec, EntityRef(string(sessionReference)), Length(*baseRangeMin), Length(*baseRangeMax), Length(*baseRmsMinor), Length(*baseRmsMajor), Angle(*basePa), *aborted, *numAntenna, antennaIdVec, Tag(*sBSummaryId,TagType::SBSummary));

	// Add row
	ExecBlockRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the ExecBlockTable" << endl;
	}
	
	// return atoi((retRow->getExecBlockId().getId()).c_str());
	return retRow->getExecBlockId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a ExecBlockRow* given a key.
 */
int sdm_getExecBlockRow (int * execBlockId, int64_t * startTime, int64_t * endTime, int * execBlockNum, char * execBlockUID, int * execBlockUIDDim, char * projectUID, int * projectUIDDim, char * configName, int * configNameDim, char * telescopeName, int * telescopeNameDim, char * observerName, int * observerNameDim, int * numObservingLog, char * observingLog, int * observingLogDim, char * sessionReference, int * sessionReferenceDim, double * baseRangeMin, double * baseRangeMax, double * baseRmsMinor, double * baseRmsMajor, double * basePa, bool * aborted, int * numAntenna, int * antennaId, int * antennaIdDim, int * sBSummaryId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ExecBlockTable &table = dataset->getExecBlock();
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  execBlockId  attr.UpperCaseName: ExecBlockId
		//  attr.NameS:  startTime  attr.UpperCaseName: StartTime
		*startTime     = row->getStartTime().get();
		//  attr.NameS:  endTime  attr.UpperCaseName: EndTime
		*endTime     = row->getEndTime().get();
		//  attr.NameS:  execBlockNum  attr.UpperCaseName: ExecBlockNum
		*execBlockNum = row->getExecBlockNum();
		//  attr.NameS:  execBlockUID  attr.UpperCaseName: ExecBlockUID
		strcpy(execBlockUID,row->getExecBlockUID().toString().c_str());
		//  attr.NameS:  projectUID  attr.UpperCaseName: ProjectUID
		strcpy(projectUID,row->getProjectUID().toString().c_str());
		//  attr.NameS:  configName  attr.UpperCaseName: ConfigName
		if ((int)row->getConfigName().size()<configNameDim[1])
			strcpy(configName,row->getConfigName().c_str());
		else
			strncpy(configName,row->getConfigName().c_str(),configNameDim[1]);
		configNameDim[0] = (int)row->getConfigName().size();
		//  attr.NameS:  telescopeName  attr.UpperCaseName: TelescopeName
		if ((int)row->getTelescopeName().size()<telescopeNameDim[1])
			strcpy(telescopeName,row->getTelescopeName().c_str());
		else
			strncpy(telescopeName,row->getTelescopeName().c_str(),telescopeNameDim[1]);
		telescopeNameDim[0] = (int)row->getTelescopeName().size();
		//  attr.NameS:  observerName  attr.UpperCaseName: ObserverName
		if ((int)row->getObserverName().size()<observerNameDim[1])
			strcpy(observerName,row->getObserverName().c_str());
		else
			strncpy(observerName,row->getObserverName().c_str(),observerNameDim[1]);
		observerNameDim[0] = (int)row->getObserverName().size();
		//  attr.NameS:  numObservingLog  attr.UpperCaseName: NumObservingLog
		*numObservingLog = row->getNumObservingLog();
		//  attr.NameS:  observingLog  attr.UpperCaseName: ObservingLog
		
		vector<string >  observingLogVec = row->getObservingLog();
		
		int maxDimZeroObservingLog = 0;
		for (int i=0; i<min((int)observingLogVec.size(),observingLogDim[3]); i++) {
			if ((int)observingLogVec[i].size()<observingLogDim[1])
				strcpy(observingLog+i*observingLogDim[1],observingLogVec[i].c_str());
			else
				strncpy(observingLog+i*observingLogDim[1],observingLogVec[i].c_str(),observingLogDim[1]);
			maxDimZeroObservingLog = max((int)observingLogVec[i].size(),maxDimZeroObservingLog);
		}
		observingLogDim[0] = maxDimZeroObservingLog;
		observingLogDim[2] = observingLogVec.size();  // number of strings
		
		
		//  attr.NameS:  sessionReference  attr.UpperCaseName: SessionReference
		strcpy(sessionReference,row->getSessionReference().toString().c_str());
		//  attr.NameS:  baseRangeMin  attr.UpperCaseName: BaseRangeMin
		*baseRangeMin = row->getBaseRangeMin().get();
		//  attr.NameS:  baseRangeMax  attr.UpperCaseName: BaseRangeMax
		*baseRangeMax = row->getBaseRangeMax().get();
		//  attr.NameS:  baseRmsMinor  attr.UpperCaseName: BaseRmsMinor
		*baseRmsMinor = row->getBaseRmsMinor().get();
		//  attr.NameS:  baseRmsMajor  attr.UpperCaseName: BaseRmsMajor
		*baseRmsMajor = row->getBaseRmsMajor().get();
		//  attr.NameS:  basePa  attr.UpperCaseName: BasePa
		*basePa = row->getBasePa().get();
		//  attr.NameS:  aborted  attr.UpperCaseName: Aborted
		*aborted = row->getAborted();
		//  attr.NameS:  numAntenna  attr.UpperCaseName: NumAntenna
		*numAntenna = row->getNumAntenna();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		
		vector<Tag>   antennaIdVec = row->getAntennaId();
		
		for (int i=0; i<min((int)antennaIdVec.size(),antennaIdDim[1]); i++)
			//antennaId[i] = atoi((row->getAntennaId()[i]).getId().c_str());
		antennaId[i] = antennaIdVec[i].getTagValue();
		antennaIdDim[0] = (int)antennaIdVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  sBSummaryId  attr.UpperCaseName: SBSummaryId
		// *sBSummaryId = atoi((row->getSBSummaryId().getId()).c_str());
		*sBSummaryId = row->getSBSummaryId().getTagValue();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getExecBlockTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
ExecBlockTable &table = dataset->getExecBlock();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getExecBlockKeys(int * execBlockId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	ExecBlockTable &table = dataset->getExecBlock();
	
	vector< ExecBlockRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// execBlockId[i] = atoi((row[i]->getExecBlockId().getId()).c_str());
				execBlockId[i] = row[i]->getExecBlockId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter releaseDate, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_addExecBlockReleaseDate  sdm_addexecblockreleasedate_
extern "C" int sdm_addExecBlockReleaseDate(int * execBlockId, int64_t * releaseDate);

int sdm_addExecBlockReleaseDate(int * execBlockId, int64_t * releaseDate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ExecBlockTable &table = dataset->getExecBlock();
	
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setReleaseDate(ArrayTime(* releaseDate ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter releaseDate, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_getExecBlockReleaseDate  sdm_getexecblockreleasedate_
extern "C" int sdm_getExecBlockReleaseDate(int * execBlockId, int64_t * releaseDate);

int sdm_getExecBlockReleaseDate(int * execBlockId, int64_t * releaseDate) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ExecBlockTable &table = dataset->getExecBlock();
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isReleaseDateExists()) {
			*releaseDate     = row->getReleaseDate().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter schedulerMode, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_addExecBlockSchedulerMode  sdm_addexecblockschedulermode_
extern "C" int sdm_addExecBlockSchedulerMode(int * execBlockId, char * schedulerMode, int * schedulerModeDim);

int sdm_addExecBlockSchedulerMode(int * execBlockId, char * schedulerMode, int * schedulerModeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ExecBlockTable &table = dataset->getExecBlock();
	
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSchedulerMode(string(schedulerMode));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter schedulerMode, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_getExecBlockSchedulerMode  sdm_getexecblockschedulermode_
extern "C" int sdm_getExecBlockSchedulerMode(int * execBlockId, char * schedulerMode, int * schedulerModeDim);

int sdm_getExecBlockSchedulerMode(int * execBlockId, char * schedulerMode, int * schedulerModeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ExecBlockTable &table = dataset->getExecBlock();
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSchedulerModeExists()) {
			if ((int)row->getSchedulerMode().size()<schedulerModeDim[1])
				strcpy(schedulerMode,row->getSchedulerMode().c_str());
			else
				strncpy(schedulerMode,row->getSchedulerMode().c_str(),schedulerModeDim[1]);
			schedulerModeDim[0] = (int)row->getSchedulerMode().size();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter siteAltitude, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_addExecBlockSiteAltitude  sdm_addexecblocksitealtitude_
extern "C" int sdm_addExecBlockSiteAltitude(int * execBlockId, double * siteAltitude);

int sdm_addExecBlockSiteAltitude(int * execBlockId, double * siteAltitude) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ExecBlockTable &table = dataset->getExecBlock();
	
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSiteAltitude(Length(* siteAltitude ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter siteAltitude, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_getExecBlockSiteAltitude  sdm_getexecblocksitealtitude_
extern "C" int sdm_getExecBlockSiteAltitude(int * execBlockId, double * siteAltitude);

int sdm_getExecBlockSiteAltitude(int * execBlockId, double * siteAltitude) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ExecBlockTable &table = dataset->getExecBlock();
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSiteAltitudeExists()) {
			*siteAltitude = row->getSiteAltitude().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter siteLongitude, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_addExecBlockSiteLongitude  sdm_addexecblocksitelongitude_
extern "C" int sdm_addExecBlockSiteLongitude(int * execBlockId, double * siteLongitude);

int sdm_addExecBlockSiteLongitude(int * execBlockId, double * siteLongitude) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ExecBlockTable &table = dataset->getExecBlock();
	
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSiteLongitude(Angle(* siteLongitude ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter siteLongitude, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_getExecBlockSiteLongitude  sdm_getexecblocksitelongitude_
extern "C" int sdm_getExecBlockSiteLongitude(int * execBlockId, double * siteLongitude);

int sdm_getExecBlockSiteLongitude(int * execBlockId, double * siteLongitude) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ExecBlockTable &table = dataset->getExecBlock();
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSiteLongitudeExists()) {
			*siteLongitude = row->getSiteLongitude().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter siteLatitude, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_addExecBlockSiteLatitude  sdm_addexecblocksitelatitude_
extern "C" int sdm_addExecBlockSiteLatitude(int * execBlockId, double * siteLatitude);

int sdm_addExecBlockSiteLatitude(int * execBlockId, double * siteLatitude) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ExecBlockTable &table = dataset->getExecBlock();
	
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSiteLatitude(Angle(* siteLatitude ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter siteLatitude, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_getExecBlockSiteLatitude  sdm_getexecblocksitelatitude_
extern "C" int sdm_getExecBlockSiteLatitude(int * execBlockId, double * siteLatitude);

int sdm_getExecBlockSiteLatitude(int * execBlockId, double * siteLatitude) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ExecBlockTable &table = dataset->getExecBlock();
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSiteLatitudeExists()) {
			*siteLatitude = row->getSiteLatitude().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter observingScript, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_addExecBlockObservingScript  sdm_addexecblockobservingscript_
extern "C" int sdm_addExecBlockObservingScript(int * execBlockId, char * observingScript, int * observingScriptDim);

int sdm_addExecBlockObservingScript(int * execBlockId, char * observingScript, int * observingScriptDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ExecBlockTable &table = dataset->getExecBlock();
	
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setObservingScript(string(observingScript));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter observingScript, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_getExecBlockObservingScript  sdm_getexecblockobservingscript_
extern "C" int sdm_getExecBlockObservingScript(int * execBlockId, char * observingScript, int * observingScriptDim);

int sdm_getExecBlockObservingScript(int * execBlockId, char * observingScript, int * observingScriptDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ExecBlockTable &table = dataset->getExecBlock();
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isObservingScriptExists()) {
			if ((int)row->getObservingScript().size()<observingScriptDim[1])
				strcpy(observingScript,row->getObservingScript().c_str());
			else
				strncpy(observingScript,row->getObservingScript().c_str(),observingScriptDim[1]);
			observingScriptDim[0] = (int)row->getObservingScript().size();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter observingScriptUID, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_addExecBlockObservingScriptUID  sdm_addexecblockobservingscriptuid_
extern "C" int sdm_addExecBlockObservingScriptUID(int * execBlockId, char * observingScriptUID);

int sdm_addExecBlockObservingScriptUID(int * execBlockId, char * observingScriptUID) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ExecBlockTable &table = dataset->getExecBlock();
	
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setObservingScriptUID(EntityRef(observingScriptUID));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter observingScriptUID, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_getExecBlockObservingScriptUID  sdm_getexecblockobservingscriptuid_
extern "C" int sdm_getExecBlockObservingScriptUID(int * execBlockId, char * observingScriptUID);

int sdm_getExecBlockObservingScriptUID(int * execBlockId, char * observingScriptUID) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ExecBlockTable &table = dataset->getExecBlock();
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isObservingScriptUIDExists()) {
			strcpy(observingScriptUID,row->getObservingScriptUID().toString().c_str());
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter scaleId, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_addExecBlockScaleId  sdm_addexecblockscaleid_
extern "C" int sdm_addExecBlockScaleId(int * execBlockId, int * scaleId);

int sdm_addExecBlockScaleId(int * execBlockId, int * scaleId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ExecBlockTable &table = dataset->getExecBlock();
	
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setScaleId(Tag(* scaleId , TagType::Scale));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter scaleId, in a row of the ExecBlock table, given a key
 *
 */

#define sdm_getExecBlockScaleId  sdm_getexecblockscaleid_
extern "C" int sdm_getExecBlockScaleId(int * execBlockId, int * scaleId);

int sdm_getExecBlockScaleId(int * execBlockId, int * scaleId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ExecBlockTable &table = dataset->getExecBlock();
	ExecBlockRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isScaleIdExists()) {
			// *scaleId = atoi((row->getScaleId().getId()).c_str());
			*scaleId = row->getScaleId().getTagValue();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace PolarizationTypeMod;


// =================== FeedTable ============================

extern "C" int sdm_addFeedRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numReceptor, double * beamOffset, int * beamOffsetDim, double * focusReference, int * focusReferenceDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, Complex * polResponse, int * polResponseDim, double * receptorAngle, int * receptorAngleDim, int * receiverId, int * receiverIdDim);
extern "C" int sdm_getFeedRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor, double * beamOffset, int * beamOffsetDim, double * focusReference, int * focusReferenceDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, Complex * polResponse, int * polResponseDim, double * receptorAngle, int * receptorAngleDim, int * receiverId, int * receiverIdDim);


extern "C" int sdm_getFeedTableSize ();

extern "C" int sdm_getFeedKeys (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addFeedRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * numReceptor, double * beamOffset, int * beamOffsetDim, double * focusReference, int * focusReferenceDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, Complex * polResponse, int * polResponseDim, double * receptorAngle, int * receptorAngleDim, int * receiverId, int * receiverIdDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	FeedTable &table = dataset->getFeed();
	FeedRow *row = 0;

	// beamOffset is an Array
	// beamOffset is 2 D
	vector<vector<double > >  beamOffsetVec(beamOffsetDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<beamOffsetDim[2];i++) {
		beamOffsetVec[i].resize(beamOffsetDim[0]);
		for (int j=0;j<beamOffsetDim[0];j++)
			beamOffsetVec[i][j]= double(beamOffset[i*beamOffsetDim[1]+j]  );
	
	
	}
	// focusReference is an Array
	// focusReference is 2 D
	vector<vector<Length > >  focusReferenceVec(focusReferenceDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<focusReferenceDim[2];i++) {
		focusReferenceVec[i].resize(focusReferenceDim[0]);
		for (int j=0;j<focusReferenceDim[0];j++)
			focusReferenceVec[i][j]= Length(focusReference[i*focusReferenceDim[1]+j]  );
	
	
	}
	// polarizationTypes is an Array
	// polarizationTypes is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec(polarizationTypesDim[0]);
	for (int i=0;i<polarizationTypesDim[0];i++)
		polarizationTypesVec[i]= PolarizationType(polarizationTypes[i]   );
	// polResponse is an Array
	// polResponse is 2 D
	vector<vector<Complex > >  polResponseVec(polResponseDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<polResponseDim[2];i++) {
		polResponseVec[i].resize(polResponseDim[0]);
		for (int j=0;j<polResponseDim[0];j++)
			polResponseVec[i][j]= Complex(polResponse[i*polResponseDim[1]+j]  );
	
	
	}
	// receptorAngle is an Array
	// receptorAngle is OneD
	vector<Angle >  receptorAngleVec(receptorAngleDim[0]);
	for (int i=0;i<receptorAngleDim[0];i++)
		receptorAngleVec[i]= Angle(receptorAngle[i]   );
	// receiverId is an Array
	// receiverId is OneD
	vector<int>   receiverIdVec(receiverIdDim[0]);
	for (int i=0;i<receiverIdDim[0];i++)
		receiverIdVec[i]= int(receiverId[i]   );
	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *numReceptor, beamOffsetVec, focusReferenceVec, polarizationTypesVec, polResponseVec, receptorAngleVec, receiverIdVec);
	} else {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *numReceptor, beamOffsetVec, focusReferenceVec, polarizationTypesVec, polResponseVec, receptorAngleVec, receiverIdVec);
	}

	// Add row
	FeedRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the FeedTable" << endl;
	}
	
	return retRow->getFeedId();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a FeedRow* given a key.
 */
int sdm_getFeedRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor, double * beamOffset, int * beamOffsetDim, double * focusReference, int * focusReferenceDim, PolarizationType * polarizationTypes, int * polarizationTypesDim, Complex * polResponse, int * polResponseDim, double * receptorAngle, int * receptorAngleDim, int * receiverId, int * receiverIdDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FeedTable &table = dataset->getFeed();
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  feedId  attr.UpperCaseName: FeedId
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  beamOffset  attr.UpperCaseName: BeamOffset
		
		vector<vector<double > >  beamOffsetVec = row->getBeamOffset();
		
		int maxDimZeroBeamOffset = 0;
		for (int i=0;i<min((int)beamOffsetVec.size(),beamOffsetDim[3]) ;i++) {
			maxDimZeroBeamOffset = max((int)beamOffsetVec[i].size(),maxDimZeroBeamOffset);
			for (int j=0;j<min((int)beamOffsetVec[i].size(),beamOffsetDim[1]) ;j++) {
				beamOffset[i*beamOffsetDim[1]+j]= beamOffsetVec[i][j];
			}
		}
		beamOffsetDim[0] = maxDimZeroBeamOffset;
		beamOffsetDim[2] = beamOffsetVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  focusReference  attr.UpperCaseName: FocusReference
		
		vector<vector<Length > >  focusReferenceVec = row->getFocusReference();
		
		int maxDimZeroFocusReference = 0;
		for (int i=0; i< min((int)focusReferenceVec.size(),focusReferenceDim[3]) ;i++) {
			maxDimZeroFocusReference = max((int)focusReferenceVec[i].size(),maxDimZeroFocusReference);
			for (int j=0; j<min((int)focusReferenceVec[i].size(),focusReferenceDim[1]) ;j++) {
				focusReference[i*focusReferenceDim[1]+j] = focusReferenceVec[i][j].get();
			}
		}
		focusReferenceDim[0] = maxDimZeroFocusReference;
		focusReferenceDim[2] = focusReferenceVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  polarizationTypes  attr.UpperCaseName: PolarizationTypes
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypesVec = row->getPolarizationTypes();
		
		for (int i=0; i<min((int)polarizationTypesVec.size(),polarizationTypesDim[1]); i++)
			polarizationTypes[i] = polarizationTypesVec[i];
		polarizationTypesDim[0] = (int)polarizationTypesVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  polResponse  attr.UpperCaseName: PolResponse
		
		vector<vector<Complex > >  polResponseVec = row->getPolResponse();
		
		int maxDimZeroPolResponse = 0;
		for (int i=0;i<min((int)polResponseVec.size(),polResponseDim[3]) ;i++) {
			maxDimZeroPolResponse = max((int)polResponseVec[i].size(),maxDimZeroPolResponse);
			for (int j=0;j<min((int)polResponseVec[i].size(),polResponseDim[1]) ;j++) {
				polResponse[i*polResponseDim[1]+j]= polResponseVec[i][j];
			}
		}
		polResponseDim[0] = maxDimZeroPolResponse;
		polResponseDim[2] = polResponseVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  receptorAngle  attr.UpperCaseName: ReceptorAngle
		
		vector<Angle >  receptorAngleVec = row->getReceptorAngle();
		
		for (int i=0; i<min((int)receptorAngleVec.size(),receptorAngleDim[1]); i++)
			receptorAngle[i] = receptorAngleVec[i].get();
		receptorAngleDim[0] = receptorAngleVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  receiverId  attr.UpperCaseName: ReceiverId
		
		vector<int>   receiverIdVec = row->getReceiverId();
		
		for (int i=0; i<min((int)receiverIdVec.size(),receiverIdDim[1]); i++)
			receiverId[i] = receiverIdVec[i];
		receiverIdDim[0] = (int)receiverIdVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getFeedTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
FeedTable &table = dataset->getFeed();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getFeedKeys(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	FeedTable &table = dataset->getFeed();
	
	vector< FeedRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		// spectralWindowId[i] = atoi((row[i]->getSpectralWindowId().getId()).c_str());
				spectralWindowId[i] = row[i]->getSpectralWindowId().getTagValue();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
	  		feedId[i] = row[i]->getFeedId();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter feedNum, in a row of the Feed table, given a key
 *
 */

#define sdm_addFeedFeedNum  sdm_addfeedfeednum_
extern "C" int sdm_addFeedFeedNum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * feedNum);

int sdm_addFeedFeedNum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * feedNum) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FeedTable &table = dataset->getFeed();
	
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setFeedNum(int(* feedNum ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter feedNum, in a row of the Feed table, given a key
 *
 */

#define sdm_getFeedFeedNum  sdm_getfeedfeednum_
extern "C" int sdm_getFeedFeedNum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * feedNum);

int sdm_getFeedFeedNum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * feedNum) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FeedTable &table = dataset->getFeed();
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFeedNumExists()) {
			*feedNum = row->getFeedNum();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter illumOffset, in a row of the Feed table, given a key
 *
 */

#define sdm_addFeedIllumOffset  sdm_addfeedillumoffset_
extern "C" int sdm_addFeedIllumOffset(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * illumOffset, int * illumOffsetDim);

int sdm_addFeedIllumOffset(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * illumOffset, int * illumOffsetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FeedTable &table = dataset->getFeed();
	
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  illumOffsetVec(illumOffsetDim[0]);
		for (int i=0;i<illumOffsetDim[0];i++)
			illumOffsetVec[i]= Length(illumOffset[i] );
		row->setIllumOffset(illumOffsetVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter illumOffset, in a row of the Feed table, given a key
 *
 */

#define sdm_getFeedIllumOffset  sdm_getfeedillumoffset_
extern "C" int sdm_getFeedIllumOffset(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * illumOffset, int * illumOffsetDim);

int sdm_getFeedIllumOffset(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * illumOffset, int * illumOffsetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FeedTable &table = dataset->getFeed();
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isIllumOffsetExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getIllumOffset().size(),illumOffsetDim[1]); i++)
				illumOffset[i] = row->getIllumOffset()[i].get();
			illumOffsetDim[0] = row->getIllumOffset().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter position, in a row of the Feed table, given a key
 *
 */

#define sdm_addFeedPosition  sdm_addfeedposition_
extern "C" int sdm_addFeedPosition(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * position, int * positionDim);

int sdm_addFeedPosition(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * position, int * positionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FeedTable &table = dataset->getFeed();
	
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  positionVec(positionDim[0]);
		for (int i=0;i<positionDim[0];i++)
			positionVec[i]= Length(position[i] );
		row->setPosition(positionVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter position, in a row of the Feed table, given a key
 *
 */

#define sdm_getFeedPosition  sdm_getfeedposition_
extern "C" int sdm_getFeedPosition(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * position, int * positionDim);

int sdm_getFeedPosition(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * position, int * positionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FeedTable &table = dataset->getFeed();
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPositionExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getPosition().size(),positionDim[1]); i++)
				position[i] = row->getPosition()[i].get();
			positionDim[0] = row->getPosition().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter skyCoupling, in a row of the Feed table, given a key
 *
 */

#define sdm_addFeedSkyCoupling  sdm_addfeedskycoupling_
extern "C" int sdm_addFeedSkyCoupling(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * skyCoupling);

int sdm_addFeedSkyCoupling(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * skyCoupling) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FeedTable &table = dataset->getFeed();
	
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSkyCoupling(float(* skyCoupling ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter skyCoupling, in a row of the Feed table, given a key
 *
 */

#define sdm_getFeedSkyCoupling  sdm_getfeedskycoupling_
extern "C" int sdm_getFeedSkyCoupling(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * skyCoupling);

int sdm_getFeedSkyCoupling(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * skyCoupling) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FeedTable &table = dataset->getFeed();
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSkyCouplingExists()) {
			*skyCoupling = row->getSkyCoupling();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numChan, in a row of the Feed table, given a key
 *
 */

#define sdm_addFeedNumChan  sdm_addfeednumchan_
extern "C" int sdm_addFeedNumChan(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numChan);

int sdm_addFeedNumChan(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numChan) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FeedTable &table = dataset->getFeed();
	
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumChan(int(* numChan ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numChan, in a row of the Feed table, given a key
 *
 */

#define sdm_getFeedNumChan  sdm_getfeednumchan_
extern "C" int sdm_getFeedNumChan(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numChan);

int sdm_getFeedNumChan(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numChan) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FeedTable &table = dataset->getFeed();
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumChanExists()) {
			*numChan = row->getNumChan();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter skyCouplingSpectrum, in a row of the Feed table, given a key
 *
 */

#define sdm_addFeedSkyCouplingSpectrum  sdm_addfeedskycouplingspectrum_
extern "C" int sdm_addFeedSkyCouplingSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * skyCouplingSpectrum, int * skyCouplingSpectrumDim);

int sdm_addFeedSkyCouplingSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * skyCouplingSpectrum, int * skyCouplingSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FeedTable &table = dataset->getFeed();
	
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<float >  skyCouplingSpectrumVec(skyCouplingSpectrumDim[0]);
		for (int i=0;i<skyCouplingSpectrumDim[0];i++)
			skyCouplingSpectrumVec[i]= float(skyCouplingSpectrum[i] );
		row->setSkyCouplingSpectrum(skyCouplingSpectrumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter skyCouplingSpectrum, in a row of the Feed table, given a key
 *
 */

#define sdm_getFeedSkyCouplingSpectrum  sdm_getfeedskycouplingspectrum_
extern "C" int sdm_getFeedSkyCouplingSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * skyCouplingSpectrum, int * skyCouplingSpectrumDim);

int sdm_getFeedSkyCouplingSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * skyCouplingSpectrum, int * skyCouplingSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FeedTable &table = dataset->getFeed();
	FeedRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSkyCouplingSpectrumExists()) {
			// attr.CppType: vector<float > attr.isOneD: true
			for (int i=0; i<min((int)row->getSkyCouplingSpectrum().size(),skyCouplingSpectrumDim[1]); i++)
				skyCouplingSpectrum[i] = row->getSkyCouplingSpectrum()[i];
			skyCouplingSpectrumDim[0] = (int)row->getSkyCouplingSpectrum().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace DirectionReferenceCodeMod;


// =================== FieldTable ============================

extern "C" int sdm_addFieldRow (char * fieldName, int * fieldNameDim, int * numPoly, double * delayDir, int * delayDirDim, double * phaseDir, int * phaseDirDim, double * referenceDir, int * referenceDirDim);
extern "C" int sdm_getFieldRow (int * fieldId, char * fieldName, int * fieldNameDim, int * numPoly, double * delayDir, int * delayDirDim, double * phaseDir, int * phaseDirDim, double * referenceDir, int * referenceDirDim);


extern "C" int sdm_getFieldTableSize ();

extern "C" int sdm_getFieldKeys (int * fieldId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addFieldRow (char * fieldName, int * fieldNameDim, int * numPoly, double * delayDir, int * delayDirDim, double * phaseDir, int * phaseDirDim, double * referenceDir, int * referenceDirDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	FieldTable &table = dataset->getField();
	FieldRow *row = 0;

	// delayDir is an Array
	// delayDir is 2 D
	vector<vector<Angle > >  delayDirVec(delayDirDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<delayDirDim[2];i++) {
		delayDirVec[i].resize(delayDirDim[0]);
		for (int j=0;j<delayDirDim[0];j++)
			delayDirVec[i][j]= Angle(delayDir[i*delayDirDim[1]+j]  );
	
	
	}
	// phaseDir is an Array
	// phaseDir is 2 D
	vector<vector<Angle > >  phaseDirVec(phaseDirDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<phaseDirDim[2];i++) {
		phaseDirVec[i].resize(phaseDirDim[0]);
		for (int j=0;j<phaseDirDim[0];j++)
			phaseDirVec[i][j]= Angle(phaseDir[i*phaseDirDim[1]+j]  );
	
	
	}
	// referenceDir is an Array
	// referenceDir is 2 D
	vector<vector<Angle > >  referenceDirVec(referenceDirDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<referenceDirDim[2];i++) {
		referenceDirVec[i].resize(referenceDirDim[0]);
		for (int j=0;j<referenceDirDim[0];j++)
			referenceDirVec[i][j]= Angle(referenceDir[i*referenceDirDim[1]+j]  );
	
	
	}
	
	// Create new row
  
	row = table.newRow(string(fieldName), *numPoly, delayDirVec, phaseDirVec, referenceDirVec);

	// Add row
	FieldRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the FieldTable" << endl;
	}
	
	// return atoi((retRow->getFieldId().getId()).c_str());
	return retRow->getFieldId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a FieldRow* given a key.
 */
int sdm_getFieldRow (int * fieldId, char * fieldName, int * fieldNameDim, int * numPoly, double * delayDir, int * delayDirDim, double * phaseDir, int * phaseDirDim, double * referenceDir, int * referenceDirDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FieldTable &table = dataset->getField();
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  fieldId  attr.UpperCaseName: FieldId
		//  attr.NameS:  fieldName  attr.UpperCaseName: FieldName
		if ((int)row->getFieldName().size()<fieldNameDim[1])
			strcpy(fieldName,row->getFieldName().c_str());
		else
			strncpy(fieldName,row->getFieldName().c_str(),fieldNameDim[1]);
		fieldNameDim[0] = (int)row->getFieldName().size();
		//  attr.NameS:  numPoly  attr.UpperCaseName: NumPoly
		*numPoly = row->getNumPoly();
		//  attr.NameS:  delayDir  attr.UpperCaseName: DelayDir
		
		vector<vector<Angle > >  delayDirVec = row->getDelayDir();
		
		int maxDimZeroDelayDir = 0;
		for (int i=0; i< min((int)delayDirVec.size(),delayDirDim[3]) ;i++) {
			maxDimZeroDelayDir = max((int)delayDirVec[i].size(),maxDimZeroDelayDir);
			for (int j=0; j<min((int)delayDirVec[i].size(),delayDirDim[1]) ;j++) {
				delayDir[i*delayDirDim[1]+j] = delayDirVec[i][j].get();
			}
		}
		delayDirDim[0] = maxDimZeroDelayDir;
		delayDirDim[2] = delayDirVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  phaseDir  attr.UpperCaseName: PhaseDir
		
		vector<vector<Angle > >  phaseDirVec = row->getPhaseDir();
		
		int maxDimZeroPhaseDir = 0;
		for (int i=0; i< min((int)phaseDirVec.size(),phaseDirDim[3]) ;i++) {
			maxDimZeroPhaseDir = max((int)phaseDirVec[i].size(),maxDimZeroPhaseDir);
			for (int j=0; j<min((int)phaseDirVec[i].size(),phaseDirDim[1]) ;j++) {
				phaseDir[i*phaseDirDim[1]+j] = phaseDirVec[i][j].get();
			}
		}
		phaseDirDim[0] = maxDimZeroPhaseDir;
		phaseDirDim[2] = phaseDirVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  referenceDir  attr.UpperCaseName: ReferenceDir
		
		vector<vector<Angle > >  referenceDirVec = row->getReferenceDir();
		
		int maxDimZeroReferenceDir = 0;
		for (int i=0; i< min((int)referenceDirVec.size(),referenceDirDim[3]) ;i++) {
			maxDimZeroReferenceDir = max((int)referenceDirVec[i].size(),maxDimZeroReferenceDir);
			for (int j=0; j<min((int)referenceDirVec[i].size(),referenceDirDim[1]) ;j++) {
				referenceDir[i*referenceDirDim[1]+j] = referenceDirVec[i][j].get();
			}
		}
		referenceDirDim[0] = maxDimZeroReferenceDir;
		referenceDirDim[2] = referenceDirVec.size();  // return dimension of the ASDM table
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getFieldTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
FieldTable &table = dataset->getField();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getFieldKeys(int * fieldId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	FieldTable &table = dataset->getField();
	
	vector< FieldRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// fieldId[i] = atoi((row[i]->getFieldId().getId()).c_str());
				fieldId[i] = row[i]->getFieldId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter time, in a row of the Field table, given a key
 *
 */

#define sdm_addFieldTime  sdm_addfieldtime_
extern "C" int sdm_addFieldTime(int * fieldId, int64_t * time);

int sdm_addFieldTime(int * fieldId, int64_t * time) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FieldTable &table = dataset->getField();
	
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTime(ArrayTime(* time ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter time, in a row of the Field table, given a key
 *
 */

#define sdm_getFieldTime  sdm_getfieldtime_
extern "C" int sdm_getFieldTime(int * fieldId, int64_t * time);

int sdm_getFieldTime(int * fieldId, int64_t * time) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FieldTable &table = dataset->getField();
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTimeExists()) {
			*time     = row->getTime().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter code, in a row of the Field table, given a key
 *
 */

#define sdm_addFieldCode  sdm_addfieldcode_
extern "C" int sdm_addFieldCode(int * fieldId, char * code, int * codeDim);

int sdm_addFieldCode(int * fieldId, char * code, int * codeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FieldTable &table = dataset->getField();
	
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCode(string(code));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter code, in a row of the Field table, given a key
 *
 */

#define sdm_getFieldCode  sdm_getfieldcode_
extern "C" int sdm_getFieldCode(int * fieldId, char * code, int * codeDim);

int sdm_getFieldCode(int * fieldId, char * code, int * codeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FieldTable &table = dataset->getField();
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCodeExists()) {
			if ((int)row->getCode().size()<codeDim[1])
				strcpy(code,row->getCode().c_str());
			else
				strncpy(code,row->getCode().c_str(),codeDim[1]);
			codeDim[0] = (int)row->getCode().size();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter directionCode, in a row of the Field table, given a key
 *
 */

#define sdm_addFieldDirectionCode  sdm_addfielddirectioncode_
extern "C" int sdm_addFieldDirectionCode(int * fieldId, DirectionReferenceCode * directionCode);

int sdm_addFieldDirectionCode(int * fieldId, DirectionReferenceCode * directionCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FieldTable &table = dataset->getField();
	
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDirectionCode(DirectionReferenceCode(* directionCode ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter directionCode, in a row of the Field table, given a key
 *
 */

#define sdm_getFieldDirectionCode  sdm_getfielddirectioncode_
extern "C" int sdm_getFieldDirectionCode(int * fieldId, DirectionReferenceCode * directionCode);

int sdm_getFieldDirectionCode(int * fieldId, DirectionReferenceCode * directionCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FieldTable &table = dataset->getField();
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDirectionCodeExists()) {
			*directionCode = row->getDirectionCode();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter directionEquinox, in a row of the Field table, given a key
 *
 */

#define sdm_addFieldDirectionEquinox  sdm_addfielddirectionequinox_
extern "C" int sdm_addFieldDirectionEquinox(int * fieldId, int64_t * directionEquinox);

int sdm_addFieldDirectionEquinox(int * fieldId, int64_t * directionEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FieldTable &table = dataset->getField();
	
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDirectionEquinox(ArrayTime(* directionEquinox ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter directionEquinox, in a row of the Field table, given a key
 *
 */

#define sdm_getFieldDirectionEquinox  sdm_getfielddirectionequinox_
extern "C" int sdm_getFieldDirectionEquinox(int * fieldId, int64_t * directionEquinox);

int sdm_getFieldDirectionEquinox(int * fieldId, int64_t * directionEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FieldTable &table = dataset->getField();
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDirectionEquinoxExists()) {
			*directionEquinox     = row->getDirectionEquinox().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter assocNature, in a row of the Field table, given a key
 *
 */

#define sdm_addFieldAssocNature  sdm_addfieldassocnature_
extern "C" int sdm_addFieldAssocNature(int * fieldId, char * assocNature, int * assocNatureDim);

int sdm_addFieldAssocNature(int * fieldId, char * assocNature, int * assocNatureDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FieldTable &table = dataset->getField();
	
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setAssocNature(string(assocNature));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter assocNature, in a row of the Field table, given a key
 *
 */

#define sdm_getFieldAssocNature  sdm_getfieldassocnature_
extern "C" int sdm_getFieldAssocNature(int * fieldId, char * assocNature, int * assocNatureDim);

int sdm_getFieldAssocNature(int * fieldId, char * assocNature, int * assocNatureDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FieldTable &table = dataset->getField();
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAssocNatureExists()) {
			if ((int)row->getAssocNature().size()<assocNatureDim[1])
				strcpy(assocNature,row->getAssocNature().c_str());
			else
				strncpy(assocNature,row->getAssocNature().c_str(),assocNatureDim[1]);
			assocNatureDim[0] = (int)row->getAssocNature().size();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter ephemerisId, in a row of the Field table, given a key
 *
 */

#define sdm_addFieldEphemerisId  sdm_addfieldephemerisid_
extern "C" int sdm_addFieldEphemerisId(int * fieldId, int * ephemerisId);

int sdm_addFieldEphemerisId(int * fieldId, int * ephemerisId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FieldTable &table = dataset->getField();
	
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setEphemerisId(int(* ephemerisId ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter ephemerisId, in a row of the Field table, given a key
 *
 */

#define sdm_getFieldEphemerisId  sdm_getfieldephemerisid_
extern "C" int sdm_getFieldEphemerisId(int * fieldId, int * ephemerisId);

int sdm_getFieldEphemerisId(int * fieldId, int * ephemerisId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FieldTable &table = dataset->getField();
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isEphemerisIdExists()) {
			*ephemerisId = row->getEphemerisId();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sourceId, in a row of the Field table, given a key
 *
 */

#define sdm_addFieldSourceId  sdm_addfieldsourceid_
extern "C" int sdm_addFieldSourceId(int * fieldId, int * sourceId);

int sdm_addFieldSourceId(int * fieldId, int * sourceId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FieldTable &table = dataset->getField();
	
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSourceId(int(* sourceId ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sourceId, in a row of the Field table, given a key
 *
 */

#define sdm_getFieldSourceId  sdm_getfieldsourceid_
extern "C" int sdm_getFieldSourceId(int * fieldId, int * sourceId);

int sdm_getFieldSourceId(int * fieldId, int * sourceId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FieldTable &table = dataset->getField();
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSourceIdExists()) {
			*sourceId = row->getSourceId();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter assocFieldId, in a row of the Field table, given a key
 *
 */

#define sdm_addFieldAssocFieldId  sdm_addfieldassocfieldid_
extern "C" int sdm_addFieldAssocFieldId(int * fieldId, int * assocFieldId);

int sdm_addFieldAssocFieldId(int * fieldId, int * assocFieldId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FieldTable &table = dataset->getField();
	
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setAssocFieldId(Tag(* assocFieldId , TagType::Field));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter assocFieldId, in a row of the Field table, given a key
 *
 */

#define sdm_getFieldAssocFieldId  sdm_getfieldassocfieldid_
extern "C" int sdm_getFieldAssocFieldId(int * fieldId, int * assocFieldId);

int sdm_getFieldAssocFieldId(int * fieldId, int * assocFieldId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FieldTable &table = dataset->getField();
	FieldRow *row = 0;
	row = table.getRowByKey( Tag(*fieldId, TagType::Field));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAssocFieldIdExists()) {
			// *assocFieldId = atoi((row->getAssocFieldId().getId()).c_str());
			*assocFieldId = row->getAssocFieldId().getTagValue();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}




// =================== FlagCmdTable ============================

extern "C" int sdm_addFlagCmdRow (int64_t * timeInterval, char * type, int * typeDim, char * reason, int * reasonDim, int * level, int * severity, bool * applied, char * command, int * commandDim);
extern "C" int sdm_getFlagCmdRow (int64_t * timeInterval, char * type, int * typeDim, char * reason, int * reasonDim, int * level, int * severity, bool * applied, char * command, int * commandDim);


extern "C" int sdm_getFlagCmdTableSize ();

extern "C" int sdm_getFlagCmdKeys (int64_t * timeInterval);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addFlagCmdRow (int64_t * timeInterval, char * type, int * typeDim, char * reason, int * reasonDim, int * level, int * severity, bool * applied, char * command, int * commandDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	FlagCmdTable &table = dataset->getFlagCmd();
	FlagCmdRow *row = 0;

	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(ArrayTimeInterval(*timeInterval, *(timeInterval+1)), string(type), string(reason), *level, *severity, *applied, string(command));
	} else {
		row = table.newRow(ArrayTimeInterval(*timeInterval), string(type), string(reason), *level, *severity, *applied, string(command));
	}

	// Add row
	FlagCmdRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the FlagCmdTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a FlagCmdRow* given a key.
 */
int sdm_getFlagCmdRow (int64_t * timeInterval, char * type, int * typeDim, char * reason, int * reasonDim, int * level, int * severity, bool * applied, char * command, int * commandDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FlagCmdTable &table = dataset->getFlagCmd();
	FlagCmdRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  type  attr.UpperCaseName: Type
		if ((int)row->getType().size()<typeDim[1])
			strcpy(type,row->getType().c_str());
		else
			strncpy(type,row->getType().c_str(),typeDim[1]);
		typeDim[0] = (int)row->getType().size();
		//  attr.NameS:  reason  attr.UpperCaseName: Reason
		if ((int)row->getReason().size()<reasonDim[1])
			strcpy(reason,row->getReason().c_str());
		else
			strncpy(reason,row->getReason().c_str(),reasonDim[1]);
		reasonDim[0] = (int)row->getReason().size();
		//  attr.NameS:  level  attr.UpperCaseName: Level
		*level = row->getLevel();
		//  attr.NameS:  severity  attr.UpperCaseName: Severity
		*severity = row->getSeverity();
		//  attr.NameS:  applied  attr.UpperCaseName: Applied
		*applied = row->getApplied();
		//  attr.NameS:  command  attr.UpperCaseName: Command
		if ((int)row->getCommand().size()<commandDim[1])
			strcpy(command,row->getCommand().c_str());
		else
			strncpy(command,row->getCommand().c_str(),commandDim[1]);
		commandDim[0] = (int)row->getCommand().size();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getFlagCmdTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
FlagCmdTable &table = dataset->getFlagCmd();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getFlagCmdKeys(int64_t * timeInterval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	FlagCmdTable &table = dataset->getFlagCmd();
	
	vector< FlagCmdRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
  		}
  		
		return size;
  	}
}





using namespace PolarizationTypeMod;


// =================== FlagTable ============================

extern "C" int sdm_addFlagRow (int64_t * startTime, int64_t * endTime, char * reason, int * reasonDim, int * numAntenna, int * antennaId, int * antennaIdDim);
extern "C" int sdm_getFlagRow (int * flagId, int64_t * startTime, int64_t * endTime, char * reason, int * reasonDim, int * numAntenna, int * antennaId, int * antennaIdDim);


extern "C" int sdm_getFlagTableSize ();

extern "C" int sdm_getFlagKeys (int * flagId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addFlagRow (int64_t * startTime, int64_t * endTime, char * reason, int * reasonDim, int * numAntenna, int * antennaId, int * antennaIdDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	FlagTable &table = dataset->getFlag();
	FlagRow *row = 0;

	// antennaId is an Array
	// antennaId is OneD
	vector<Tag>   antennaIdVec(antennaIdDim[0]);
	for (int i=0;i<antennaIdDim[0];i++)
		antennaIdVec[i]= Tag(antennaId[i]   , TagType::Antenna);
	
	// Create new row
  
	row = table.newRow(ArrayTime(*startTime), ArrayTime(*endTime), string(reason), *numAntenna, antennaIdVec);

	// Add row
	FlagRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the FlagTable" << endl;
	}
	
	// return atoi((retRow->getFlagId().getId()).c_str());
	return retRow->getFlagId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a FlagRow* given a key.
 */
int sdm_getFlagRow (int * flagId, int64_t * startTime, int64_t * endTime, char * reason, int * reasonDim, int * numAntenna, int * antennaId, int * antennaIdDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FlagTable &table = dataset->getFlag();
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  flagId  attr.UpperCaseName: FlagId
		//  attr.NameS:  startTime  attr.UpperCaseName: StartTime
		*startTime     = row->getStartTime().get();
		//  attr.NameS:  endTime  attr.UpperCaseName: EndTime
		*endTime     = row->getEndTime().get();
		//  attr.NameS:  reason  attr.UpperCaseName: Reason
		if ((int)row->getReason().size()<reasonDim[1])
			strcpy(reason,row->getReason().c_str());
		else
			strncpy(reason,row->getReason().c_str(),reasonDim[1]);
		reasonDim[0] = (int)row->getReason().size();
		//  attr.NameS:  numAntenna  attr.UpperCaseName: NumAntenna
		*numAntenna = row->getNumAntenna();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		
		vector<Tag>   antennaIdVec = row->getAntennaId();
		
		for (int i=0; i<min((int)antennaIdVec.size(),antennaIdDim[1]); i++)
			//antennaId[i] = atoi((row->getAntennaId()[i]).getId().c_str());
		antennaId[i] = antennaIdVec[i].getTagValue();
		antennaIdDim[0] = (int)antennaIdVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getFlagTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
FlagTable &table = dataset->getFlag();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getFlagKeys(int * flagId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	FlagTable &table = dataset->getFlag();
	
	vector< FlagRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// flagId[i] = atoi((row[i]->getFlagId().getId()).c_str());
				flagId[i] = row[i]->getFlagId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter numPolarizationType, in a row of the Flag table, given a key
 *
 */

#define sdm_addFlagNumPolarizationType  sdm_addflagnumpolarizationtype_
extern "C" int sdm_addFlagNumPolarizationType(int * flagId, int * numPolarizationType);

int sdm_addFlagNumPolarizationType(int * flagId, int * numPolarizationType) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FlagTable &table = dataset->getFlag();
	
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumPolarizationType(int(* numPolarizationType ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numPolarizationType, in a row of the Flag table, given a key
 *
 */

#define sdm_getFlagNumPolarizationType  sdm_getflagnumpolarizationtype_
extern "C" int sdm_getFlagNumPolarizationType(int * flagId, int * numPolarizationType);

int sdm_getFlagNumPolarizationType(int * flagId, int * numPolarizationType) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FlagTable &table = dataset->getFlag();
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumPolarizationTypeExists()) {
			*numPolarizationType = row->getNumPolarizationType();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numSpectralWindow, in a row of the Flag table, given a key
 *
 */

#define sdm_addFlagNumSpectralWindow  sdm_addflagnumspectralwindow_
extern "C" int sdm_addFlagNumSpectralWindow(int * flagId, int * numSpectralWindow);

int sdm_addFlagNumSpectralWindow(int * flagId, int * numSpectralWindow) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FlagTable &table = dataset->getFlag();
	
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumSpectralWindow(int(* numSpectralWindow ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numSpectralWindow, in a row of the Flag table, given a key
 *
 */

#define sdm_getFlagNumSpectralWindow  sdm_getflagnumspectralwindow_
extern "C" int sdm_getFlagNumSpectralWindow(int * flagId, int * numSpectralWindow);

int sdm_getFlagNumSpectralWindow(int * flagId, int * numSpectralWindow) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FlagTable &table = dataset->getFlag();
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumSpectralWindowExists()) {
			*numSpectralWindow = row->getNumSpectralWindow();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numPairedAntenna, in a row of the Flag table, given a key
 *
 */

#define sdm_addFlagNumPairedAntenna  sdm_addflagnumpairedantenna_
extern "C" int sdm_addFlagNumPairedAntenna(int * flagId, int * numPairedAntenna);

int sdm_addFlagNumPairedAntenna(int * flagId, int * numPairedAntenna) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FlagTable &table = dataset->getFlag();
	
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumPairedAntenna(int(* numPairedAntenna ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numPairedAntenna, in a row of the Flag table, given a key
 *
 */

#define sdm_getFlagNumPairedAntenna  sdm_getflagnumpairedantenna_
extern "C" int sdm_getFlagNumPairedAntenna(int * flagId, int * numPairedAntenna);

int sdm_getFlagNumPairedAntenna(int * flagId, int * numPairedAntenna) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FlagTable &table = dataset->getFlag();
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumPairedAntennaExists()) {
			*numPairedAntenna = row->getNumPairedAntenna();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter polarizationType, in a row of the Flag table, given a key
 *
 */

#define sdm_addFlagPolarizationType  sdm_addflagpolarizationtype_
extern "C" int sdm_addFlagPolarizationType(int * flagId, PolarizationType * polarizationType, int * polarizationTypeDim);

int sdm_addFlagPolarizationType(int * flagId, PolarizationType * polarizationType, int * polarizationTypeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FlagTable &table = dataset->getFlag();
	
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypeVec(polarizationTypeDim[0]);
		for (int i=0;i<polarizationTypeDim[0];i++)
			polarizationTypeVec[i]= PolarizationType(polarizationType[i] );
		row->setPolarizationType(polarizationTypeVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter polarizationType, in a row of the Flag table, given a key
 *
 */

#define sdm_getFlagPolarizationType  sdm_getflagpolarizationtype_
extern "C" int sdm_getFlagPolarizationType(int * flagId, PolarizationType * polarizationType, int * polarizationTypeDim);

int sdm_getFlagPolarizationType(int * flagId, PolarizationType * polarizationType, int * polarizationTypeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FlagTable &table = dataset->getFlag();
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPolarizationTypeExists()) {
			// attr.CppType: vector<PolarizationTypeMod::PolarizationType > attr.isOneD: true
			for (int i=0; i<min((int)row->getPolarizationType().size(),polarizationTypeDim[1]); i++)
				polarizationType[i] = row->getPolarizationType()[i];
			polarizationTypeDim[0] = (int)row->getPolarizationType().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter pairedAntennaId, in a row of the Flag table, given a key
 *
 */

#define sdm_addFlagPairedAntennaId  sdm_addflagpairedantennaid_
extern "C" int sdm_addFlagPairedAntennaId(int * flagId, int * pairedAntennaId, int * pairedAntennaIdDim);

int sdm_addFlagPairedAntennaId(int * flagId, int * pairedAntennaId, int * pairedAntennaIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FlagTable &table = dataset->getFlag();
	
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Tag>   pairedAntennaIdVec(pairedAntennaIdDim[0]);
		for (int i=0;i<pairedAntennaIdDim[0];i++)
			pairedAntennaIdVec[i]= Tag(pairedAntennaId[i] , TagType::Antenna);
		row->setPairedAntennaId(pairedAntennaIdVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter pairedAntennaId, in a row of the Flag table, given a key
 *
 */

#define sdm_getFlagPairedAntennaId  sdm_getflagpairedantennaid_
extern "C" int sdm_getFlagPairedAntennaId(int * flagId, int * pairedAntennaId, int * pairedAntennaIdDim);

int sdm_getFlagPairedAntennaId(int * flagId, int * pairedAntennaId, int * pairedAntennaIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FlagTable &table = dataset->getFlag();
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPairedAntennaIdExists()) {
			// attr.CppType: vector<Tag>  attr.isOneD: true
			for (int i=0; i<min((int)row->getPairedAntennaId().size(),pairedAntennaIdDim[1]); i++)
			// pairedAntennaId[i] = atoi((row->getPairedAntennaId()[i]).getId().c_str());
			pairedAntennaId[i] = row->getPairedAntennaId()[i].getTagValue();
			pairedAntennaIdDim[0] = (int)row->getPairedAntennaId().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter spectralWindowId, in a row of the Flag table, given a key
 *
 */

#define sdm_addFlagSpectralWindowId  sdm_addflagspectralwindowid_
extern "C" int sdm_addFlagSpectralWindowId(int * flagId, int * spectralWindowId, int * spectralWindowIdDim);

int sdm_addFlagSpectralWindowId(int * flagId, int * spectralWindowId, int * spectralWindowIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FlagTable &table = dataset->getFlag();
	
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Tag>   spectralWindowIdVec(spectralWindowIdDim[0]);
		for (int i=0;i<spectralWindowIdDim[0];i++)
			spectralWindowIdVec[i]= Tag(spectralWindowId[i] , TagType::SpectralWindow);
		row->setSpectralWindowId(spectralWindowIdVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter spectralWindowId, in a row of the Flag table, given a key
 *
 */

#define sdm_getFlagSpectralWindowId  sdm_getflagspectralwindowid_
extern "C" int sdm_getFlagSpectralWindowId(int * flagId, int * spectralWindowId, int * spectralWindowIdDim);

int sdm_getFlagSpectralWindowId(int * flagId, int * spectralWindowId, int * spectralWindowIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FlagTable &table = dataset->getFlag();
	FlagRow *row = 0;
	row = table.getRowByKey( Tag(*flagId, TagType::Flag));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSpectralWindowIdExists()) {
			// attr.CppType: vector<Tag>  attr.isOneD: true
			for (int i=0; i<min((int)row->getSpectralWindowId().size(),spectralWindowIdDim[1]); i++)
			// spectralWindowId[i] = atoi((row->getSpectralWindowId()[i]).getId().c_str());
			spectralWindowId[i] = row->getSpectralWindowId()[i].getTagValue();
			spectralWindowIdDim[0] = (int)row->getSpectralWindowId().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace PolarizationTypeMod;
using namespace ReceiverBandMod;


// =================== FocusModelTable ============================

extern "C" int sdm_addFocusModelRow (int * antennaId, PolarizationType * polarizationType, ReceiverBand * receiverBand, int * numCoeff, char * coeffName, int * coeffNameDim, char * coeffFormula, int * coeffFormulaDim, float * coeffVal, int * coeffValDim, char * assocNature, int * assocNatureDim, int * assocFocusModelId);
extern "C" int sdm_getFocusModelRow (int * antennaId, int * focusModelId, PolarizationType * polarizationType, ReceiverBand * receiverBand, int * numCoeff, char * coeffName, int * coeffNameDim, char * coeffFormula, int * coeffFormulaDim, float * coeffVal, int * coeffValDim, char * assocNature, int * assocNatureDim, int * assocFocusModelId);


extern "C" int sdm_getFocusModelTableSize ();

extern "C" int sdm_getFocusModelKeys (int * antennaId, int * focusModelId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addFocusModelRow (int * antennaId, PolarizationType * polarizationType, ReceiverBand * receiverBand, int * numCoeff, char * coeffName, int * coeffNameDim, char * coeffFormula, int * coeffFormulaDim, float * coeffVal, int * coeffValDim, char * assocNature, int * assocNatureDim, int * assocFocusModelId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	FocusModelTable &table = dataset->getFocusModel();
	FocusModelRow *row = 0;

	// polarizationType is an enumeration
	// PolarizationType * polarizationType =  (int) polarizationType;
	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	// coeffName is an Array
	// coeffName is OneD
	vector<string >  coeffNameVec(coeffNameDim[2]);
	for (int i=0;i<coeffNameDim[2];i++)
		coeffNameVec[i]= string(coeffName+i*coeffNameDim[1]  );
	// coeffFormula is an Array
	// coeffFormula is OneD
	vector<string >  coeffFormulaVec(coeffFormulaDim[2]);
	for (int i=0;i<coeffFormulaDim[2];i++)
		coeffFormulaVec[i]= string(coeffFormula+i*coeffFormulaDim[1]  );
	// coeffVal is an Array
	// coeffVal is OneD
	vector<float >  coeffValVec(coeffValDim[0]);
	for (int i=0;i<coeffValDim[0];i++)
		coeffValVec[i]= float(coeffVal[i]   );
	
	// Create new row
  
	row = table.newRow(Tag(*antennaId,TagType::Antenna), *polarizationType, *receiverBand, *numCoeff, coeffNameVec, coeffFormulaVec, coeffValVec, string(assocNature), *assocFocusModelId);

	// Add row
	FocusModelRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the FocusModelTable" << endl;
	}
	
	return retRow->getFocusModelId();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a FocusModelRow* given a key.
 */
int sdm_getFocusModelRow (int * antennaId, int * focusModelId, PolarizationType * polarizationType, ReceiverBand * receiverBand, int * numCoeff, char * coeffName, int * coeffNameDim, char * coeffFormula, int * coeffFormulaDim, float * coeffVal, int * coeffValDim, char * assocNature, int * assocNatureDim, int * assocFocusModelId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FocusModelTable &table = dataset->getFocusModel();
	FocusModelRow *row = 0;
	row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), *focusModelId);
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  focusModelId  attr.UpperCaseName: FocusModelId
		//  attr.NameS:  polarizationType  attr.UpperCaseName: PolarizationType
		*polarizationType = row->getPolarizationType();
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		*receiverBand = row->getReceiverBand();
		//  attr.NameS:  numCoeff  attr.UpperCaseName: NumCoeff
		*numCoeff = row->getNumCoeff();
		//  attr.NameS:  coeffName  attr.UpperCaseName: CoeffName
		
		vector<string >  coeffNameVec = row->getCoeffName();
		
		int maxDimZeroCoeffName = 0;
		for (int i=0; i<min((int)coeffNameVec.size(),coeffNameDim[3]); i++) {
			if ((int)coeffNameVec[i].size()<coeffNameDim[1])
				strcpy(coeffName+i*coeffNameDim[1],coeffNameVec[i].c_str());
			else
				strncpy(coeffName+i*coeffNameDim[1],coeffNameVec[i].c_str(),coeffNameDim[1]);
			maxDimZeroCoeffName = max((int)coeffNameVec[i].size(),maxDimZeroCoeffName);
		}
		coeffNameDim[0] = maxDimZeroCoeffName;
		coeffNameDim[2] = coeffNameVec.size();  // number of strings
		
		
		//  attr.NameS:  coeffFormula  attr.UpperCaseName: CoeffFormula
		
		vector<string >  coeffFormulaVec = row->getCoeffFormula();
		
		int maxDimZeroCoeffFormula = 0;
		for (int i=0; i<min((int)coeffFormulaVec.size(),coeffFormulaDim[3]); i++) {
			if ((int)coeffFormulaVec[i].size()<coeffFormulaDim[1])
				strcpy(coeffFormula+i*coeffFormulaDim[1],coeffFormulaVec[i].c_str());
			else
				strncpy(coeffFormula+i*coeffFormulaDim[1],coeffFormulaVec[i].c_str(),coeffFormulaDim[1]);
			maxDimZeroCoeffFormula = max((int)coeffFormulaVec[i].size(),maxDimZeroCoeffFormula);
		}
		coeffFormulaDim[0] = maxDimZeroCoeffFormula;
		coeffFormulaDim[2] = coeffFormulaVec.size();  // number of strings
		
		
		//  attr.NameS:  coeffVal  attr.UpperCaseName: CoeffVal
		
		vector<float >  coeffValVec = row->getCoeffVal();
		
		for (int i=0; i<min((int)coeffValVec.size(),coeffValDim[1]); i++)
			coeffVal[i] = coeffValVec[i];
		coeffValDim[0] = (int)coeffValVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  assocNature  attr.UpperCaseName: AssocNature
		if ((int)row->getAssocNature().size()<assocNatureDim[1])
			strcpy(assocNature,row->getAssocNature().c_str());
		else
			strncpy(assocNature,row->getAssocNature().c_str(),assocNatureDim[1]);
		assocNatureDim[0] = (int)row->getAssocNature().size();
		//  attr.NameS:  assocFocusModelId  attr.UpperCaseName: AssocFocusModelId
		*assocFocusModelId = row->getAssocFocusModelId();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getFocusModelTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
FocusModelTable &table = dataset->getFocusModel();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getFocusModelKeys(int * antennaId, int * focusModelId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	FocusModelTable &table = dataset->getFocusModel();
	
	vector< FocusModelRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		focusModelId[i] = row[i]->getFocusModelId();
  		}
  		
		return size;
  	}
}







// =================== FocusTable ============================

extern "C" int sdm_addFocusRow (int * antennaId, int64_t * timeInterval, bool * focusTracking, double * focusOffset, int * focusOffsetDim, double * focusRotationOffset, int * focusRotationOffsetDim, int * focusModelId);
extern "C" int sdm_getFocusRow (int * antennaId, int64_t * timeInterval, bool * focusTracking, double * focusOffset, int * focusOffsetDim, double * focusRotationOffset, int * focusRotationOffsetDim, int * focusModelId);


extern "C" int sdm_getFocusTableSize ();

extern "C" int sdm_getFocusKeys (int * antennaId, int64_t * timeInterval);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addFocusRow (int * antennaId, int64_t * timeInterval, bool * focusTracking, double * focusOffset, int * focusOffsetDim, double * focusRotationOffset, int * focusRotationOffsetDim, int * focusModelId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	FocusTable &table = dataset->getFocus();
	FocusRow *row = 0;

	// focusOffset is an Array
	// focusOffset is OneD
	vector<Length >  focusOffsetVec(focusOffsetDim[0]);
	for (int i=0;i<focusOffsetDim[0];i++)
		focusOffsetVec[i]= Length(focusOffset[i]   );
	// focusRotationOffset is an Array
	// focusRotationOffset is OneD
	vector<Angle >  focusRotationOffsetVec(focusRotationOffsetDim[0]);
	for (int i=0;i<focusRotationOffsetDim[0];i++)
		focusRotationOffsetVec[i]= Angle(focusRotationOffset[i]   );
	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *focusTracking, focusOffsetVec, focusRotationOffsetVec, *focusModelId);
	} else {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), ArrayTimeInterval(*timeInterval), *focusTracking, focusOffsetVec, focusRotationOffsetVec, *focusModelId);
	}

	// Add row
	FocusRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the FocusTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a FocusRow* given a key.
 */
int sdm_getFocusRow (int * antennaId, int64_t * timeInterval, bool * focusTracking, double * focusOffset, int * focusOffsetDim, double * focusRotationOffset, int * focusRotationOffsetDim, int * focusModelId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FocusTable &table = dataset->getFocus();
	FocusRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  focusTracking  attr.UpperCaseName: FocusTracking
		*focusTracking = row->getFocusTracking();
		//  attr.NameS:  focusOffset  attr.UpperCaseName: FocusOffset
		
		vector<Length >  focusOffsetVec = row->getFocusOffset();
		
		for (int i=0; i<min((int)focusOffsetVec.size(),focusOffsetDim[1]); i++)
			focusOffset[i] = focusOffsetVec[i].get();
		focusOffsetDim[0] = focusOffsetVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  focusRotationOffset  attr.UpperCaseName: FocusRotationOffset
		
		vector<Angle >  focusRotationOffsetVec = row->getFocusRotationOffset();
		
		for (int i=0; i<min((int)focusRotationOffsetVec.size(),focusRotationOffsetDim[1]); i++)
			focusRotationOffset[i] = focusRotationOffsetVec[i].get();
		focusRotationOffsetDim[0] = focusRotationOffsetVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  focusModelId  attr.UpperCaseName: FocusModelId
		*focusModelId = row->getFocusModelId();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getFocusTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
FocusTable &table = dataset->getFocus();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getFocusKeys(int * antennaId, int64_t * timeInterval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	FocusTable &table = dataset->getFocus();
	
	vector< FocusRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter measuredFocusPosition, in a row of the Focus table, given a key
 *
 */

#define sdm_addFocusMeasuredFocusPosition  sdm_addfocusmeasuredfocusposition_
extern "C" int sdm_addFocusMeasuredFocusPosition(int * antennaId, int64_t * timeInterval, double * measuredFocusPosition, int * measuredFocusPositionDim);

int sdm_addFocusMeasuredFocusPosition(int * antennaId, int64_t * timeInterval, double * measuredFocusPosition, int * measuredFocusPositionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FocusTable &table = dataset->getFocus();
	
	FocusRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  measuredFocusPositionVec(measuredFocusPositionDim[0]);
		for (int i=0;i<measuredFocusPositionDim[0];i++)
			measuredFocusPositionVec[i]= Length(measuredFocusPosition[i] );
		row->setMeasuredFocusPosition(measuredFocusPositionVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter measuredFocusPosition, in a row of the Focus table, given a key
 *
 */

#define sdm_getFocusMeasuredFocusPosition  sdm_getfocusmeasuredfocusposition_
extern "C" int sdm_getFocusMeasuredFocusPosition(int * antennaId, int64_t * timeInterval, double * measuredFocusPosition, int * measuredFocusPositionDim);

int sdm_getFocusMeasuredFocusPosition(int * antennaId, int64_t * timeInterval, double * measuredFocusPosition, int * measuredFocusPositionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FocusTable &table = dataset->getFocus();
	FocusRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isMeasuredFocusPositionExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getMeasuredFocusPosition().size(),measuredFocusPositionDim[1]); i++)
				measuredFocusPosition[i] = row->getMeasuredFocusPosition()[i].get();
			measuredFocusPositionDim[0] = row->getMeasuredFocusPosition().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter measuredFocusRotation, in a row of the Focus table, given a key
 *
 */

#define sdm_addFocusMeasuredFocusRotation  sdm_addfocusmeasuredfocusrotation_
extern "C" int sdm_addFocusMeasuredFocusRotation(int * antennaId, int64_t * timeInterval, double * measuredFocusRotation, int * measuredFocusRotationDim);

int sdm_addFocusMeasuredFocusRotation(int * antennaId, int64_t * timeInterval, double * measuredFocusRotation, int * measuredFocusRotationDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FocusTable &table = dataset->getFocus();
	
	FocusRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Angle >  measuredFocusRotationVec(measuredFocusRotationDim[0]);
		for (int i=0;i<measuredFocusRotationDim[0];i++)
			measuredFocusRotationVec[i]= Angle(measuredFocusRotation[i] );
		row->setMeasuredFocusRotation(measuredFocusRotationVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter measuredFocusRotation, in a row of the Focus table, given a key
 *
 */

#define sdm_getFocusMeasuredFocusRotation  sdm_getfocusmeasuredfocusrotation_
extern "C" int sdm_getFocusMeasuredFocusRotation(int * antennaId, int64_t * timeInterval, double * measuredFocusRotation, int * measuredFocusRotationDim);

int sdm_getFocusMeasuredFocusRotation(int * antennaId, int64_t * timeInterval, double * measuredFocusRotation, int * measuredFocusRotationDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	FocusTable &table = dataset->getFocus();
	FocusRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isMeasuredFocusRotationExists()) {
			// attr.CppType: vector<Angle > attr.isOneD: true
			for (int i=0; i<min((int)row->getMeasuredFocusRotation().size(),measuredFocusRotationDim[1]); i++)
				measuredFocusRotation[i] = row->getMeasuredFocusRotation()[i].get();
			measuredFocusRotationDim[0] = row->getMeasuredFocusRotation().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}




// =================== FreqOffsetTable ============================

extern "C" int sdm_addFreqOffsetRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * offset);
extern "C" int sdm_getFreqOffsetRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * offset);


extern "C" int sdm_getFreqOffsetTableSize ();

extern "C" int sdm_getFreqOffsetKeys (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addFreqOffsetRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * offset){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	FreqOffsetTable &table = dataset->getFreqOffset();
	FreqOffsetRow *row = 0;

	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId, Frequency(*offset));
	} else {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId, Frequency(*offset));
	}

	// Add row
	FreqOffsetRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the FreqOffsetTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a FreqOffsetRow* given a key.
 */
int sdm_getFreqOffsetRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * offset) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	FreqOffsetTable &table = dataset->getFreqOffset();
	FreqOffsetRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  feedId  attr.UpperCaseName: FeedId
		//  attr.NameS:  offset  attr.UpperCaseName: Offset
		*offset = row->getOffset().get();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getFreqOffsetTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
FreqOffsetTable &table = dataset->getFreqOffset();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getFreqOffsetKeys(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	FreqOffsetTable &table = dataset->getFreqOffset();
	
	vector< FreqOffsetRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		// spectralWindowId[i] = atoi((row[i]->getSpectralWindowId().getId()).c_str());
				spectralWindowId[i] = row[i]->getSpectralWindowId().getTagValue();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
	  		feedId[i] = row[i]->getFeedId();
  		}
  		
		return size;
  	}
}





using namespace PolarizationTypeMod;


// =================== GainTrackingTable ============================

extern "C" int sdm_addGainTrackingRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor, float * attenuator, int * attenuatorDim, PolarizationType * polarizationType, int * polarizationTypeDim);
extern "C" int sdm_getGainTrackingRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor, float * attenuator, int * attenuatorDim, PolarizationType * polarizationType, int * polarizationTypeDim);


extern "C" int sdm_getGainTrackingTableSize ();

extern "C" int sdm_getGainTrackingKeys (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addGainTrackingRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor, float * attenuator, int * attenuatorDim, PolarizationType * polarizationType, int * polarizationTypeDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	GainTrackingTable &table = dataset->getGainTracking();
	GainTrackingRow *row = 0;

	// attenuator is an Array
	// attenuator is OneD
	vector<float >  attenuatorVec(attenuatorDim[0]);
	for (int i=0;i<attenuatorDim[0];i++)
		attenuatorVec[i]= float(attenuator[i]   );
	// polarizationType is an Array
	// polarizationType is OneD
	vector<PolarizationTypeMod::PolarizationType >  polarizationTypeVec(polarizationTypeDim[0]);
	for (int i=0;i<polarizationTypeDim[0];i++)
		polarizationTypeVec[i]= PolarizationType(polarizationType[i]   );
	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId, *numReceptor, attenuatorVec, polarizationTypeVec);
	} else {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId, *numReceptor, attenuatorVec, polarizationTypeVec);
	}

	// Add row
	GainTrackingRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the GainTrackingTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a GainTrackingRow* given a key.
 */
int sdm_getGainTrackingRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor, float * attenuator, int * attenuatorDim, PolarizationType * polarizationType, int * polarizationTypeDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	GainTrackingTable &table = dataset->getGainTracking();
	GainTrackingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  feedId  attr.UpperCaseName: FeedId
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  attenuator  attr.UpperCaseName: Attenuator
		
		vector<float >  attenuatorVec = row->getAttenuator();
		
		for (int i=0; i<min((int)attenuatorVec.size(),attenuatorDim[1]); i++)
			attenuator[i] = attenuatorVec[i];
		attenuatorDim[0] = (int)attenuatorVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  polarizationType  attr.UpperCaseName: PolarizationType
		
		vector<PolarizationTypeMod::PolarizationType >  polarizationTypeVec = row->getPolarizationType();
		
		for (int i=0; i<min((int)polarizationTypeVec.size(),polarizationTypeDim[1]); i++)
			polarizationType[i] = polarizationTypeVec[i];
		polarizationTypeDim[0] = (int)polarizationTypeVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getGainTrackingTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
GainTrackingTable &table = dataset->getGainTracking();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getGainTrackingKeys(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	GainTrackingTable &table = dataset->getGainTracking();
	
	vector< GainTrackingRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		// spectralWindowId[i] = atoi((row[i]->getSpectralWindowId().getId()).c_str());
				spectralWindowId[i] = row[i]->getSpectralWindowId().getTagValue();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
	  		feedId[i] = row[i]->getFeedId();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter samplingLevel, in a row of the GainTracking table, given a key
 *
 */

#define sdm_addGainTrackingSamplingLevel  sdm_addgaintrackingsamplinglevel_
extern "C" int sdm_addGainTrackingSamplingLevel(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * samplingLevel);

int sdm_addGainTrackingSamplingLevel(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * samplingLevel) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	GainTrackingTable &table = dataset->getGainTracking();
	
	GainTrackingRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSamplingLevel(float(* samplingLevel ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter samplingLevel, in a row of the GainTracking table, given a key
 *
 */

#define sdm_getGainTrackingSamplingLevel  sdm_getgaintrackingsamplinglevel_
extern "C" int sdm_getGainTrackingSamplingLevel(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * samplingLevel);

int sdm_getGainTrackingSamplingLevel(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * samplingLevel) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	GainTrackingTable &table = dataset->getGainTracking();
	GainTrackingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSamplingLevelExists()) {
			*samplingLevel = row->getSamplingLevel();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numAttFreq, in a row of the GainTracking table, given a key
 *
 */

#define sdm_addGainTrackingNumAttFreq  sdm_addgaintrackingnumattfreq_
extern "C" int sdm_addGainTrackingNumAttFreq(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numAttFreq);

int sdm_addGainTrackingNumAttFreq(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numAttFreq) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	GainTrackingTable &table = dataset->getGainTracking();
	
	GainTrackingRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumAttFreq(int(* numAttFreq ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numAttFreq, in a row of the GainTracking table, given a key
 *
 */

#define sdm_getGainTrackingNumAttFreq  sdm_getgaintrackingnumattfreq_
extern "C" int sdm_getGainTrackingNumAttFreq(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numAttFreq);

int sdm_getGainTrackingNumAttFreq(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numAttFreq) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	GainTrackingTable &table = dataset->getGainTracking();
	GainTrackingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumAttFreqExists()) {
			*numAttFreq = row->getNumAttFreq();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter attFreq, in a row of the GainTracking table, given a key
 *
 */

#define sdm_addGainTrackingAttFreq  sdm_addgaintrackingattfreq_
extern "C" int sdm_addGainTrackingAttFreq(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * attFreq, int * attFreqDim);

int sdm_addGainTrackingAttFreq(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * attFreq, int * attFreqDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	GainTrackingTable &table = dataset->getGainTracking();
	
	GainTrackingRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<double >  attFreqVec(attFreqDim[0]);
		for (int i=0;i<attFreqDim[0];i++)
			attFreqVec[i]= double(attFreq[i] );
		row->setAttFreq(attFreqVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter attFreq, in a row of the GainTracking table, given a key
 *
 */

#define sdm_getGainTrackingAttFreq  sdm_getgaintrackingattfreq_
extern "C" int sdm_getGainTrackingAttFreq(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * attFreq, int * attFreqDim);

int sdm_getGainTrackingAttFreq(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * attFreq, int * attFreqDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	GainTrackingTable &table = dataset->getGainTracking();
	GainTrackingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAttFreqExists()) {
			// attr.CppType: vector<double > attr.isOneD: true
			for (int i=0; i<min((int)row->getAttFreq().size(),attFreqDim[1]); i++)
				attFreq[i] = row->getAttFreq()[i];
			attFreqDim[0] = (int)row->getAttFreq().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter attSpectrum, in a row of the GainTracking table, given a key
 *
 */

#define sdm_addGainTrackingAttSpectrum  sdm_addgaintrackingattspectrum_
extern "C" int sdm_addGainTrackingAttSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, Complex * attSpectrum, int * attSpectrumDim);

int sdm_addGainTrackingAttSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, Complex * attSpectrum, int * attSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	GainTrackingTable &table = dataset->getGainTracking();
	
	GainTrackingRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Complex >  attSpectrumVec(attSpectrumDim[0]);
		for (int i=0;i<attSpectrumDim[0];i++)
			attSpectrumVec[i]= Complex(attSpectrum[i] );
		row->setAttSpectrum(attSpectrumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter attSpectrum, in a row of the GainTracking table, given a key
 *
 */

#define sdm_getGainTrackingAttSpectrum  sdm_getgaintrackingattspectrum_
extern "C" int sdm_getGainTrackingAttSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, Complex * attSpectrum, int * attSpectrumDim);

int sdm_getGainTrackingAttSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, Complex * attSpectrum, int * attSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	GainTrackingTable &table = dataset->getGainTracking();
	GainTrackingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAttSpectrumExists()) {
			// attr.CppType: vector<Complex > attr.isOneD: true
			for (int i=0; i<min((int)row->getAttSpectrum().size(),attSpectrumDim[1]); i++)
				attSpectrum[i] = row->getAttSpectrum()[i];
			attSpectrumDim[0] = (int)row->getAttSpectrum().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}




// =================== HistoryTable ============================

extern "C" int sdm_addHistoryRow (int * execBlockId, int64_t * time, char * message, int * messageDim, char * priority, int * priorityDim, char * origin, int * originDim, char * objectId, int * objectIdDim, char * application, int * applicationDim, char * cliCommand, int * cliCommandDim, char * appParms, int * appParmsDim);
extern "C" int sdm_getHistoryRow (int * execBlockId, int64_t * time, char * message, int * messageDim, char * priority, int * priorityDim, char * origin, int * originDim, char * objectId, int * objectIdDim, char * application, int * applicationDim, char * cliCommand, int * cliCommandDim, char * appParms, int * appParmsDim);


extern "C" int sdm_getHistoryTableSize ();

extern "C" int sdm_getHistoryKeys (int * execBlockId, int64_t * time);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addHistoryRow (int * execBlockId, int64_t * time, char * message, int * messageDim, char * priority, int * priorityDim, char * origin, int * originDim, char * objectId, int * objectIdDim, char * application, int * applicationDim, char * cliCommand, int * cliCommandDim, char * appParms, int * appParmsDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	HistoryTable &table = dataset->getHistory();
	HistoryRow *row = 0;

	
	// Create new row
  
	row = table.newRow(Tag(*execBlockId,TagType::ExecBlock), ArrayTime(*time), string(message), string(priority), string(origin), string(objectId), string(application), string(cliCommand), string(appParms));

	// Add row
	HistoryRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the HistoryTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a HistoryRow* given a key.
 */
int sdm_getHistoryRow (int * execBlockId, int64_t * time, char * message, int * messageDim, char * priority, int * priorityDim, char * origin, int * originDim, char * objectId, int * objectIdDim, char * application, int * applicationDim, char * cliCommand, int * cliCommandDim, char * appParms, int * appParmsDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	HistoryTable &table = dataset->getHistory();
	HistoryRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), ArrayTime(*time));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  execBlockId  attr.UpperCaseName: ExecBlockId
		//  attr.NameS:  time  attr.UpperCaseName: Time
		//  attr.NameS:  message  attr.UpperCaseName: Message
		if ((int)row->getMessage().size()<messageDim[1])
			strcpy(message,row->getMessage().c_str());
		else
			strncpy(message,row->getMessage().c_str(),messageDim[1]);
		messageDim[0] = (int)row->getMessage().size();
		//  attr.NameS:  priority  attr.UpperCaseName: Priority
		if ((int)row->getPriority().size()<priorityDim[1])
			strcpy(priority,row->getPriority().c_str());
		else
			strncpy(priority,row->getPriority().c_str(),priorityDim[1]);
		priorityDim[0] = (int)row->getPriority().size();
		//  attr.NameS:  origin  attr.UpperCaseName: Origin
		if ((int)row->getOrigin().size()<originDim[1])
			strcpy(origin,row->getOrigin().c_str());
		else
			strncpy(origin,row->getOrigin().c_str(),originDim[1]);
		originDim[0] = (int)row->getOrigin().size();
		//  attr.NameS:  objectId  attr.UpperCaseName: ObjectId
		if ((int)row->getObjectId().size()<objectIdDim[1])
			strcpy(objectId,row->getObjectId().c_str());
		else
			strncpy(objectId,row->getObjectId().c_str(),objectIdDim[1]);
		objectIdDim[0] = (int)row->getObjectId().size();
		//  attr.NameS:  application  attr.UpperCaseName: Application
		if ((int)row->getApplication().size()<applicationDim[1])
			strcpy(application,row->getApplication().c_str());
		else
			strncpy(application,row->getApplication().c_str(),applicationDim[1]);
		applicationDim[0] = (int)row->getApplication().size();
		//  attr.NameS:  cliCommand  attr.UpperCaseName: CliCommand
		if ((int)row->getCliCommand().size()<cliCommandDim[1])
			strcpy(cliCommand,row->getCliCommand().c_str());
		else
			strncpy(cliCommand,row->getCliCommand().c_str(),cliCommandDim[1]);
		cliCommandDim[0] = (int)row->getCliCommand().size();
		//  attr.NameS:  appParms  attr.UpperCaseName: AppParms
		if ((int)row->getAppParms().size()<appParmsDim[1])
			strcpy(appParms,row->getAppParms().c_str());
		else
			strncpy(appParms,row->getAppParms().c_str(),appParmsDim[1]);
		appParmsDim[0] = (int)row->getAppParms().size();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getHistoryTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
HistoryTable &table = dataset->getHistory();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getHistoryKeys(int * execBlockId, int64_t * time) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	HistoryTable &table = dataset->getHistory();
	
	vector< HistoryRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// execBlockId[i] = atoi((row[i]->getExecBlockId().getId()).c_str());
				execBlockId[i] = row[i]->getExecBlockId().getTagValue();
	  		time[i] = row[i]->getTime().get();
  		}
  		
		return size;
  	}
}





using namespace HolographyChannelTypeMod;


// =================== HolographyTable ============================

extern "C" int sdm_addHolographyRow (double * distance, double * focus, int * numCorr, HolographyChannelType * type, int * typeDim);
extern "C" int sdm_getHolographyRow (int * holographyId, double * distance, double * focus, int * numCorr, HolographyChannelType * type, int * typeDim);


extern "C" int sdm_getHolographyTableSize ();

extern "C" int sdm_getHolographyKeys (int * holographyId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addHolographyRow (double * distance, double * focus, int * numCorr, HolographyChannelType * type, int * typeDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	HolographyTable &table = dataset->getHolography();
	HolographyRow *row = 0;

	// type is an Array
	// type is OneD
	vector<HolographyChannelTypeMod::HolographyChannelType >  typeVec(typeDim[0]);
	for (int i=0;i<typeDim[0];i++)
		typeVec[i]= HolographyChannelType(type[i]   );
	
	// Create new row
  
	row = table.newRow(Length(*distance), Length(*focus), *numCorr, typeVec);

	// Add row
	HolographyRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the HolographyTable" << endl;
	}
	
	// return atoi((retRow->getHolographyId().getId()).c_str());
	return retRow->getHolographyId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a HolographyRow* given a key.
 */
int sdm_getHolographyRow (int * holographyId, double * distance, double * focus, int * numCorr, HolographyChannelType * type, int * typeDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	HolographyTable &table = dataset->getHolography();
	HolographyRow *row = 0;
	row = table.getRowByKey( Tag(*holographyId, TagType::Holography));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  holographyId  attr.UpperCaseName: HolographyId
		//  attr.NameS:  distance  attr.UpperCaseName: Distance
		*distance = row->getDistance().get();
		//  attr.NameS:  focus  attr.UpperCaseName: Focus
		*focus = row->getFocus().get();
		//  attr.NameS:  numCorr  attr.UpperCaseName: NumCorr
		*numCorr = row->getNumCorr();
		//  attr.NameS:  type  attr.UpperCaseName: Type
		
		vector<HolographyChannelTypeMod::HolographyChannelType >  typeVec = row->getType();
		
		for (int i=0; i<min((int)typeVec.size(),typeDim[1]); i++)
			type[i] = typeVec[i];
		typeDim[0] = (int)typeVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getHolographyTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
HolographyTable &table = dataset->getHolography();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getHolographyKeys(int * holographyId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	HolographyTable &table = dataset->getHolography();
	
	vector< HolographyRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// holographyId[i] = atoi((row[i]->getHolographyId().getId()).c_str());
				holographyId[i] = row[i]->getHolographyId().getTagValue();
  		}
  		
		return size;
  	}
}





using namespace TimeSamplingMod;


// =================== MainTable ============================

extern "C" int sdm_addMainRow (int64_t * time, int * configDescriptionId, int * fieldId, int * numAntenna, TimeSampling * timeSampling, int64_t * interval, int * numIntegration, int * scanNumber, int * subscanNumber, int64_t * dataSize, char * dataUID, int * dataUIDDim, int * stateId, int * stateIdDim, int * execBlockId);
extern "C" int sdm_getMainRow (int64_t * time, int * configDescriptionId, int * fieldId, int * numAntenna, TimeSampling * timeSampling, int64_t * interval, int * numIntegration, int * scanNumber, int * subscanNumber, int64_t * dataSize, char * dataUID, int * dataUIDDim, int * stateId, int * stateIdDim, int * execBlockId);


extern "C" int sdm_getMainTableSize ();

extern "C" int sdm_getMainKeys (int64_t * time, int * configDescriptionId, int * fieldId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addMainRow (int64_t * time, int * configDescriptionId, int * fieldId, int * numAntenna, TimeSampling * timeSampling, int64_t * interval, int * numIntegration, int * scanNumber, int * subscanNumber, int64_t * dataSize, char * dataUID, int * dataUIDDim, int * stateId, int * stateIdDim, int * execBlockId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	MainTable &table = dataset->getMain();
	MainRow *row = 0;

	// timeSampling is an enumeration
	// TimeSampling * timeSampling =  (int) timeSampling;
	// stateId is an Array
	// stateId is OneD
	vector<Tag>   stateIdVec(stateIdDim[0]);
	for (int i=0;i<stateIdDim[0];i++)
		stateIdVec[i]= Tag(stateId[i]   , TagType::State);
	
	// Create new row
  
	row = table.newRow(ArrayTime(*time), Tag(*configDescriptionId,TagType::ConfigDescription), Tag(*fieldId,TagType::Field), *numAntenna, *timeSampling, Interval(*interval), *numIntegration, *scanNumber, *subscanNumber, *dataSize, EntityRef(string(dataUID)), stateIdVec, Tag(*execBlockId,TagType::ExecBlock));

	// Add row
	MainRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the MainTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a MainRow* given a key.
 */
int sdm_getMainRow (int64_t * time, int * configDescriptionId, int * fieldId, int * numAntenna, TimeSampling * timeSampling, int64_t * interval, int * numIntegration, int * scanNumber, int * subscanNumber, int64_t * dataSize, char * dataUID, int * dataUIDDim, int * stateId, int * stateIdDim, int * execBlockId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	MainTable &table = dataset->getMain();
	MainRow *row = 0;
	row = table.getRowByKey( ArrayTime(*time), Tag(*configDescriptionId, TagType::ConfigDescription), Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  time  attr.UpperCaseName: Time
		//  attr.NameS:  configDescriptionId  attr.UpperCaseName: ConfigDescriptionId
		//  attr.NameS:  fieldId  attr.UpperCaseName: FieldId
		//  attr.NameS:  numAntenna  attr.UpperCaseName: NumAntenna
		*numAntenna = row->getNumAntenna();
		//  attr.NameS:  timeSampling  attr.UpperCaseName: TimeSampling
		*timeSampling = row->getTimeSampling();
		//  attr.NameS:  interval  attr.UpperCaseName: Interval
		*interval = row->getInterval().get();
		//  attr.NameS:  numIntegration  attr.UpperCaseName: NumIntegration
		*numIntegration = row->getNumIntegration();
		//  attr.NameS:  scanNumber  attr.UpperCaseName: ScanNumber
		*scanNumber = row->getScanNumber();
		//  attr.NameS:  subscanNumber  attr.UpperCaseName: SubscanNumber
		*subscanNumber = row->getSubscanNumber();
		//  attr.NameS:  dataSize  attr.UpperCaseName: DataSize
		*dataSize = row->getDataSize();
		//  attr.NameS:  dataUID  attr.UpperCaseName: DataUID
		strcpy(dataUID,row->getDataUID().toString().c_str());
		//  attr.NameS:  stateId  attr.UpperCaseName: StateId
		
		vector<Tag>   stateIdVec = row->getStateId();
		
		for (int i=0; i<min((int)stateIdVec.size(),stateIdDim[1]); i++)
			//stateId[i] = atoi((row->getStateId()[i]).getId().c_str());
		stateId[i] = stateIdVec[i].getTagValue();
		stateIdDim[0] = (int)stateIdVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  execBlockId  attr.UpperCaseName: ExecBlockId
		// *execBlockId = atoi((row->getExecBlockId().getId()).c_str());
		*execBlockId = row->getExecBlockId().getTagValue();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getMainTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
MainTable &table = dataset->getMain();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getMainKeys(int64_t * time, int * configDescriptionId, int * fieldId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	MainTable &table = dataset->getMain();
	
	vector< MainRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		time[i] = row[i]->getTime().get();
	  		// configDescriptionId[i] = atoi((row[i]->getConfigDescriptionId().getId()).c_str());
				configDescriptionId[i] = row[i]->getConfigDescriptionId().getTagValue();
	  		// fieldId[i] = atoi((row[i]->getFieldId().getId()).c_str());
				fieldId[i] = row[i]->getFieldId().getTagValue();
  		}
  		
		return size;
  	}
}







// =================== ObservationTable ============================

extern "C" int sdm_addObservationRow ();
extern "C" int sdm_getObservationRow (int * observationId);


extern "C" int sdm_getObservationTableSize ();

extern "C" int sdm_getObservationKeys (int * observationId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addObservationRow (){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	ObservationTable &table = dataset->getObservation();
	ObservationRow *row = 0;

	
	// Create new row
  
	row = table.newRow();

	// Add row
	ObservationRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the ObservationTable" << endl;
	}
	
	// return atoi((retRow->getObservationId().getId()).c_str());
	return retRow->getObservationId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a ObservationRow* given a key.
 */
int sdm_getObservationRow (int * observationId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ObservationTable &table = dataset->getObservation();
	ObservationRow *row = 0;
	row = table.getRowByKey( Tag(*observationId, TagType::Observation));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  observationId  attr.UpperCaseName: ObservationId
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getObservationTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
ObservationTable &table = dataset->getObservation();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getObservationKeys(int * observationId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	ObservationTable &table = dataset->getObservation();
	
	vector< ObservationRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// observationId[i] = atoi((row[i]->getObservationId().getId()).c_str());
				observationId[i] = row[i]->getObservationId().getTagValue();
  		}
  		
		return size;
  	}
}





using namespace PolarizationTypeMod;
using namespace ReceiverBandMod;


// =================== PointingModelTable ============================

extern "C" int sdm_addPointingModelRow (int * antennaId, int * numCoeff, char * coeffName, int * coeffNameDim, float * coeffVal, int * coeffValDim, PolarizationType * polarizationType, ReceiverBand * receiverBand, char * assocNature, int * assocNatureDim, int * assocPointingModelId);
extern "C" int sdm_getPointingModelRow (int * antennaId, int * pointingModelId, int * numCoeff, char * coeffName, int * coeffNameDim, float * coeffVal, int * coeffValDim, PolarizationType * polarizationType, ReceiverBand * receiverBand, char * assocNature, int * assocNatureDim, int * assocPointingModelId);


extern "C" int sdm_getPointingModelTableSize ();

extern "C" int sdm_getPointingModelKeys (int * antennaId, int * pointingModelId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addPointingModelRow (int * antennaId, int * numCoeff, char * coeffName, int * coeffNameDim, float * coeffVal, int * coeffValDim, PolarizationType * polarizationType, ReceiverBand * receiverBand, char * assocNature, int * assocNatureDim, int * assocPointingModelId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	PointingModelTable &table = dataset->getPointingModel();
	PointingModelRow *row = 0;

	// coeffName is an Array
	// coeffName is OneD
	vector<string >  coeffNameVec(coeffNameDim[2]);
	for (int i=0;i<coeffNameDim[2];i++)
		coeffNameVec[i]= string(coeffName+i*coeffNameDim[1]  );
	// coeffVal is an Array
	// coeffVal is OneD
	vector<float >  coeffValVec(coeffValDim[0]);
	for (int i=0;i<coeffValDim[0];i++)
		coeffValVec[i]= float(coeffVal[i]   );
	// polarizationType is an enumeration
	// PolarizationType * polarizationType =  (int) polarizationType;
	// receiverBand is an enumeration
	// ReceiverBand * receiverBand =  (int) receiverBand;
	
	// Create new row
  
	row = table.newRow(Tag(*antennaId,TagType::Antenna), *numCoeff, coeffNameVec, coeffValVec, *polarizationType, *receiverBand, string(assocNature), *assocPointingModelId);

	// Add row
	PointingModelRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the PointingModelTable" << endl;
	}
	
	return retRow->getPointingModelId();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a PointingModelRow* given a key.
 */
int sdm_getPointingModelRow (int * antennaId, int * pointingModelId, int * numCoeff, char * coeffName, int * coeffNameDim, float * coeffVal, int * coeffValDim, PolarizationType * polarizationType, ReceiverBand * receiverBand, char * assocNature, int * assocNatureDim, int * assocPointingModelId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingModelTable &table = dataset->getPointingModel();
	PointingModelRow *row = 0;
	row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), *pointingModelId);
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  pointingModelId  attr.UpperCaseName: PointingModelId
		//  attr.NameS:  numCoeff  attr.UpperCaseName: NumCoeff
		*numCoeff = row->getNumCoeff();
		//  attr.NameS:  coeffName  attr.UpperCaseName: CoeffName
		
		vector<string >  coeffNameVec = row->getCoeffName();
		
		int maxDimZeroCoeffName = 0;
		for (int i=0; i<min((int)coeffNameVec.size(),coeffNameDim[3]); i++) {
			if ((int)coeffNameVec[i].size()<coeffNameDim[1])
				strcpy(coeffName+i*coeffNameDim[1],coeffNameVec[i].c_str());
			else
				strncpy(coeffName+i*coeffNameDim[1],coeffNameVec[i].c_str(),coeffNameDim[1]);
			maxDimZeroCoeffName = max((int)coeffNameVec[i].size(),maxDimZeroCoeffName);
		}
		coeffNameDim[0] = maxDimZeroCoeffName;
		coeffNameDim[2] = coeffNameVec.size();  // number of strings
		
		
		//  attr.NameS:  coeffVal  attr.UpperCaseName: CoeffVal
		
		vector<float >  coeffValVec = row->getCoeffVal();
		
		for (int i=0; i<min((int)coeffValVec.size(),coeffValDim[1]); i++)
			coeffVal[i] = coeffValVec[i];
		coeffValDim[0] = (int)coeffValVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  polarizationType  attr.UpperCaseName: PolarizationType
		*polarizationType = row->getPolarizationType();
		//  attr.NameS:  receiverBand  attr.UpperCaseName: ReceiverBand
		*receiverBand = row->getReceiverBand();
		//  attr.NameS:  assocNature  attr.UpperCaseName: AssocNature
		if ((int)row->getAssocNature().size()<assocNatureDim[1])
			strcpy(assocNature,row->getAssocNature().c_str());
		else
			strncpy(assocNature,row->getAssocNature().c_str(),assocNatureDim[1]);
		assocNatureDim[0] = (int)row->getAssocNature().size();
		//  attr.NameS:  assocPointingModelId  attr.UpperCaseName: AssocPointingModelId
		*assocPointingModelId = row->getAssocPointingModelId();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getPointingModelTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
PointingModelTable &table = dataset->getPointingModel();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getPointingModelKeys(int * antennaId, int * pointingModelId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	PointingModelTable &table = dataset->getPointingModel();
	
	vector< PointingModelRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		pointingModelId[i] = row[i]->getPointingModelId();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter coeffFormula, in a row of the PointingModel table, given a key
 *
 */

#define sdm_addPointingModelCoeffFormula  sdm_addpointingmodelcoeffformula_
extern "C" int sdm_addPointingModelCoeffFormula(int * antennaId, int * pointingModelId, char * coeffFormula, int * coeffFormulaDim);

int sdm_addPointingModelCoeffFormula(int * antennaId, int * pointingModelId, char * coeffFormula, int * coeffFormulaDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingModelTable &table = dataset->getPointingModel();
	
	PointingModelRow *row = 0;
	row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), *pointingModelId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<string >  coeffFormulaVec(coeffFormulaDim[2]);
		for (int i=0;i<coeffFormulaDim[2];i++)
			coeffFormulaVec[i]= string(coeffFormula+i*coeffFormulaDim[1]  
		row->setCoeffFormula(coeffFormulaVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter coeffFormula, in a row of the PointingModel table, given a key
 *
 */

#define sdm_getPointingModelCoeffFormula  sdm_getpointingmodelcoeffformula_
extern "C" int sdm_getPointingModelCoeffFormula(int * antennaId, int * pointingModelId, char * coeffFormula, int * coeffFormulaDim);

int sdm_getPointingModelCoeffFormula(int * antennaId, int * pointingModelId, char * coeffFormula, int * coeffFormulaDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	PointingModelTable &table = dataset->getPointingModel();
	PointingModelRow *row = 0;
	row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), *pointingModelId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCoeffFormulaExists()) {
			// attr.CppType: vector<string > attr.isOneD: true
			int maxDimZeroCoeffFormula = 0;
			for (int i=0; i<min((int)row->getCoeffFormula().size(),coeffFormulaDim[3]); i++) {
				if ((int)row->getCoeffFormula()[i].size()<coeffFormulaDim[1])
					strcpy(coeffFormula+i*coeffFormulaDim[1],row->getCoeffFormula()[i].c_str());
				else
					strncpy(coeffFormula+i*coeffFormulaDim[1],row->getCoeffFormula()[i].c_str(),coeffFormulaDim[1]);
				maxDimZeroCoeffFormula = max((int)row->getCoeffFormula()[i].size(),maxDimZeroCoeffFormula);
			}
			coeffFormulaDim[0] = maxDimZeroCoeffFormula;
			coeffFormulaDim[2] = row->getCoeffFormula().size();  // number of strings
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace DirectionReferenceCodeMod;


// =================== PointingTable ============================

extern "C" int sdm_addPointingRow (int * antennaId, int64_t * timeInterval, int * numSample, double * encoder, int * encoderDim, bool * pointingTracking, bool * usePolynomials, int64_t * timeOrigin, int * numTerm, double * pointingDirection, int * pointingDirectionDim, double * target, int * targetDim, double * offset, int * offsetDim, int * pointingModelId);
extern "C" int sdm_getPointingRow (int * antennaId, int64_t * timeInterval, int * numSample, double * encoder, int * encoderDim, bool * pointingTracking, bool * usePolynomials, int64_t * timeOrigin, int * numTerm, double * pointingDirection, int * pointingDirectionDim, double * target, int * targetDim, double * offset, int * offsetDim, int * pointingModelId);


extern "C" int sdm_getPointingTableSize ();

extern "C" int sdm_getPointingKeys (int * antennaId, int64_t * timeInterval);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addPointingRow (int * antennaId, int64_t * timeInterval, int * numSample, double * encoder, int * encoderDim, bool * pointingTracking, bool * usePolynomials, int64_t * timeOrigin, int * numTerm, double * pointingDirection, int * pointingDirectionDim, double * target, int * targetDim, double * offset, int * offsetDim, int * pointingModelId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	PointingTable &table = dataset->getPointing();
	PointingRow *row = 0;

	// encoder is an Array
	// encoder is 2 D
	vector<vector<Angle > >  encoderVec(encoderDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<encoderDim[2];i++) {
		encoderVec[i].resize(encoderDim[0]);
		for (int j=0;j<encoderDim[0];j++)
			encoderVec[i][j]= Angle(encoder[i*encoderDim[1]+j]  );
	
	
	}
	// pointingDirection is an Array
	// pointingDirection is 2 D
	vector<vector<Angle > >  pointingDirectionVec(pointingDirectionDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<pointingDirectionDim[2];i++) {
		pointingDirectionVec[i].resize(pointingDirectionDim[0]);
		for (int j=0;j<pointingDirectionDim[0];j++)
			pointingDirectionVec[i][j]= Angle(pointingDirection[i*pointingDirectionDim[1]+j]  );
	
	
	}
	// target is an Array
	// target is 2 D
	vector<vector<Angle > >  targetVec(targetDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<targetDim[2];i++) {
		targetVec[i].resize(targetDim[0]);
		for (int j=0;j<targetDim[0];j++)
			targetVec[i][j]= Angle(target[i*targetDim[1]+j]  );
	
	
	}
	// offset is an Array
	// offset is 2 D
	vector<vector<Angle > >  offsetVec(offsetDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<offsetDim[2];i++) {
		offsetVec[i].resize(offsetDim[0]);
		for (int j=0;j<offsetDim[0];j++)
			offsetVec[i][j]= Angle(offset[i*offsetDim[1]+j]  );
	
	
	}
	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *numSample, encoderVec, *pointingTracking, *usePolynomials, ArrayTime(*timeOrigin), *numTerm, pointingDirectionVec, targetVec, offsetVec, *pointingModelId);
	} else {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), ArrayTimeInterval(*timeInterval), *numSample, encoderVec, *pointingTracking, *usePolynomials, ArrayTime(*timeOrigin), *numTerm, pointingDirectionVec, targetVec, offsetVec, *pointingModelId);
	}

	// Add row
	PointingRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the PointingTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a PointingRow* given a key.
 */
int sdm_getPointingRow (int * antennaId, int64_t * timeInterval, int * numSample, double * encoder, int * encoderDim, bool * pointingTracking, bool * usePolynomials, int64_t * timeOrigin, int * numTerm, double * pointingDirection, int * pointingDirectionDim, double * target, int * targetDim, double * offset, int * offsetDim, int * pointingModelId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  numSample  attr.UpperCaseName: NumSample
		*numSample = row->getNumSample();
		//  attr.NameS:  encoder  attr.UpperCaseName: Encoder
		
		vector<vector<Angle > >  encoderVec = row->getEncoder();
		
		int maxDimZeroEncoder = 0;
		for (int i=0; i< min((int)encoderVec.size(),encoderDim[3]) ;i++) {
			maxDimZeroEncoder = max((int)encoderVec[i].size(),maxDimZeroEncoder);
			for (int j=0; j<min((int)encoderVec[i].size(),encoderDim[1]) ;j++) {
				encoder[i*encoderDim[1]+j] = encoderVec[i][j].get();
			}
		}
		encoderDim[0] = maxDimZeroEncoder;
		encoderDim[2] = encoderVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  pointingTracking  attr.UpperCaseName: PointingTracking
		*pointingTracking = row->getPointingTracking();
		//  attr.NameS:  usePolynomials  attr.UpperCaseName: UsePolynomials
		*usePolynomials = row->getUsePolynomials();
		//  attr.NameS:  timeOrigin  attr.UpperCaseName: TimeOrigin
		*timeOrigin     = row->getTimeOrigin().get();
		//  attr.NameS:  numTerm  attr.UpperCaseName: NumTerm
		*numTerm = row->getNumTerm();
		//  attr.NameS:  pointingDirection  attr.UpperCaseName: PointingDirection
		
		vector<vector<Angle > >  pointingDirectionVec = row->getPointingDirection();
		
		int maxDimZeroPointingDirection = 0;
		for (int i=0; i< min((int)pointingDirectionVec.size(),pointingDirectionDim[3]) ;i++) {
			maxDimZeroPointingDirection = max((int)pointingDirectionVec[i].size(),maxDimZeroPointingDirection);
			for (int j=0; j<min((int)pointingDirectionVec[i].size(),pointingDirectionDim[1]) ;j++) {
				pointingDirection[i*pointingDirectionDim[1]+j] = pointingDirectionVec[i][j].get();
			}
		}
		pointingDirectionDim[0] = maxDimZeroPointingDirection;
		pointingDirectionDim[2] = pointingDirectionVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  target  attr.UpperCaseName: Target
		
		vector<vector<Angle > >  targetVec = row->getTarget();
		
		int maxDimZeroTarget = 0;
		for (int i=0; i< min((int)targetVec.size(),targetDim[3]) ;i++) {
			maxDimZeroTarget = max((int)targetVec[i].size(),maxDimZeroTarget);
			for (int j=0; j<min((int)targetVec[i].size(),targetDim[1]) ;j++) {
				target[i*targetDim[1]+j] = targetVec[i][j].get();
			}
		}
		targetDim[0] = maxDimZeroTarget;
		targetDim[2] = targetVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  offset  attr.UpperCaseName: Offset
		
		vector<vector<Angle > >  offsetVec = row->getOffset();
		
		int maxDimZeroOffset = 0;
		for (int i=0; i< min((int)offsetVec.size(),offsetDim[3]) ;i++) {
			maxDimZeroOffset = max((int)offsetVec[i].size(),maxDimZeroOffset);
			for (int j=0; j<min((int)offsetVec[i].size(),offsetDim[1]) ;j++) {
				offset[i*offsetDim[1]+j] = offsetVec[i][j].get();
			}
		}
		offsetDim[0] = maxDimZeroOffset;
		offsetDim[2] = offsetVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  pointingModelId  attr.UpperCaseName: PointingModelId
		*pointingModelId = row->getPointingModelId();
		
		return 1;   // 1 means that the line has been found
	}	
}


// -------------------------------------------
// Columns get methods
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column AntennaId of Table Pointing.
 */
#define sdm_getPointingAntennaIdColumn  sdm_getpointingantennaidcolumn_
extern "C" int sdm_getPointingAntennaIdColumn(int * antennaId);
int sdm_getPointingAntennaIdColumn (int * antennaId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  antennaId  Column: AntennaId
			// Scalar column of Tag
			antennaId[ir] = row[ir]->getAntennaId().getTagValue();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column TimeInterval of Table Pointing.
 */
#define sdm_getPointingTimeIntervalColumn  sdm_getpointingtimeintervalcolumn_
extern "C" int sdm_getPointingTimeIntervalColumn(int64_t * timeInterval);
int sdm_getPointingTimeIntervalColumn (int64_t * timeInterval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  timeInterval  Column: TimeInterval
			// Scalar column of ArrayTimeInterval
			timeInterval[2*ir]  = row[ir]->getTimeInterval().getStartInNanoSeconds();
			timeInterval[2*ir+1] = row[ir]->getTimeInterval().getDurationInNanoSeconds();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column NumSample of Table Pointing.
 */
#define sdm_getPointingNumSampleColumn  sdm_getpointingnumsamplecolumn_
extern "C" int sdm_getPointingNumSampleColumn(int * numSample);
int sdm_getPointingNumSampleColumn (int * numSample) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  numSample  Column: NumSample
			// Scalar column of int
			numSample[ir] = row[ir]->getNumSample();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column Encoder of Table Pointing.
 */
#define sdm_getPointingEncoderColumn  sdm_getpointingencodercolumn_
extern "C" int sdm_getPointingEncoderColumn(double * encoder, int * encoderDim);
int sdm_getPointingEncoderColumn (double * encoder, int * encoderDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  encoder  Column: Encoder
			vector<vector<Angle > >  encoderVec = row[ir]->getEncoder();
			// TwoD column of Angle
			int maxDimZeroEncoder = 0;
			for (int i=0; i<min((int)encoderVec.size(),encoderDim[3]); i++) {
				maxDimZeroEncoder = max((int)encoderVec[i].size(),maxDimZeroEncoder);
				for (int j=0; j<min((int)encoderVec[i].size(), encoderDim[1]) ;j++) {
					encoder[(ir*encoderDim[3]+i)*encoderDim[1]+j]= encoderVec[i][j].get();;
				}
			}
	  			encoderDim[ir*4] = maxDimZeroEncoder; // return the maximum of inner dimension
         		encoderDim[ir*4+2] = encoderVec.size();  // return the outer dimension
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column PointingTracking of Table Pointing.
 */
#define sdm_getPointingPointingTrackingColumn  sdm_getpointingpointingtrackingcolumn_
extern "C" int sdm_getPointingPointingTrackingColumn(bool * pointingTracking);
int sdm_getPointingPointingTrackingColumn (bool * pointingTracking) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  pointingTracking  Column: PointingTracking
			// Scalar column of bool
			pointingTracking[ir] = row[ir]->getPointingTracking();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column UsePolynomials of Table Pointing.
 */
#define sdm_getPointingUsePolynomialsColumn  sdm_getpointingusepolynomialscolumn_
extern "C" int sdm_getPointingUsePolynomialsColumn(bool * usePolynomials);
int sdm_getPointingUsePolynomialsColumn (bool * usePolynomials) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  usePolynomials  Column: UsePolynomials
			// Scalar column of bool
			usePolynomials[ir] = row[ir]->getUsePolynomials();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column TimeOrigin of Table Pointing.
 */
#define sdm_getPointingTimeOriginColumn  sdm_getpointingtimeorigincolumn_
extern "C" int sdm_getPointingTimeOriginColumn(int64_t * timeOrigin);
int sdm_getPointingTimeOriginColumn (int64_t * timeOrigin) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  timeOrigin  Column: TimeOrigin
			// Scalar column of ArrayTime
			timeOrigin[ir]     = row[ir]->getTimeOrigin().get();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column NumTerm of Table Pointing.
 */
#define sdm_getPointingNumTermColumn  sdm_getpointingnumtermcolumn_
extern "C" int sdm_getPointingNumTermColumn(int * numTerm);
int sdm_getPointingNumTermColumn (int * numTerm) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  numTerm  Column: NumTerm
			// Scalar column of int
			numTerm[ir] = row[ir]->getNumTerm();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column PointingDirection of Table Pointing.
 */
#define sdm_getPointingPointingDirectionColumn  sdm_getpointingpointingdirectioncolumn_
extern "C" int sdm_getPointingPointingDirectionColumn(double * pointingDirection, int * pointingDirectionDim);
int sdm_getPointingPointingDirectionColumn (double * pointingDirection, int * pointingDirectionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  pointingDirection  Column: PointingDirection
			vector<vector<Angle > >  pointingDirectionVec = row[ir]->getPointingDirection();
			// TwoD column of Angle
			int maxDimZeroPointingDirection = 0;
			for (int i=0; i<min((int)pointingDirectionVec.size(),pointingDirectionDim[3]); i++) {
				maxDimZeroPointingDirection = max((int)pointingDirectionVec[i].size(),maxDimZeroPointingDirection);
				for (int j=0; j<min((int)pointingDirectionVec[i].size(), pointingDirectionDim[1]) ;j++) {
					pointingDirection[(ir*pointingDirectionDim[3]+i)*pointingDirectionDim[1]+j]= pointingDirectionVec[i][j].get();;
				}
			}
	  			pointingDirectionDim[ir*4] = maxDimZeroPointingDirection; // return the maximum of inner dimension
         		pointingDirectionDim[ir*4+2] = pointingDirectionVec.size();  // return the outer dimension
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column Target of Table Pointing.
 */
#define sdm_getPointingTargetColumn  sdm_getpointingtargetcolumn_
extern "C" int sdm_getPointingTargetColumn(double * target, int * targetDim);
int sdm_getPointingTargetColumn (double * target, int * targetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  target  Column: Target
			vector<vector<Angle > >  targetVec = row[ir]->getTarget();
			// TwoD column of Angle
			int maxDimZeroTarget = 0;
			for (int i=0; i<min((int)targetVec.size(),targetDim[3]); i++) {
				maxDimZeroTarget = max((int)targetVec[i].size(),maxDimZeroTarget);
				for (int j=0; j<min((int)targetVec[i].size(), targetDim[1]) ;j++) {
					target[(ir*targetDim[3]+i)*targetDim[1]+j]= targetVec[i][j].get();;
				}
			}
	  			targetDim[ir*4] = maxDimZeroTarget; // return the maximum of inner dimension
         		targetDim[ir*4+2] = targetVec.size();  // return the outer dimension
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column Offset of Table Pointing.
 */
#define sdm_getPointingOffsetColumn  sdm_getpointingoffsetcolumn_
extern "C" int sdm_getPointingOffsetColumn(double * offset, int * offsetDim);
int sdm_getPointingOffsetColumn (double * offset, int * offsetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  offset  Column: Offset
			vector<vector<Angle > >  offsetVec = row[ir]->getOffset();
			// TwoD column of Angle
			int maxDimZeroOffset = 0;
			for (int i=0; i<min((int)offsetVec.size(),offsetDim[3]); i++) {
				maxDimZeroOffset = max((int)offsetVec[i].size(),maxDimZeroOffset);
				for (int j=0; j<min((int)offsetVec[i].size(), offsetDim[1]) ;j++) {
					offset[(ir*offsetDim[3]+i)*offsetDim[1]+j]= offsetVec[i][j].get();;
				}
			}
	  			offsetDim[ir*4] = maxDimZeroOffset; // return the maximum of inner dimension
         		offsetDim[ir*4+2] = offsetVec.size();  // return the outer dimension
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column PointingModelId of Table Pointing.
 */
#define sdm_getPointingPointingModelIdColumn  sdm_getpointingpointingmodelidcolumn_
extern "C" int sdm_getPointingPointingModelIdColumn(int * pointingModelId);
int sdm_getPointingPointingModelIdColumn (int * pointingModelId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	vector< PointingRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  pointingModelId  Column: PointingModelId
			// Scalar column of int
			pointingModelId[ir] = row[ir]->getPointingModelId();
		}
	}
	return size ;   // return the size of the table  
}


// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getPointingTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
PointingTable &table = dataset->getPointing();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getPointingKeys(int * antennaId, int64_t * timeInterval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	PointingTable &table = dataset->getPointing();
	
	vector< PointingRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter overTheTop, in a row of the Pointing table, given a key
 *
 */

#define sdm_addPointingOverTheTop  sdm_addpointingoverthetop_
extern "C" int sdm_addPointingOverTheTop(int * antennaId, int64_t * timeInterval, bool * overTheTop);

int sdm_addPointingOverTheTop(int * antennaId, int64_t * timeInterval, bool * overTheTop) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setOverTheTop(bool(* overTheTop ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter overTheTop, in a row of the Pointing table, given a key
 *
 */

#define sdm_getPointingOverTheTop  sdm_getpointingoverthetop_
extern "C" int sdm_getPointingOverTheTop(int * antennaId, int64_t * timeInterval, bool * overTheTop);

int sdm_getPointingOverTheTop(int * antennaId, int64_t * timeInterval, bool * overTheTop) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	PointingTable &table = dataset->getPointing();
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isOverTheTopExists()) {
			*overTheTop = row->getOverTheTop();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sourceOffset, in a row of the Pointing table, given a key
 *
 */

#define sdm_addPointingSourceOffset  sdm_addpointingsourceoffset_
extern "C" int sdm_addPointingSourceOffset(int * antennaId, int64_t * timeInterval, double * sourceOffset, int * sourceOffsetDim);

int sdm_addPointingSourceOffset(int * antennaId, int64_t * timeInterval, double * sourceOffset, int * sourceOffsetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par sourceOffset:
		vector<vector<Angle > >  sourceOffsetVec(sourceOffsetDim[2]);
		for (int i=0;i<sourceOffsetDim[2];i++) {
			sourceOffsetVec[i].resize(sourceOffsetDim[0]);
			for (int j=0;j<sourceOffsetDim[0];j++)
				sourceOffsetVec[i][j]= Angle(sourceOffset[i*(sourceOffsetDim[1])+j]);
		}
		row->setSourceOffset(sourceOffsetVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sourceOffset, in a row of the Pointing table, given a key
 *
 */

#define sdm_getPointingSourceOffset  sdm_getpointingsourceoffset_
extern "C" int sdm_getPointingSourceOffset(int * antennaId, int64_t * timeInterval, double * sourceOffset, int * sourceOffsetDim);

int sdm_getPointingSourceOffset(int * antennaId, int64_t * timeInterval, double * sourceOffset, int * sourceOffsetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	PointingTable &table = dataset->getPointing();
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSourceOffsetExists()) {
			// attr.CppType: vector<vector<Angle > > attr.isOneD: false
			int maxDimZeroSourceOffset = 0;
			for (int i=0; i< min((int)row->getSourceOffset().size(),sourceOffsetDim[3]) ;i++) {
				maxDimZeroSourceOffset = max((int)row->getSourceOffset()[i].size(),maxDimZeroSourceOffset);
				for (int j=0; j<min((int)row->getSourceOffset()[i].size(),sourceOffsetDim[1]) ;j++) {
					sourceOffset[i*sourceOffsetDim[1]+j] = row->getSourceOffset()[i][j].get();
				}
			}
			sourceOffsetDim[0] = maxDimZeroSourceOffset;
			sourceOffsetDim[2] = row->getSourceOffset().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sourceOffsetReferenceCode, in a row of the Pointing table, given a key
 *
 */

#define sdm_addPointingSourceOffsetReferenceCode  sdm_addpointingsourceoffsetreferencecode_
extern "C" int sdm_addPointingSourceOffsetReferenceCode(int * antennaId, int64_t * timeInterval, DirectionReferenceCode * sourceOffsetReferenceCode);

int sdm_addPointingSourceOffsetReferenceCode(int * antennaId, int64_t * timeInterval, DirectionReferenceCode * sourceOffsetReferenceCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSourceOffsetReferenceCode(DirectionReferenceCode(* sourceOffsetReferenceCode ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sourceOffsetReferenceCode, in a row of the Pointing table, given a key
 *
 */

#define sdm_getPointingSourceOffsetReferenceCode  sdm_getpointingsourceoffsetreferencecode_
extern "C" int sdm_getPointingSourceOffsetReferenceCode(int * antennaId, int64_t * timeInterval, DirectionReferenceCode * sourceOffsetReferenceCode);

int sdm_getPointingSourceOffsetReferenceCode(int * antennaId, int64_t * timeInterval, DirectionReferenceCode * sourceOffsetReferenceCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	PointingTable &table = dataset->getPointing();
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSourceOffsetReferenceCodeExists()) {
			*sourceOffsetReferenceCode = row->getSourceOffsetReferenceCode();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sourceOffsetEquinox, in a row of the Pointing table, given a key
 *
 */

#define sdm_addPointingSourceOffsetEquinox  sdm_addpointingsourceoffsetequinox_
extern "C" int sdm_addPointingSourceOffsetEquinox(int * antennaId, int64_t * timeInterval, int64_t * sourceOffsetEquinox);

int sdm_addPointingSourceOffsetEquinox(int * antennaId, int64_t * timeInterval, int64_t * sourceOffsetEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSourceOffsetEquinox(ArrayTime(* sourceOffsetEquinox ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sourceOffsetEquinox, in a row of the Pointing table, given a key
 *
 */

#define sdm_getPointingSourceOffsetEquinox  sdm_getpointingsourceoffsetequinox_
extern "C" int sdm_getPointingSourceOffsetEquinox(int * antennaId, int64_t * timeInterval, int64_t * sourceOffsetEquinox);

int sdm_getPointingSourceOffsetEquinox(int * antennaId, int64_t * timeInterval, int64_t * sourceOffsetEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	PointingTable &table = dataset->getPointing();
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSourceOffsetEquinoxExists()) {
			*sourceOffsetEquinox     = row->getSourceOffsetEquinox().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sampledTimeInterval, in a row of the Pointing table, given a key
 *
 */

#define sdm_addPointingSampledTimeInterval  sdm_addpointingsampledtimeinterval_
extern "C" int sdm_addPointingSampledTimeInterval(int * antennaId, int64_t * timeInterval, int64_t * sampledTimeInterval, int * sampledTimeIntervalDim);

int sdm_addPointingSampledTimeInterval(int * antennaId, int64_t * timeInterval, int64_t * sampledTimeInterval, int * sampledTimeIntervalDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<ArrayTimeInterval >  sampledTimeIntervalVec(sampledTimeIntervalDim[0]);
		for (int i=0;i<sampledTimeIntervalDim[0];i++)
			sampledTimeIntervalVec[i]= ArrayTimeInterval(sampledTimeInterval[2*i], sampledTimeInterval[2*i+1]);
		row->setSampledTimeInterval(sampledTimeIntervalVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sampledTimeInterval, in a row of the Pointing table, given a key
 *
 */

#define sdm_getPointingSampledTimeInterval  sdm_getpointingsampledtimeinterval_
extern "C" int sdm_getPointingSampledTimeInterval(int * antennaId, int64_t * timeInterval, int64_t * sampledTimeInterval, int * sampledTimeIntervalDim);

int sdm_getPointingSampledTimeInterval(int * antennaId, int64_t * timeInterval, int64_t * sampledTimeInterval, int * sampledTimeIntervalDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	PointingTable &table = dataset->getPointing();
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSampledTimeIntervalExists()) {
			// attr.CppType: vector<ArrayTimeInterval > attr.isOneD: true
			for (int i=0; i<min((int)row->getSampledTimeInterval().size(),sampledTimeIntervalDim[1]); i++) {
				sampledTimeInterval[2*i] = row->getSampledTimeInterval()[i].getStartInNanoSeconds();
				sampledTimeInterval[2*i+1] = row->getSampledTimeInterval()[i].getDurationInNanoSeconds();
			}
			sampledTimeIntervalDim[0] = row->getSampledTimeInterval().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter atmosphericCorrection, in a row of the Pointing table, given a key
 *
 */

#define sdm_addPointingAtmosphericCorrection  sdm_addpointingatmosphericcorrection_
extern "C" int sdm_addPointingAtmosphericCorrection(int * antennaId, int64_t * timeInterval, double * atmosphericCorrection, int * atmosphericCorrectionDim);

int sdm_addPointingAtmosphericCorrection(int * antennaId, int64_t * timeInterval, double * atmosphericCorrection, int * atmosphericCorrectionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PointingTable &table = dataset->getPointing();
	
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par atmosphericCorrection:
		vector<vector<Angle > >  atmosphericCorrectionVec(atmosphericCorrectionDim[2]);
		for (int i=0;i<atmosphericCorrectionDim[2];i++) {
			atmosphericCorrectionVec[i].resize(atmosphericCorrectionDim[0]);
			for (int j=0;j<atmosphericCorrectionDim[0];j++)
				atmosphericCorrectionVec[i][j]= Angle(atmosphericCorrection[i*(atmosphericCorrectionDim[1])+j]);
		}
		row->setAtmosphericCorrection(atmosphericCorrectionVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter atmosphericCorrection, in a row of the Pointing table, given a key
 *
 */

#define sdm_getPointingAtmosphericCorrection  sdm_getpointingatmosphericcorrection_
extern "C" int sdm_getPointingAtmosphericCorrection(int * antennaId, int64_t * timeInterval, double * atmosphericCorrection, int * atmosphericCorrectionDim);

int sdm_getPointingAtmosphericCorrection(int * antennaId, int64_t * timeInterval, double * atmosphericCorrection, int * atmosphericCorrectionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	PointingTable &table = dataset->getPointing();
	PointingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAtmosphericCorrectionExists()) {
			// attr.CppType: vector<vector<Angle > > attr.isOneD: false
			int maxDimZeroAtmosphericCorrection = 0;
			for (int i=0; i< min((int)row->getAtmosphericCorrection().size(),atmosphericCorrectionDim[3]) ;i++) {
				maxDimZeroAtmosphericCorrection = max((int)row->getAtmosphericCorrection()[i].size(),maxDimZeroAtmosphericCorrection);
				for (int j=0; j<min((int)row->getAtmosphericCorrection()[i].size(),atmosphericCorrectionDim[1]) ;j++) {
					atmosphericCorrection[i*atmosphericCorrectionDim[1]+j] = row->getAtmosphericCorrection()[i][j].get();
				}
			}
			atmosphericCorrectionDim[0] = maxDimZeroAtmosphericCorrection;
			atmosphericCorrectionDim[2] = row->getAtmosphericCorrection().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace StokesParameterMod;
using namespace PolarizationTypeMod;


// =================== PolarizationTable ============================

extern "C" int sdm_addPolarizationRow (int * numCorr, StokesParameter * corrType, int * corrTypeDim, PolarizationType * corrProduct, int * corrProductDim);
extern "C" int sdm_getPolarizationRow (int * polarizationId, int * numCorr, StokesParameter * corrType, int * corrTypeDim, PolarizationType * corrProduct, int * corrProductDim);


extern "C" int sdm_getPolarizationTableSize ();

extern "C" int sdm_getPolarizationKeys (int * polarizationId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addPolarizationRow (int * numCorr, StokesParameter * corrType, int * corrTypeDim, PolarizationType * corrProduct, int * corrProductDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	PolarizationTable &table = dataset->getPolarization();
	PolarizationRow *row = 0;

	// corrType is an Array
	// corrType is OneD
	vector<StokesParameterMod::StokesParameter >  corrTypeVec(corrTypeDim[0]);
	for (int i=0;i<corrTypeDim[0];i++)
		corrTypeVec[i]= StokesParameter(corrType[i]   );
	// corrProduct is an Array
	// corrProduct is 2 D
	vector<vector<PolarizationTypeMod::PolarizationType > >  corrProductVec(corrProductDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<corrProductDim[2];i++) {
		corrProductVec[i].resize(corrProductDim[0]);
		for (int j=0;j<corrProductDim[0];j++)
			corrProductVec[i][j]= PolarizationType(corrProduct[i*corrProductDim[1]+j]  );
	
	
	}
	
	// Create new row
  
	row = table.newRow(*numCorr, corrTypeVec, corrProductVec);

	// Add row
	PolarizationRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the PolarizationTable" << endl;
	}
	
	// return atoi((retRow->getPolarizationId().getId()).c_str());
	return retRow->getPolarizationId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a PolarizationRow* given a key.
 */
int sdm_getPolarizationRow (int * polarizationId, int * numCorr, StokesParameter * corrType, int * corrTypeDim, PolarizationType * corrProduct, int * corrProductDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	PolarizationTable &table = dataset->getPolarization();
	PolarizationRow *row = 0;
	row = table.getRowByKey( Tag(*polarizationId, TagType::Polarization));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  polarizationId  attr.UpperCaseName: PolarizationId
		//  attr.NameS:  numCorr  attr.UpperCaseName: NumCorr
		*numCorr = row->getNumCorr();
		//  attr.NameS:  corrType  attr.UpperCaseName: CorrType
		
		vector<StokesParameterMod::StokesParameter >  corrTypeVec = row->getCorrType();
		
		for (int i=0; i<min((int)corrTypeVec.size(),corrTypeDim[1]); i++)
			corrType[i] = corrTypeVec[i];
		corrTypeDim[0] = (int)corrTypeVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  corrProduct  attr.UpperCaseName: CorrProduct
		
		vector<vector<PolarizationTypeMod::PolarizationType > >  corrProductVec = row->getCorrProduct();
		
		int maxDimZeroCorrProduct = 0;
		for (int i=0;i<min((int)corrProductVec.size(),corrProductDim[3]) ;i++) {
			maxDimZeroCorrProduct = max((int)corrProductVec[i].size(),maxDimZeroCorrProduct);
			for (int j=0;j<min((int)corrProductVec[i].size(),corrProductDim[1]) ;j++) {
				corrProduct[i*corrProductDim[1]+j]= corrProductVec[i][j];
			}
		}
		corrProductDim[0] = maxDimZeroCorrProduct;
		corrProductDim[2] = corrProductVec.size();  // return dimension of the ASDM
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getPolarizationTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
PolarizationTable &table = dataset->getPolarization();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getPolarizationKeys(int * polarizationId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	PolarizationTable &table = dataset->getPolarization();
	
	vector< PolarizationRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// polarizationId[i] = atoi((row[i]->getPolarizationId().getId()).c_str());
				polarizationId[i] = row[i]->getPolarizationId().getTagValue();
  		}
  		
		return size;
  	}
}





using namespace ProcessorTypeMod;
using namespace ProcessorSubTypeMod;


// =================== ProcessorTable ============================

extern "C" int sdm_addProcessorRow (int * modeId, ProcessorType * processorType, ProcessorSubType * processorSubType);
extern "C" int sdm_getProcessorRow (int * processorId, int * modeId, ProcessorType * processorType, ProcessorSubType * processorSubType);


extern "C" int sdm_getProcessorTableSize ();

extern "C" int sdm_getProcessorKeys (int * processorId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addProcessorRow (int * modeId, ProcessorType * processorType, ProcessorSubType * processorSubType){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	ProcessorTable &table = dataset->getProcessor();
	ProcessorRow *row = 0;

	// processorType is an enumeration
	// ProcessorType * processorType =  (int) processorType;
	// processorSubType is an enumeration
	// ProcessorSubType * processorSubType =  (int) processorSubType;
	
	// Create new row
  
	if (*processorSubType == ProcessorSubTypeMod::ALMA_CORRELATOR_MODE) {
		row = table.newRow(Tag(*modeId, TagType::CorrelatorMode), *processorType, *processorSubType);
	} else if (*processorSubType == ProcessorSubTypeMod::ALMA_RADIOMETER) {
		row = table.newRow(Tag(*modeId, TagType::AlmaRadiometer), *processorType, *processorSubType);
	} else if (*processorSubType == ProcessorSubTypeMod::SQUARE_LAW_DETECTOR)  {
		row = table.newRow(Tag(*modeId, TagType::SquareLawDetector), *processorType, *processorSubType);
	//} else if (*processorSubType == ProcessorSubTypeMod::HOLOGRAPHY)  {
	//	  row = table.newRow(Tag(*modeId, TagType::Holography), *processorType, *processorSubType);
	}

	// Add row
	ProcessorRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the ProcessorTable" << endl;
	}
	
	// return atoi((retRow->getProcessorId().getId()).c_str());
	return retRow->getProcessorId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a ProcessorRow* given a key.
 */
int sdm_getProcessorRow (int * processorId, int * modeId, ProcessorType * processorType, ProcessorSubType * processorSubType) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ProcessorTable &table = dataset->getProcessor();
	ProcessorRow *row = 0;
	row = table.getRowByKey( Tag(*processorId, TagType::Processor));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  processorId  attr.UpperCaseName: ProcessorId
		//  attr.NameS:  modeId  attr.UpperCaseName: ModeId
		// *modeId = atoi((row->getModeId().getId()).c_str());
		*modeId = row->getModeId().getTagValue();
		//  attr.NameS:  processorType  attr.UpperCaseName: ProcessorType
		*processorType = row->getProcessorType();
		//  attr.NameS:  processorSubType  attr.UpperCaseName: ProcessorSubType
		*processorSubType = row->getProcessorSubType();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getProcessorTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
ProcessorTable &table = dataset->getProcessor();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getProcessorKeys(int * processorId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	ProcessorTable &table = dataset->getProcessor();
	
	vector< ProcessorRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// processorId[i] = atoi((row[i]->getProcessorId().getId()).c_str());
				processorId[i] = row[i]->getProcessorId().getTagValue();
  		}
  		
		return size;
  	}
}





using namespace ReceiverBandMod;
using namespace ReceiverSidebandMod;
using namespace NetSidebandMod;


// =================== ReceiverTable ============================

extern "C" int sdm_addReceiverRow (int * spectralWindowId, int64_t * timeInterval, char * name, int * nameDim, int * numLO, ReceiverBand * frequencyBand, double * freqLO, int * freqLODim, ReceiverSideband * receiverSideband, NetSideband * sidebandLO, int * sidebandLODim);
extern "C" int sdm_getReceiverRow (int * receiverId, int * spectralWindowId, int64_t * timeInterval, char * name, int * nameDim, int * numLO, ReceiverBand * frequencyBand, double * freqLO, int * freqLODim, ReceiverSideband * receiverSideband, NetSideband * sidebandLO, int * sidebandLODim);


extern "C" int sdm_getReceiverTableSize ();

extern "C" int sdm_getReceiverKeys (int * receiverId, int * spectralWindowId, int64_t * timeInterval);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addReceiverRow (int * spectralWindowId, int64_t * timeInterval, char * name, int * nameDim, int * numLO, ReceiverBand * frequencyBand, double * freqLO, int * freqLODim, ReceiverSideband * receiverSideband, NetSideband * sidebandLO, int * sidebandLODim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	ReceiverTable &table = dataset->getReceiver();
	ReceiverRow *row = 0;

	// frequencyBand is an enumeration
	// ReceiverBand * frequencyBand =  (int) frequencyBand;
	// freqLO is an Array
	// freqLO is OneD
	vector<Frequency >  freqLOVec(freqLODim[0]);
	for (int i=0;i<freqLODim[0];i++)
		freqLOVec[i]= Frequency(freqLO[i]   );
	// receiverSideband is an enumeration
	// ReceiverSideband * receiverSideband =  (int) receiverSideband;
	// sidebandLO is an Array
	// sidebandLO is OneD
	vector<NetSidebandMod::NetSideband >  sidebandLOVec(sidebandLODim[0]);
	for (int i=0;i<sidebandLODim[0];i++)
		sidebandLOVec[i]= NetSideband(sidebandLO[i]   );
	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), string(name), *numLO, *frequencyBand, freqLOVec, *receiverSideband, sidebandLOVec);
	} else {
		row = table.newRow(Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), string(name), *numLO, *frequencyBand, freqLOVec, *receiverSideband, sidebandLOVec);
	}

	// Add row
	ReceiverRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the ReceiverTable" << endl;
	}
	
	return retRow->getReceiverId();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a ReceiverRow* given a key.
 */
int sdm_getReceiverRow (int * receiverId, int * spectralWindowId, int64_t * timeInterval, char * name, int * nameDim, int * numLO, ReceiverBand * frequencyBand, double * freqLO, int * freqLODim, ReceiverSideband * receiverSideband, NetSideband * sidebandLO, int * sidebandLODim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ReceiverTable &table = dataset->getReceiver();
	ReceiverRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *receiverId, Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( *receiverId, Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  receiverId  attr.UpperCaseName: ReceiverId
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  name  attr.UpperCaseName: Name
		if ((int)row->getName().size()<nameDim[1])
			strcpy(name,row->getName().c_str());
		else
			strncpy(name,row->getName().c_str(),nameDim[1]);
		nameDim[0] = (int)row->getName().size();
		//  attr.NameS:  numLO  attr.UpperCaseName: NumLO
		*numLO = row->getNumLO();
		//  attr.NameS:  frequencyBand  attr.UpperCaseName: FrequencyBand
		*frequencyBand = row->getFrequencyBand();
		//  attr.NameS:  freqLO  attr.UpperCaseName: FreqLO
		
		vector<Frequency >  freqLOVec = row->getFreqLO();
		
		for (int i=0; i<min((int)freqLOVec.size(),freqLODim[1]); i++)
			freqLO[i] = freqLOVec[i].get();
		freqLODim[0] = freqLOVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  receiverSideband  attr.UpperCaseName: ReceiverSideband
		*receiverSideband = row->getReceiverSideband();
		//  attr.NameS:  sidebandLO  attr.UpperCaseName: SidebandLO
		
		vector<NetSidebandMod::NetSideband >  sidebandLOVec = row->getSidebandLO();
		
		for (int i=0; i<min((int)sidebandLOVec.size(),sidebandLODim[1]); i++)
			sidebandLO[i] = sidebandLOVec[i];
		sidebandLODim[0] = (int)sidebandLOVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getReceiverTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
ReceiverTable &table = dataset->getReceiver();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getReceiverKeys(int * receiverId, int * spectralWindowId, int64_t * timeInterval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	ReceiverTable &table = dataset->getReceiver();
	
	vector< ReceiverRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		receiverId[i] = row[i]->getReceiverId();
	  		// spectralWindowId[i] = atoi((row[i]->getSpectralWindowId().getId()).c_str());
				spectralWindowId[i] = row[i]->getSpectralWindowId().getTagValue();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
  		}
  		
		return size;
  	}
}





using namespace ReceiverBandMod;
using namespace SBTypeMod;
using namespace DirectionReferenceCodeMod;


// =================== SBSummaryTable ============================

extern "C" int sdm_addSBSummaryRow (char * sbSummaryUID, int * sbSummaryUIDDim, char * projectUID, int * projectUIDDim, char * obsUnitSetUID, int * obsUnitSetUIDDim, double * frequency, ReceiverBand * frequencyBand, SBType * sbType, int64_t * sbDuration, int * numObservingMode, char * observingMode, int * observingModeDim, int * numberRepeats, int * numScienceGoal, char * scienceGoal, int * scienceGoalDim, int * numWeatherConstraint, char * weatherConstraint, int * weatherConstraintDim);
extern "C" int sdm_getSBSummaryRow (int * sBSummaryId, char * sbSummaryUID, int * sbSummaryUIDDim, char * projectUID, int * projectUIDDim, char * obsUnitSetUID, int * obsUnitSetUIDDim, double * frequency, ReceiverBand * frequencyBand, SBType * sbType, int64_t * sbDuration, int * numObservingMode, char * observingMode, int * observingModeDim, int * numberRepeats, int * numScienceGoal, char * scienceGoal, int * scienceGoalDim, int * numWeatherConstraint, char * weatherConstraint, int * weatherConstraintDim);


extern "C" int sdm_getSBSummaryTableSize ();

extern "C" int sdm_getSBSummaryKeys (int * sBSummaryId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addSBSummaryRow (char * sbSummaryUID, int * sbSummaryUIDDim, char * projectUID, int * projectUIDDim, char * obsUnitSetUID, int * obsUnitSetUIDDim, double * frequency, ReceiverBand * frequencyBand, SBType * sbType, int64_t * sbDuration, int * numObservingMode, char * observingMode, int * observingModeDim, int * numberRepeats, int * numScienceGoal, char * scienceGoal, int * scienceGoalDim, int * numWeatherConstraint, char * weatherConstraint, int * weatherConstraintDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	SBSummaryTable &table = dataset->getSBSummary();
	SBSummaryRow *row = 0;

	// frequencyBand is an enumeration
	// ReceiverBand * frequencyBand =  (int) frequencyBand;
	// sbType is an enumeration
	// SBType * sbType =  (int) sbType;
	// observingMode is an Array
	// observingMode is OneD
	vector<string >  observingModeVec(observingModeDim[2]);
	for (int i=0;i<observingModeDim[2];i++)
		observingModeVec[i]= string(observingMode+i*observingModeDim[1]  );
	// scienceGoal is an Array
	// scienceGoal is OneD
	vector<string >  scienceGoalVec(scienceGoalDim[2]);
	for (int i=0;i<scienceGoalDim[2];i++)
		scienceGoalVec[i]= string(scienceGoal+i*scienceGoalDim[1]  );
	// weatherConstraint is an Array
	// weatherConstraint is OneD
	vector<string >  weatherConstraintVec(weatherConstraintDim[2]);
	for (int i=0;i<weatherConstraintDim[2];i++)
		weatherConstraintVec[i]= string(weatherConstraint+i*weatherConstraintDim[1]  );
	
	// Create new row
  
	row = table.newRow(EntityRef(string(sbSummaryUID)), EntityRef(string(projectUID)), EntityRef(string(obsUnitSetUID)), *frequency, *frequencyBand, *sbType, Interval(*sbDuration), *numObservingMode, observingModeVec, *numberRepeats, *numScienceGoal, scienceGoalVec, *numWeatherConstraint, weatherConstraintVec);

	// Add row
	SBSummaryRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the SBSummaryTable" << endl;
	}
	
	// return atoi((retRow->getSBSummaryId().getId()).c_str());
	return retRow->getSBSummaryId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a SBSummaryRow* given a key.
 */
int sdm_getSBSummaryRow (int * sBSummaryId, char * sbSummaryUID, int * sbSummaryUIDDim, char * projectUID, int * projectUIDDim, char * obsUnitSetUID, int * obsUnitSetUIDDim, double * frequency, ReceiverBand * frequencyBand, SBType * sbType, int64_t * sbDuration, int * numObservingMode, char * observingMode, int * observingModeDim, int * numberRepeats, int * numScienceGoal, char * scienceGoal, int * scienceGoalDim, int * numWeatherConstraint, char * weatherConstraint, int * weatherConstraintDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SBSummaryTable &table = dataset->getSBSummary();
	SBSummaryRow *row = 0;
	row = table.getRowByKey( Tag(*sBSummaryId, TagType::SBSummary));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  sBSummaryId  attr.UpperCaseName: SBSummaryId
		//  attr.NameS:  sbSummaryUID  attr.UpperCaseName: SbSummaryUID
		strcpy(sbSummaryUID,row->getSbSummaryUID().toString().c_str());
		//  attr.NameS:  projectUID  attr.UpperCaseName: ProjectUID
		strcpy(projectUID,row->getProjectUID().toString().c_str());
		//  attr.NameS:  obsUnitSetUID  attr.UpperCaseName: ObsUnitSetUID
		strcpy(obsUnitSetUID,row->getObsUnitSetUID().toString().c_str());
		//  attr.NameS:  frequency  attr.UpperCaseName: Frequency
		*frequency = row->getFrequency();
		//  attr.NameS:  frequencyBand  attr.UpperCaseName: FrequencyBand
		*frequencyBand = row->getFrequencyBand();
		//  attr.NameS:  sbType  attr.UpperCaseName: SbType
		*sbType = row->getSbType();
		//  attr.NameS:  sbDuration  attr.UpperCaseName: SbDuration
		*sbDuration = row->getSbDuration().get();
		//  attr.NameS:  numObservingMode  attr.UpperCaseName: NumObservingMode
		*numObservingMode = row->getNumObservingMode();
		//  attr.NameS:  observingMode  attr.UpperCaseName: ObservingMode
		
		vector<string >  observingModeVec = row->getObservingMode();
		
		int maxDimZeroObservingMode = 0;
		for (int i=0; i<min((int)observingModeVec.size(),observingModeDim[3]); i++) {
			if ((int)observingModeVec[i].size()<observingModeDim[1])
				strcpy(observingMode+i*observingModeDim[1],observingModeVec[i].c_str());
			else
				strncpy(observingMode+i*observingModeDim[1],observingModeVec[i].c_str(),observingModeDim[1]);
			maxDimZeroObservingMode = max((int)observingModeVec[i].size(),maxDimZeroObservingMode);
		}
		observingModeDim[0] = maxDimZeroObservingMode;
		observingModeDim[2] = observingModeVec.size();  // number of strings
		
		
		//  attr.NameS:  numberRepeats  attr.UpperCaseName: NumberRepeats
		*numberRepeats = row->getNumberRepeats();
		//  attr.NameS:  numScienceGoal  attr.UpperCaseName: NumScienceGoal
		*numScienceGoal = row->getNumScienceGoal();
		//  attr.NameS:  scienceGoal  attr.UpperCaseName: ScienceGoal
		
		vector<string >  scienceGoalVec = row->getScienceGoal();
		
		int maxDimZeroScienceGoal = 0;
		for (int i=0; i<min((int)scienceGoalVec.size(),scienceGoalDim[3]); i++) {
			if ((int)scienceGoalVec[i].size()<scienceGoalDim[1])
				strcpy(scienceGoal+i*scienceGoalDim[1],scienceGoalVec[i].c_str());
			else
				strncpy(scienceGoal+i*scienceGoalDim[1],scienceGoalVec[i].c_str(),scienceGoalDim[1]);
			maxDimZeroScienceGoal = max((int)scienceGoalVec[i].size(),maxDimZeroScienceGoal);
		}
		scienceGoalDim[0] = maxDimZeroScienceGoal;
		scienceGoalDim[2] = scienceGoalVec.size();  // number of strings
		
		
		//  attr.NameS:  numWeatherConstraint  attr.UpperCaseName: NumWeatherConstraint
		*numWeatherConstraint = row->getNumWeatherConstraint();
		//  attr.NameS:  weatherConstraint  attr.UpperCaseName: WeatherConstraint
		
		vector<string >  weatherConstraintVec = row->getWeatherConstraint();
		
		int maxDimZeroWeatherConstraint = 0;
		for (int i=0; i<min((int)weatherConstraintVec.size(),weatherConstraintDim[3]); i++) {
			if ((int)weatherConstraintVec[i].size()<weatherConstraintDim[1])
				strcpy(weatherConstraint+i*weatherConstraintDim[1],weatherConstraintVec[i].c_str());
			else
				strncpy(weatherConstraint+i*weatherConstraintDim[1],weatherConstraintVec[i].c_str(),weatherConstraintDim[1]);
			maxDimZeroWeatherConstraint = max((int)weatherConstraintVec[i].size(),maxDimZeroWeatherConstraint);
		}
		weatherConstraintDim[0] = maxDimZeroWeatherConstraint;
		weatherConstraintDim[2] = weatherConstraintVec.size();  // number of strings
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getSBSummaryTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
SBSummaryTable &table = dataset->getSBSummary();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getSBSummaryKeys(int * sBSummaryId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	SBSummaryTable &table = dataset->getSBSummary();
	
	vector< SBSummaryRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// sBSummaryId[i] = atoi((row[i]->getSBSummaryId().getId()).c_str());
				sBSummaryId[i] = row[i]->getSBSummaryId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter centerDirection, in a row of the SBSummary table, given a key
 *
 */

#define sdm_addSBSummaryCenterDirection  sdm_addsbsummarycenterdirection_
extern "C" int sdm_addSBSummaryCenterDirection(int * sBSummaryId, double * centerDirection, int * centerDirectionDim);

int sdm_addSBSummaryCenterDirection(int * sBSummaryId, double * centerDirection, int * centerDirectionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SBSummaryTable &table = dataset->getSBSummary();
	
	SBSummaryRow *row = 0;
	row = table.getRowByKey( Tag(*sBSummaryId, TagType::SBSummary));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Angle >  centerDirectionVec(centerDirectionDim[0]);
		for (int i=0;i<centerDirectionDim[0];i++)
			centerDirectionVec[i]= Angle(centerDirection[i] );
		row->setCenterDirection(centerDirectionVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter centerDirection, in a row of the SBSummary table, given a key
 *
 */

#define sdm_getSBSummaryCenterDirection  sdm_getsbsummarycenterdirection_
extern "C" int sdm_getSBSummaryCenterDirection(int * sBSummaryId, double * centerDirection, int * centerDirectionDim);

int sdm_getSBSummaryCenterDirection(int * sBSummaryId, double * centerDirection, int * centerDirectionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SBSummaryTable &table = dataset->getSBSummary();
	SBSummaryRow *row = 0;
	row = table.getRowByKey( Tag(*sBSummaryId, TagType::SBSummary));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCenterDirectionExists()) {
			// attr.CppType: vector<Angle > attr.isOneD: true
			for (int i=0; i<min((int)row->getCenterDirection().size(),centerDirectionDim[1]); i++)
				centerDirection[i] = row->getCenterDirection()[i].get();
			centerDirectionDim[0] = row->getCenterDirection().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter centerDirectionCode, in a row of the SBSummary table, given a key
 *
 */

#define sdm_addSBSummaryCenterDirectionCode  sdm_addsbsummarycenterdirectioncode_
extern "C" int sdm_addSBSummaryCenterDirectionCode(int * sBSummaryId, DirectionReferenceCode * centerDirectionCode);

int sdm_addSBSummaryCenterDirectionCode(int * sBSummaryId, DirectionReferenceCode * centerDirectionCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SBSummaryTable &table = dataset->getSBSummary();
	
	SBSummaryRow *row = 0;
	row = table.getRowByKey( Tag(*sBSummaryId, TagType::SBSummary));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCenterDirectionCode(DirectionReferenceCode(* centerDirectionCode ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter centerDirectionCode, in a row of the SBSummary table, given a key
 *
 */

#define sdm_getSBSummaryCenterDirectionCode  sdm_getsbsummarycenterdirectioncode_
extern "C" int sdm_getSBSummaryCenterDirectionCode(int * sBSummaryId, DirectionReferenceCode * centerDirectionCode);

int sdm_getSBSummaryCenterDirectionCode(int * sBSummaryId, DirectionReferenceCode * centerDirectionCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SBSummaryTable &table = dataset->getSBSummary();
	SBSummaryRow *row = 0;
	row = table.getRowByKey( Tag(*sBSummaryId, TagType::SBSummary));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCenterDirectionCodeExists()) {
			*centerDirectionCode = row->getCenterDirectionCode();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter centerDirectionEquinox, in a row of the SBSummary table, given a key
 *
 */

#define sdm_addSBSummaryCenterDirectionEquinox  sdm_addsbsummarycenterdirectionequinox_
extern "C" int sdm_addSBSummaryCenterDirectionEquinox(int * sBSummaryId, int64_t * centerDirectionEquinox);

int sdm_addSBSummaryCenterDirectionEquinox(int * sBSummaryId, int64_t * centerDirectionEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SBSummaryTable &table = dataset->getSBSummary();
	
	SBSummaryRow *row = 0;
	row = table.getRowByKey( Tag(*sBSummaryId, TagType::SBSummary));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCenterDirectionEquinox(ArrayTime(* centerDirectionEquinox ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter centerDirectionEquinox, in a row of the SBSummary table, given a key
 *
 */

#define sdm_getSBSummaryCenterDirectionEquinox  sdm_getsbsummarycenterdirectionequinox_
extern "C" int sdm_getSBSummaryCenterDirectionEquinox(int * sBSummaryId, int64_t * centerDirectionEquinox);

int sdm_getSBSummaryCenterDirectionEquinox(int * sBSummaryId, int64_t * centerDirectionEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SBSummaryTable &table = dataset->getSBSummary();
	SBSummaryRow *row = 0;
	row = table.getRowByKey( Tag(*sBSummaryId, TagType::SBSummary));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCenterDirectionEquinoxExists()) {
			*centerDirectionEquinox     = row->getCenterDirectionEquinox().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace TimeScaleMod;
using namespace DataScaleMod;
using namespace DataScaleMod;
using namespace WeightTypeMod;


// =================== ScaleTable ============================

extern "C" int sdm_addScaleRow (TimeScale * timeScale, DataScale * crossDataScale, DataScale * autoDataScale, WeightType * weightType);
extern "C" int sdm_getScaleRow (int * scaleId, TimeScale * timeScale, DataScale * crossDataScale, DataScale * autoDataScale, WeightType * weightType);


extern "C" int sdm_getScaleTableSize ();

extern "C" int sdm_getScaleKeys (int * scaleId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addScaleRow (TimeScale * timeScale, DataScale * crossDataScale, DataScale * autoDataScale, WeightType * weightType){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	ScaleTable &table = dataset->getScale();
	ScaleRow *row = 0;

	// timeScale is an enumeration
	// TimeScale * timeScale =  (int) timeScale;
	// crossDataScale is an enumeration
	// DataScale * crossDataScale =  (int) crossDataScale;
	// autoDataScale is an enumeration
	// DataScale * autoDataScale =  (int) autoDataScale;
	// weightType is an enumeration
	// WeightType * weightType =  (int) weightType;
	
	// Create new row
  
	row = table.newRow(*timeScale, *crossDataScale, *autoDataScale, *weightType);

	// Add row
	ScaleRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the ScaleTable" << endl;
	}
	
	// return atoi((retRow->getScaleId().getId()).c_str());
	return retRow->getScaleId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a ScaleRow* given a key.
 */
int sdm_getScaleRow (int * scaleId, TimeScale * timeScale, DataScale * crossDataScale, DataScale * autoDataScale, WeightType * weightType) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ScaleTable &table = dataset->getScale();
	ScaleRow *row = 0;
	row = table.getRowByKey( Tag(*scaleId, TagType::Scale));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  scaleId  attr.UpperCaseName: ScaleId
		//  attr.NameS:  timeScale  attr.UpperCaseName: TimeScale
		*timeScale = row->getTimeScale();
		//  attr.NameS:  crossDataScale  attr.UpperCaseName: CrossDataScale
		*crossDataScale = row->getCrossDataScale();
		//  attr.NameS:  autoDataScale  attr.UpperCaseName: AutoDataScale
		*autoDataScale = row->getAutoDataScale();
		//  attr.NameS:  weightType  attr.UpperCaseName: WeightType
		*weightType = row->getWeightType();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getScaleTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
ScaleTable &table = dataset->getScale();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getScaleKeys(int * scaleId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	ScaleTable &table = dataset->getScale();
	
	vector< ScaleRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// scaleId[i] = atoi((row[i]->getScaleId().getId()).c_str());
				scaleId[i] = row[i]->getScaleId().getTagValue();
  		}
  		
		return size;
  	}
}





using namespace ScanIntentMod;
using namespace CalDataOriginMod;
using namespace CalibrationFunctionMod;
using namespace CalibrationSetMod;
using namespace AntennaMotionPatternMod;


// =================== ScanTable ============================

extern "C" int sdm_addScanRow (int * execBlockId, int * scanNumber, int64_t * startTime, int64_t * endTime, int * numIntent, int * numSubscan, ScanIntent * scanIntent, int * scanIntentDim, CalDataOrigin * calDataType, int * calDataTypeDim, bool * calibrationOnLine, int * calibrationOnLineDim);
extern "C" int sdm_getScanRow (int * execBlockId, int * scanNumber, int64_t * startTime, int64_t * endTime, int * numIntent, int * numSubscan, ScanIntent * scanIntent, int * scanIntentDim, CalDataOrigin * calDataType, int * calDataTypeDim, bool * calibrationOnLine, int * calibrationOnLineDim);


extern "C" int sdm_getScanTableSize ();

extern "C" int sdm_getScanKeys (int * execBlockId, int * scanNumber);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addScanRow (int * execBlockId, int * scanNumber, int64_t * startTime, int64_t * endTime, int * numIntent, int * numSubscan, ScanIntent * scanIntent, int * scanIntentDim, CalDataOrigin * calDataType, int * calDataTypeDim, bool * calibrationOnLine, int * calibrationOnLineDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	ScanTable &table = dataset->getScan();
	ScanRow *row = 0;

	// scanIntent is an Array
	// scanIntent is OneD
	vector<ScanIntentMod::ScanIntent >  scanIntentVec(scanIntentDim[0]);
	for (int i=0;i<scanIntentDim[0];i++)
		scanIntentVec[i]= ScanIntent(scanIntent[i]   );
	// calDataType is an Array
	// calDataType is OneD
	vector<CalDataOriginMod::CalDataOrigin >  calDataTypeVec(calDataTypeDim[0]);
	for (int i=0;i<calDataTypeDim[0];i++)
		calDataTypeVec[i]= CalDataOrigin(calDataType[i]   );
	// calibrationOnLine is an Array
	// calibrationOnLine is OneD
	vector<bool >  calibrationOnLineVec(calibrationOnLineDim[0]);
	for (int i=0;i<calibrationOnLineDim[0];i++)
		calibrationOnLineVec[i]= bool(calibrationOnLine[i]   );
	
	// Create new row
  
	row = table.newRow(Tag(*execBlockId,TagType::ExecBlock), *scanNumber, ArrayTime(*startTime), ArrayTime(*endTime), *numIntent, *numSubscan, scanIntentVec, calDataTypeVec, calibrationOnLineVec);

	// Add row
	ScanRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the ScanTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a ScanRow* given a key.
 */
int sdm_getScanRow (int * execBlockId, int * scanNumber, int64_t * startTime, int64_t * endTime, int * numIntent, int * numSubscan, ScanIntent * scanIntent, int * scanIntentDim, CalDataOrigin * calDataType, int * calDataTypeDim, bool * calibrationOnLine, int * calibrationOnLineDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ScanTable &table = dataset->getScan();
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  execBlockId  attr.UpperCaseName: ExecBlockId
		//  attr.NameS:  scanNumber  attr.UpperCaseName: ScanNumber
		//  attr.NameS:  startTime  attr.UpperCaseName: StartTime
		*startTime     = row->getStartTime().get();
		//  attr.NameS:  endTime  attr.UpperCaseName: EndTime
		*endTime     = row->getEndTime().get();
		//  attr.NameS:  numIntent  attr.UpperCaseName: NumIntent
		*numIntent = row->getNumIntent();
		//  attr.NameS:  numSubscan  attr.UpperCaseName: NumSubscan
		*numSubscan = row->getNumSubscan();
		//  attr.NameS:  scanIntent  attr.UpperCaseName: ScanIntent
		
		vector<ScanIntentMod::ScanIntent >  scanIntentVec = row->getScanIntent();
		
		for (int i=0; i<min((int)scanIntentVec.size(),scanIntentDim[1]); i++)
			scanIntent[i] = scanIntentVec[i];
		scanIntentDim[0] = (int)scanIntentVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  calDataType  attr.UpperCaseName: CalDataType
		
		vector<CalDataOriginMod::CalDataOrigin >  calDataTypeVec = row->getCalDataType();
		
		for (int i=0; i<min((int)calDataTypeVec.size(),calDataTypeDim[1]); i++)
			calDataType[i] = calDataTypeVec[i];
		calDataTypeDim[0] = (int)calDataTypeVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  calibrationOnLine  attr.UpperCaseName: CalibrationOnLine
		
		vector<bool >  calibrationOnLineVec = row->getCalibrationOnLine();
		
		for (int i=0; i<min((int)calibrationOnLineVec.size(),calibrationOnLineDim[1]); i++)
			calibrationOnLine[i] = calibrationOnLineVec[i];
		calibrationOnLineDim[0] = (int)calibrationOnLineVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getScanTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
ScanTable &table = dataset->getScan();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getScanKeys(int * execBlockId, int * scanNumber) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	ScanTable &table = dataset->getScan();
	
	vector< ScanRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// execBlockId[i] = atoi((row[i]->getExecBlockId().getId()).c_str());
				execBlockId[i] = row[i]->getExecBlockId().getTagValue();
	  		scanNumber[i] = row[i]->getScanNumber();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter calibrationFunction, in a row of the Scan table, given a key
 *
 */

#define sdm_addScanCalibrationFunction  sdm_addscancalibrationfunction_
extern "C" int sdm_addScanCalibrationFunction(int * execBlockId, int * scanNumber, CalibrationFunction * calibrationFunction, int * calibrationFunctionDim);

int sdm_addScanCalibrationFunction(int * execBlockId, int * scanNumber, CalibrationFunction * calibrationFunction, int * calibrationFunctionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ScanTable &table = dataset->getScan();
	
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<CalibrationFunctionMod::CalibrationFunction >  calibrationFunctionVec(calibrationFunctionDim[0]);
		for (int i=0;i<calibrationFunctionDim[0];i++)
			calibrationFunctionVec[i]= CalibrationFunction(calibrationFunction[i] );
		row->setCalibrationFunction(calibrationFunctionVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter calibrationFunction, in a row of the Scan table, given a key
 *
 */

#define sdm_getScanCalibrationFunction  sdm_getscancalibrationfunction_
extern "C" int sdm_getScanCalibrationFunction(int * execBlockId, int * scanNumber, CalibrationFunction * calibrationFunction, int * calibrationFunctionDim);

int sdm_getScanCalibrationFunction(int * execBlockId, int * scanNumber, CalibrationFunction * calibrationFunction, int * calibrationFunctionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ScanTable &table = dataset->getScan();
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCalibrationFunctionExists()) {
			// attr.CppType: vector<CalibrationFunctionMod::CalibrationFunction > attr.isOneD: true
			for (int i=0; i<min((int)row->getCalibrationFunction().size(),calibrationFunctionDim[1]); i++)
				calibrationFunction[i] = row->getCalibrationFunction()[i];
			calibrationFunctionDim[0] = (int)row->getCalibrationFunction().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter calibrationSet, in a row of the Scan table, given a key
 *
 */

#define sdm_addScanCalibrationSet  sdm_addscancalibrationset_
extern "C" int sdm_addScanCalibrationSet(int * execBlockId, int * scanNumber, CalibrationSet * calibrationSet, int * calibrationSetDim);

int sdm_addScanCalibrationSet(int * execBlockId, int * scanNumber, CalibrationSet * calibrationSet, int * calibrationSetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ScanTable &table = dataset->getScan();
	
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<CalibrationSetMod::CalibrationSet >  calibrationSetVec(calibrationSetDim[0]);
		for (int i=0;i<calibrationSetDim[0];i++)
			calibrationSetVec[i]= CalibrationSet(calibrationSet[i] );
		row->setCalibrationSet(calibrationSetVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter calibrationSet, in a row of the Scan table, given a key
 *
 */

#define sdm_getScanCalibrationSet  sdm_getscancalibrationset_
extern "C" int sdm_getScanCalibrationSet(int * execBlockId, int * scanNumber, CalibrationSet * calibrationSet, int * calibrationSetDim);

int sdm_getScanCalibrationSet(int * execBlockId, int * scanNumber, CalibrationSet * calibrationSet, int * calibrationSetDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ScanTable &table = dataset->getScan();
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCalibrationSetExists()) {
			// attr.CppType: vector<CalibrationSetMod::CalibrationSet > attr.isOneD: true
			for (int i=0; i<min((int)row->getCalibrationSet().size(),calibrationSetDim[1]); i++)
				calibrationSet[i] = row->getCalibrationSet()[i];
			calibrationSetDim[0] = (int)row->getCalibrationSet().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter calPattern, in a row of the Scan table, given a key
 *
 */

#define sdm_addScanCalPattern  sdm_addscancalpattern_
extern "C" int sdm_addScanCalPattern(int * execBlockId, int * scanNumber, AntennaMotionPattern * calPattern, int * calPatternDim);

int sdm_addScanCalPattern(int * execBlockId, int * scanNumber, AntennaMotionPattern * calPattern, int * calPatternDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ScanTable &table = dataset->getScan();
	
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<AntennaMotionPatternMod::AntennaMotionPattern >  calPatternVec(calPatternDim[0]);
		for (int i=0;i<calPatternDim[0];i++)
			calPatternVec[i]= AntennaMotionPattern(calPattern[i] );
		row->setCalPattern(calPatternVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter calPattern, in a row of the Scan table, given a key
 *
 */

#define sdm_getScanCalPattern  sdm_getscancalpattern_
extern "C" int sdm_getScanCalPattern(int * execBlockId, int * scanNumber, AntennaMotionPattern * calPattern, int * calPatternDim);

int sdm_getScanCalPattern(int * execBlockId, int * scanNumber, AntennaMotionPattern * calPattern, int * calPatternDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ScanTable &table = dataset->getScan();
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCalPatternExists()) {
			// attr.CppType: vector<AntennaMotionPatternMod::AntennaMotionPattern > attr.isOneD: true
			for (int i=0; i<min((int)row->getCalPattern().size(),calPatternDim[1]); i++)
				calPattern[i] = row->getCalPattern()[i];
			calPatternDim[0] = (int)row->getCalPattern().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numField, in a row of the Scan table, given a key
 *
 */

#define sdm_addScanNumField  sdm_addscannumfield_
extern "C" int sdm_addScanNumField(int * execBlockId, int * scanNumber, int * numField);

int sdm_addScanNumField(int * execBlockId, int * scanNumber, int * numField) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ScanTable &table = dataset->getScan();
	
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumField(int(* numField ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numField, in a row of the Scan table, given a key
 *
 */

#define sdm_getScanNumField  sdm_getscannumfield_
extern "C" int sdm_getScanNumField(int * execBlockId, int * scanNumber, int * numField);

int sdm_getScanNumField(int * execBlockId, int * scanNumber, int * numField) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ScanTable &table = dataset->getScan();
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumFieldExists()) {
			*numField = row->getNumField();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter fieldName, in a row of the Scan table, given a key
 *
 */

#define sdm_addScanFieldName  sdm_addscanfieldname_
extern "C" int sdm_addScanFieldName(int * execBlockId, int * scanNumber, char * fieldName, int * fieldNameDim);

int sdm_addScanFieldName(int * execBlockId, int * scanNumber, char * fieldName, int * fieldNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ScanTable &table = dataset->getScan();
	
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<string >  fieldNameVec(fieldNameDim[2]);
		for (int i=0;i<fieldNameDim[2];i++)
			fieldNameVec[i]= string(fieldName+i*fieldNameDim[1]  
		row->setFieldName(fieldNameVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter fieldName, in a row of the Scan table, given a key
 *
 */

#define sdm_getScanFieldName  sdm_getscanfieldname_
extern "C" int sdm_getScanFieldName(int * execBlockId, int * scanNumber, char * fieldName, int * fieldNameDim);

int sdm_getScanFieldName(int * execBlockId, int * scanNumber, char * fieldName, int * fieldNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ScanTable &table = dataset->getScan();
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFieldNameExists()) {
			// attr.CppType: vector<string > attr.isOneD: true
			int maxDimZeroFieldName = 0;
			for (int i=0; i<min((int)row->getFieldName().size(),fieldNameDim[3]); i++) {
				if ((int)row->getFieldName()[i].size()<fieldNameDim[1])
					strcpy(fieldName+i*fieldNameDim[1],row->getFieldName()[i].c_str());
				else
					strncpy(fieldName+i*fieldNameDim[1],row->getFieldName()[i].c_str(),fieldNameDim[1]);
				maxDimZeroFieldName = max((int)row->getFieldName()[i].size(),maxDimZeroFieldName);
			}
			fieldNameDim[0] = maxDimZeroFieldName;
			fieldNameDim[2] = row->getFieldName().size();  // number of strings
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sourceName, in a row of the Scan table, given a key
 *
 */

#define sdm_addScanSourceName  sdm_addscansourcename_
extern "C" int sdm_addScanSourceName(int * execBlockId, int * scanNumber, char * sourceName, int * sourceNameDim);

int sdm_addScanSourceName(int * execBlockId, int * scanNumber, char * sourceName, int * sourceNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	ScanTable &table = dataset->getScan();
	
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSourceName(string(sourceName));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sourceName, in a row of the Scan table, given a key
 *
 */

#define sdm_getScanSourceName  sdm_getscansourcename_
extern "C" int sdm_getScanSourceName(int * execBlockId, int * scanNumber, char * sourceName, int * sourceNameDim);

int sdm_getScanSourceName(int * execBlockId, int * scanNumber, char * sourceName, int * sourceNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	ScanTable &table = dataset->getScan();
	ScanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSourceNameExists()) {
			if ((int)row->getSourceName().size()<sourceNameDim[1])
				strcpy(sourceName,row->getSourceName().c_str());
			else
				strncpy(sourceName,row->getSourceName().c_str(),sourceNameDim[1]);
			sourceNameDim[0] = (int)row->getSourceName().size();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}




// =================== SeeingTable ============================

extern "C" int sdm_addSeeingRow (int64_t * timeInterval, int * numBaseLength, double * baseLength, int * baseLengthDim, double * phaseRms, int * phaseRmsDim, float * seeing, float * exponent);
extern "C" int sdm_getSeeingRow (int64_t * timeInterval, int * numBaseLength, double * baseLength, int * baseLengthDim, double * phaseRms, int * phaseRmsDim, float * seeing, float * exponent);


extern "C" int sdm_getSeeingTableSize ();

extern "C" int sdm_getSeeingKeys (int64_t * timeInterval);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addSeeingRow (int64_t * timeInterval, int * numBaseLength, double * baseLength, int * baseLengthDim, double * phaseRms, int * phaseRmsDim, float * seeing, float * exponent){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	SeeingTable &table = dataset->getSeeing();
	SeeingRow *row = 0;

	// baseLength is an Array
	// baseLength is OneD
	vector<Length >  baseLengthVec(baseLengthDim[0]);
	for (int i=0;i<baseLengthDim[0];i++)
		baseLengthVec[i]= Length(baseLength[i]   );
	// phaseRms is an Array
	// phaseRms is OneD
	vector<Angle >  phaseRmsVec(phaseRmsDim[0]);
	for (int i=0;i<phaseRmsDim[0];i++)
		phaseRmsVec[i]= Angle(phaseRms[i]   );
	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *numBaseLength, baseLengthVec, phaseRmsVec, *seeing, *exponent);
	} else {
		row = table.newRow(ArrayTimeInterval(*timeInterval), *numBaseLength, baseLengthVec, phaseRmsVec, *seeing, *exponent);
	}

	// Add row
	SeeingRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the SeeingTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a SeeingRow* given a key.
 */
int sdm_getSeeingRow (int64_t * timeInterval, int * numBaseLength, double * baseLength, int * baseLengthDim, double * phaseRms, int * phaseRmsDim, float * seeing, float * exponent) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SeeingTable &table = dataset->getSeeing();
	SeeingRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  numBaseLength  attr.UpperCaseName: NumBaseLength
		*numBaseLength = row->getNumBaseLength();
		//  attr.NameS:  baseLength  attr.UpperCaseName: BaseLength
		
		vector<Length >  baseLengthVec = row->getBaseLength();
		
		for (int i=0; i<min((int)baseLengthVec.size(),baseLengthDim[1]); i++)
			baseLength[i] = baseLengthVec[i].get();
		baseLengthDim[0] = baseLengthVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  phaseRms  attr.UpperCaseName: PhaseRms
		
		vector<Angle >  phaseRmsVec = row->getPhaseRms();
		
		for (int i=0; i<min((int)phaseRmsVec.size(),phaseRmsDim[1]); i++)
			phaseRms[i] = phaseRmsVec[i].get();
		phaseRmsDim[0] = phaseRmsVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  seeing  attr.UpperCaseName: Seeing
		*seeing = row->getSeeing();
		//  attr.NameS:  exponent  attr.UpperCaseName: Exponent
		*exponent = row->getExponent();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getSeeingTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
SeeingTable &table = dataset->getSeeing();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getSeeingKeys(int64_t * timeInterval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	SeeingTable &table = dataset->getSeeing();
	
	vector< SeeingRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
  		}
  		
		return size;
  	}
}





using namespace DirectionReferenceCodeMod;
using namespace SourceModelMod;
using namespace FrequencyReferenceCodeMod;
using namespace StokesParameterMod;
using namespace RadialVelocityReferenceCodeMod;


// =================== SourceTable ============================

extern "C" int sdm_addSourceRow (int64_t * timeInterval, int * spectralWindowId, char * code, int * codeDim, double * direction, int * directionDim, double * properMotion, int * properMotionDim, char * sourceName, int * sourceNameDim);
extern "C" int sdm_getSourceRow (int * sourceId, int64_t * timeInterval, int * spectralWindowId, char * code, int * codeDim, double * direction, int * directionDim, double * properMotion, int * properMotionDim, char * sourceName, int * sourceNameDim);


extern "C" int sdm_getSourceTableSize ();

extern "C" int sdm_getSourceKeys (int * sourceId, int64_t * timeInterval, int * spectralWindowId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addSourceRow (int64_t * timeInterval, int * spectralWindowId, char * code, int * codeDim, double * direction, int * directionDim, double * properMotion, int * properMotionDim, char * sourceName, int * sourceNameDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;

	// direction is an Array
	// direction is OneD
	vector<Angle >  directionVec(directionDim[0]);
	for (int i=0;i<directionDim[0];i++)
		directionVec[i]= Angle(direction[i]   );
	// properMotion is an Array
	// properMotion is OneD
	vector<AngularRate >  properMotionVec(properMotionDim[0]);
	for (int i=0;i<properMotionDim[0];i++)
		properMotionVec[i]= AngularRate(properMotion[i]   );
	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId,TagType::SpectralWindow), string(code), directionVec, properMotionVec, string(sourceName));
	} else {
		row = table.newRow(ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId,TagType::SpectralWindow), string(code), directionVec, properMotionVec, string(sourceName));
	}

	// Add row
	SourceRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the SourceTable" << endl;
	}
	
	return retRow->getSourceId();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a SourceRow* given a key.
 */
int sdm_getSourceRow (int * sourceId, int64_t * timeInterval, int * spectralWindowId, char * code, int * codeDim, double * direction, int * directionDim, double * properMotion, int * properMotionDim, char * sourceName, int * sourceNameDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  sourceId  attr.UpperCaseName: SourceId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		//  attr.NameS:  code  attr.UpperCaseName: Code
		if ((int)row->getCode().size()<codeDim[1])
			strcpy(code,row->getCode().c_str());
		else
			strncpy(code,row->getCode().c_str(),codeDim[1]);
		codeDim[0] = (int)row->getCode().size();
		//  attr.NameS:  direction  attr.UpperCaseName: Direction
		
		vector<Angle >  directionVec = row->getDirection();
		
		for (int i=0; i<min((int)directionVec.size(),directionDim[1]); i++)
			direction[i] = directionVec[i].get();
		directionDim[0] = directionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  properMotion  attr.UpperCaseName: ProperMotion
		
		vector<AngularRate >  properMotionVec = row->getProperMotion();
		
		for (int i=0; i<min((int)properMotionVec.size(),properMotionDim[1]); i++)
			properMotion[i] = properMotionVec[i].get();
		properMotionDim[0] = properMotionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  sourceName  attr.UpperCaseName: SourceName
		if ((int)row->getSourceName().size()<sourceNameDim[1])
			strcpy(sourceName,row->getSourceName().c_str());
		else
			strncpy(sourceName,row->getSourceName().c_str(),sourceNameDim[1]);
		sourceNameDim[0] = (int)row->getSourceName().size();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getSourceTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
SourceTable &table = dataset->getSource();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getSourceKeys(int * sourceId, int64_t * timeInterval, int * spectralWindowId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	SourceTable &table = dataset->getSource();
	
	vector< SourceRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		sourceId[i] = row[i]->getSourceId();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
	  		// spectralWindowId[i] = atoi((row[i]->getSpectralWindowId().getId()).c_str());
				spectralWindowId[i] = row[i]->getSpectralWindowId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter directionCode, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceDirectionCode  sdm_addsourcedirectioncode_
extern "C" int sdm_addSourceDirectionCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, DirectionReferenceCode * directionCode);

int sdm_addSourceDirectionCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, DirectionReferenceCode * directionCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDirectionCode(DirectionReferenceCode(* directionCode ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter directionCode, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceDirectionCode  sdm_getsourcedirectioncode_
extern "C" int sdm_getSourceDirectionCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, DirectionReferenceCode * directionCode);

int sdm_getSourceDirectionCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, DirectionReferenceCode * directionCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDirectionCodeExists()) {
			*directionCode = row->getDirectionCode();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter directionEquinox, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceDirectionEquinox  sdm_addsourcedirectionequinox_
extern "C" int sdm_addSourceDirectionEquinox(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int64_t * directionEquinox);

int sdm_addSourceDirectionEquinox(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int64_t * directionEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDirectionEquinox(ArrayTime(* directionEquinox ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter directionEquinox, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceDirectionEquinox  sdm_getsourcedirectionequinox_
extern "C" int sdm_getSourceDirectionEquinox(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int64_t * directionEquinox);

int sdm_getSourceDirectionEquinox(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int64_t * directionEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDirectionEquinoxExists()) {
			*directionEquinox     = row->getDirectionEquinox().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter calibrationGroup, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceCalibrationGroup  sdm_addsourcecalibrationgroup_
extern "C" int sdm_addSourceCalibrationGroup(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * calibrationGroup);

int sdm_addSourceCalibrationGroup(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * calibrationGroup) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCalibrationGroup(int(* calibrationGroup ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter calibrationGroup, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceCalibrationGroup  sdm_getsourcecalibrationgroup_
extern "C" int sdm_getSourceCalibrationGroup(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * calibrationGroup);

int sdm_getSourceCalibrationGroup(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * calibrationGroup) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCalibrationGroupExists()) {
			*calibrationGroup = row->getCalibrationGroup();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter catalog, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceCatalog  sdm_addsourcecatalog_
extern "C" int sdm_addSourceCatalog(int * sourceId, int64_t * timeInterval, int * spectralWindowId, char * catalog, int * catalogDim);

int sdm_addSourceCatalog(int * sourceId, int64_t * timeInterval, int * spectralWindowId, char * catalog, int * catalogDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCatalog(string(catalog));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter catalog, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceCatalog  sdm_getsourcecatalog_
extern "C" int sdm_getSourceCatalog(int * sourceId, int64_t * timeInterval, int * spectralWindowId, char * catalog, int * catalogDim);

int sdm_getSourceCatalog(int * sourceId, int64_t * timeInterval, int * spectralWindowId, char * catalog, int * catalogDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCatalogExists()) {
			if ((int)row->getCatalog().size()<catalogDim[1])
				strcpy(catalog,row->getCatalog().c_str());
			else
				strncpy(catalog,row->getCatalog().c_str(),catalogDim[1]);
			catalogDim[0] = (int)row->getCatalog().size();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter deltaVel, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceDeltaVel  sdm_addsourcedeltavel_
extern "C" int sdm_addSourceDeltaVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * deltaVel);

int sdm_addSourceDeltaVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * deltaVel) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDeltaVel(Speed(* deltaVel ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter deltaVel, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceDeltaVel  sdm_getsourcedeltavel_
extern "C" int sdm_getSourceDeltaVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * deltaVel);

int sdm_getSourceDeltaVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * deltaVel) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDeltaVelExists()) {
			*deltaVel = row->getDeltaVel().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter position, in a row of the Source table, given a key
 *
 */

#define sdm_addSourcePosition  sdm_addsourceposition_
extern "C" int sdm_addSourcePosition(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * position, int * positionDim);

int sdm_addSourcePosition(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * position, int * positionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  positionVec(positionDim[0]);
		for (int i=0;i<positionDim[0];i++)
			positionVec[i]= Length(position[i] );
		row->setPosition(positionVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter position, in a row of the Source table, given a key
 *
 */

#define sdm_getSourcePosition  sdm_getsourceposition_
extern "C" int sdm_getSourcePosition(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * position, int * positionDim);

int sdm_getSourcePosition(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * position, int * positionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPositionExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getPosition().size(),positionDim[1]); i++)
				position[i] = row->getPosition()[i].get();
			positionDim[0] = row->getPosition().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numLines, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceNumLines  sdm_addsourcenumlines_
extern "C" int sdm_addSourceNumLines(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numLines);

int sdm_addSourceNumLines(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numLines) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumLines(int(* numLines ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numLines, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceNumLines  sdm_getsourcenumlines_
extern "C" int sdm_getSourceNumLines(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numLines);

int sdm_getSourceNumLines(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numLines) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumLinesExists()) {
			*numLines = row->getNumLines();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter transition, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceTransition  sdm_addsourcetransition_
extern "C" int sdm_addSourceTransition(int * sourceId, int64_t * timeInterval, int * spectralWindowId, char * transition, int * transitionDim);

int sdm_addSourceTransition(int * sourceId, int64_t * timeInterval, int * spectralWindowId, char * transition, int * transitionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<string >  transitionVec(transitionDim[2]);
		for (int i=0;i<transitionDim[2];i++)
			transitionVec[i]= string(transition+i*transitionDim[1]  
		row->setTransition(transitionVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter transition, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceTransition  sdm_getsourcetransition_
extern "C" int sdm_getSourceTransition(int * sourceId, int64_t * timeInterval, int * spectralWindowId, char * transition, int * transitionDim);

int sdm_getSourceTransition(int * sourceId, int64_t * timeInterval, int * spectralWindowId, char * transition, int * transitionDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTransitionExists()) {
			// attr.CppType: vector<string > attr.isOneD: true
			int maxDimZeroTransition = 0;
			for (int i=0; i<min((int)row->getTransition().size(),transitionDim[3]); i++) {
				if ((int)row->getTransition()[i].size()<transitionDim[1])
					strcpy(transition+i*transitionDim[1],row->getTransition()[i].c_str());
				else
					strncpy(transition+i*transitionDim[1],row->getTransition()[i].c_str(),transitionDim[1]);
				maxDimZeroTransition = max((int)row->getTransition()[i].size(),maxDimZeroTransition);
			}
			transitionDim[0] = maxDimZeroTransition;
			transitionDim[2] = row->getTransition().size();  // number of strings
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter restFrequency, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceRestFrequency  sdm_addsourcerestfrequency_
extern "C" int sdm_addSourceRestFrequency(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * restFrequency, int * restFrequencyDim);

int sdm_addSourceRestFrequency(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * restFrequency, int * restFrequencyDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Frequency >  restFrequencyVec(restFrequencyDim[0]);
		for (int i=0;i<restFrequencyDim[0];i++)
			restFrequencyVec[i]= Frequency(restFrequency[i] );
		row->setRestFrequency(restFrequencyVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter restFrequency, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceRestFrequency  sdm_getsourcerestfrequency_
extern "C" int sdm_getSourceRestFrequency(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * restFrequency, int * restFrequencyDim);

int sdm_getSourceRestFrequency(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * restFrequency, int * restFrequencyDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isRestFrequencyExists()) {
			// attr.CppType: vector<Frequency > attr.isOneD: true
			for (int i=0; i<min((int)row->getRestFrequency().size(),restFrequencyDim[1]); i++)
				restFrequency[i] = row->getRestFrequency()[i].get();
			restFrequencyDim[0] = row->getRestFrequency().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sysVel, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceSysVel  sdm_addsourcesysvel_
extern "C" int sdm_addSourceSysVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * sysVel, int * sysVelDim);

int sdm_addSourceSysVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * sysVel, int * sysVelDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Speed >  sysVelVec(sysVelDim[0]);
		for (int i=0;i<sysVelDim[0];i++)
			sysVelVec[i]= Speed(sysVel[i] );
		row->setSysVel(sysVelVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sysVel, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceSysVel  sdm_getsourcesysvel_
extern "C" int sdm_getSourceSysVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * sysVel, int * sysVelDim);

int sdm_getSourceSysVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * sysVel, int * sysVelDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSysVelExists()) {
			// attr.CppType: vector<Speed > attr.isOneD: true
			for (int i=0; i<min((int)row->getSysVel().size(),sysVelDim[1]); i++)
				sysVel[i] = row->getSysVel()[i].get();
			sysVelDim[0] = row->getSysVel().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter rangeVel, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceRangeVel  sdm_addsourcerangevel_
extern "C" int sdm_addSourceRangeVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * rangeVel, int * rangeVelDim);

int sdm_addSourceRangeVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * rangeVel, int * rangeVelDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Speed >  rangeVelVec(rangeVelDim[0]);
		for (int i=0;i<rangeVelDim[0];i++)
			rangeVelVec[i]= Speed(rangeVel[i] );
		row->setRangeVel(rangeVelVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter rangeVel, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceRangeVel  sdm_getsourcerangevel_
extern "C" int sdm_getSourceRangeVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * rangeVel, int * rangeVelDim);

int sdm_getSourceRangeVel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * rangeVel, int * rangeVelDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isRangeVelExists()) {
			// attr.CppType: vector<Speed > attr.isOneD: true
			for (int i=0; i<min((int)row->getRangeVel().size(),rangeVelDim[1]); i++)
				rangeVel[i] = row->getRangeVel()[i].get();
			rangeVelDim[0] = row->getRangeVel().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sourceModel, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceSourceModel  sdm_addsourcesourcemodel_
extern "C" int sdm_addSourceSourceModel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, SourceModel * sourceModel);

int sdm_addSourceSourceModel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, SourceModel * sourceModel) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSourceModel(SourceModel(* sourceModel ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sourceModel, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceSourceModel  sdm_getsourcesourcemodel_
extern "C" int sdm_getSourceSourceModel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, SourceModel * sourceModel);

int sdm_getSourceSourceModel(int * sourceId, int64_t * timeInterval, int * spectralWindowId, SourceModel * sourceModel) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSourceModelExists()) {
			*sourceModel = row->getSourceModel();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter frequencyRefCode, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceFrequencyRefCode  sdm_addsourcefrequencyrefcode_
extern "C" int sdm_addSourceFrequencyRefCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, FrequencyReferenceCode * frequencyRefCode);

int sdm_addSourceFrequencyRefCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, FrequencyReferenceCode * frequencyRefCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setFrequencyRefCode(FrequencyReferenceCode(* frequencyRefCode ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter frequencyRefCode, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceFrequencyRefCode  sdm_getsourcefrequencyrefcode_
extern "C" int sdm_getSourceFrequencyRefCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, FrequencyReferenceCode * frequencyRefCode);

int sdm_getSourceFrequencyRefCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, FrequencyReferenceCode * frequencyRefCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFrequencyRefCodeExists()) {
			*frequencyRefCode = row->getFrequencyRefCode();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numFreq, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceNumFreq  sdm_addsourcenumfreq_
extern "C" int sdm_addSourceNumFreq(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numFreq);

int sdm_addSourceNumFreq(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numFreq) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumFreq(int(* numFreq ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numFreq, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceNumFreq  sdm_getsourcenumfreq_
extern "C" int sdm_getSourceNumFreq(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numFreq);

int sdm_getSourceNumFreq(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numFreq) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumFreqExists()) {
			*numFreq = row->getNumFreq();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numStokes, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceNumStokes  sdm_addsourcenumstokes_
extern "C" int sdm_addSourceNumStokes(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numStokes);

int sdm_addSourceNumStokes(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numStokes) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumStokes(int(* numStokes ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numStokes, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceNumStokes  sdm_getsourcenumstokes_
extern "C" int sdm_getSourceNumStokes(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numStokes);

int sdm_getSourceNumStokes(int * sourceId, int64_t * timeInterval, int * spectralWindowId, int * numStokes) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumStokesExists()) {
			*numStokes = row->getNumStokes();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter frequency, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceFrequency  sdm_addsourcefrequency_
extern "C" int sdm_addSourceFrequency(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * frequency, int * frequencyDim);

int sdm_addSourceFrequency(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * frequency, int * frequencyDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Frequency >  frequencyVec(frequencyDim[0]);
		for (int i=0;i<frequencyDim[0];i++)
			frequencyVec[i]= Frequency(frequency[i] );
		row->setFrequency(frequencyVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter frequency, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceFrequency  sdm_getsourcefrequency_
extern "C" int sdm_getSourceFrequency(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * frequency, int * frequencyDim);

int sdm_getSourceFrequency(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * frequency, int * frequencyDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFrequencyExists()) {
			// attr.CppType: vector<Frequency > attr.isOneD: true
			for (int i=0; i<min((int)row->getFrequency().size(),frequencyDim[1]); i++)
				frequency[i] = row->getFrequency()[i].get();
			frequencyDim[0] = row->getFrequency().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter frequencyInterval, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceFrequencyInterval  sdm_addsourcefrequencyinterval_
extern "C" int sdm_addSourceFrequencyInterval(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * frequencyInterval, int * frequencyIntervalDim);

int sdm_addSourceFrequencyInterval(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * frequencyInterval, int * frequencyIntervalDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Frequency >  frequencyIntervalVec(frequencyIntervalDim[0]);
		for (int i=0;i<frequencyIntervalDim[0];i++)
			frequencyIntervalVec[i]= Frequency(frequencyInterval[i] );
		row->setFrequencyInterval(frequencyIntervalVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter frequencyInterval, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceFrequencyInterval  sdm_getsourcefrequencyinterval_
extern "C" int sdm_getSourceFrequencyInterval(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * frequencyInterval, int * frequencyIntervalDim);

int sdm_getSourceFrequencyInterval(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * frequencyInterval, int * frequencyIntervalDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFrequencyIntervalExists()) {
			// attr.CppType: vector<Frequency > attr.isOneD: true
			for (int i=0; i<min((int)row->getFrequencyInterval().size(),frequencyIntervalDim[1]); i++)
				frequencyInterval[i] = row->getFrequencyInterval()[i].get();
			frequencyIntervalDim[0] = row->getFrequencyInterval().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter stokesParameter, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceStokesParameter  sdm_addsourcestokesparameter_
extern "C" int sdm_addSourceStokesParameter(int * sourceId, int64_t * timeInterval, int * spectralWindowId, StokesParameter * stokesParameter, int * stokesParameterDim);

int sdm_addSourceStokesParameter(int * sourceId, int64_t * timeInterval, int * spectralWindowId, StokesParameter * stokesParameter, int * stokesParameterDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<StokesParameterMod::StokesParameter >  stokesParameterVec(stokesParameterDim[0]);
		for (int i=0;i<stokesParameterDim[0];i++)
			stokesParameterVec[i]= StokesParameter(stokesParameter[i] );
		row->setStokesParameter(stokesParameterVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter stokesParameter, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceStokesParameter  sdm_getsourcestokesparameter_
extern "C" int sdm_getSourceStokesParameter(int * sourceId, int64_t * timeInterval, int * spectralWindowId, StokesParameter * stokesParameter, int * stokesParameterDim);

int sdm_getSourceStokesParameter(int * sourceId, int64_t * timeInterval, int * spectralWindowId, StokesParameter * stokesParameter, int * stokesParameterDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isStokesParameterExists()) {
			// attr.CppType: vector<StokesParameterMod::StokesParameter > attr.isOneD: true
			for (int i=0; i<min((int)row->getStokesParameter().size(),stokesParameterDim[1]); i++)
				stokesParameter[i] = row->getStokesParameter()[i];
			stokesParameterDim[0] = (int)row->getStokesParameter().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter flux, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceFlux  sdm_addsourceflux_
extern "C" int sdm_addSourceFlux(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * flux, int * fluxDim);

int sdm_addSourceFlux(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * flux, int * fluxDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par flux:
		vector<vector<Flux > >  fluxVec(fluxDim[2]);
		for (int i=0;i<fluxDim[2];i++) {
			fluxVec[i].resize(fluxDim[0]);
			for (int j=0;j<fluxDim[0];j++)
				fluxVec[i][j]= Flux(flux[i*(fluxDim[1])+j]);
		}
		row->setFlux(fluxVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter flux, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceFlux  sdm_getsourceflux_
extern "C" int sdm_getSourceFlux(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * flux, int * fluxDim);

int sdm_getSourceFlux(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * flux, int * fluxDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFluxExists()) {
			// attr.CppType: vector<vector<Flux > > attr.isOneD: false
			int maxDimZeroFlux = 0;
			for (int i=0; i< min((int)row->getFlux().size(),fluxDim[3]) ;i++) {
				maxDimZeroFlux = max((int)row->getFlux()[i].size(),maxDimZeroFlux);
				for (int j=0; j<min((int)row->getFlux()[i].size(),fluxDim[1]) ;j++) {
					flux[i*fluxDim[1]+j] = row->getFlux()[i][j].get();
				}
			}
			fluxDim[0] = maxDimZeroFlux;
			fluxDim[2] = row->getFlux().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter fluxErr, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceFluxErr  sdm_addsourcefluxerr_
extern "C" int sdm_addSourceFluxErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * fluxErr, int * fluxErrDim);

int sdm_addSourceFluxErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * fluxErr, int * fluxErrDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par fluxErr:
		vector<vector<Flux > >  fluxErrVec(fluxErrDim[2]);
		for (int i=0;i<fluxErrDim[2];i++) {
			fluxErrVec[i].resize(fluxErrDim[0]);
			for (int j=0;j<fluxErrDim[0];j++)
				fluxErrVec[i][j]= Flux(fluxErr[i*(fluxErrDim[1])+j]);
		}
		row->setFluxErr(fluxErrVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter fluxErr, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceFluxErr  sdm_getsourcefluxerr_
extern "C" int sdm_getSourceFluxErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * fluxErr, int * fluxErrDim);

int sdm_getSourceFluxErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * fluxErr, int * fluxErrDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFluxErrExists()) {
			// attr.CppType: vector<vector<Flux > > attr.isOneD: false
			int maxDimZeroFluxErr = 0;
			for (int i=0; i< min((int)row->getFluxErr().size(),fluxErrDim[3]) ;i++) {
				maxDimZeroFluxErr = max((int)row->getFluxErr()[i].size(),maxDimZeroFluxErr);
				for (int j=0; j<min((int)row->getFluxErr()[i].size(),fluxErrDim[1]) ;j++) {
					fluxErr[i*fluxErrDim[1]+j] = row->getFluxErr()[i][j].get();
				}
			}
			fluxErrDim[0] = maxDimZeroFluxErr;
			fluxErrDim[2] = row->getFluxErr().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter positionAngle, in a row of the Source table, given a key
 *
 */

#define sdm_addSourcePositionAngle  sdm_addsourcepositionangle_
extern "C" int sdm_addSourcePositionAngle(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * positionAngle, int * positionAngleDim);

int sdm_addSourcePositionAngle(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * positionAngle, int * positionAngleDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Angle >  positionAngleVec(positionAngleDim[0]);
		for (int i=0;i<positionAngleDim[0];i++)
			positionAngleVec[i]= Angle(positionAngle[i] );
		row->setPositionAngle(positionAngleVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter positionAngle, in a row of the Source table, given a key
 *
 */

#define sdm_getSourcePositionAngle  sdm_getsourcepositionangle_
extern "C" int sdm_getSourcePositionAngle(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * positionAngle, int * positionAngleDim);

int sdm_getSourcePositionAngle(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * positionAngle, int * positionAngleDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPositionAngleExists()) {
			// attr.CppType: vector<Angle > attr.isOneD: true
			for (int i=0; i<min((int)row->getPositionAngle().size(),positionAngleDim[1]); i++)
				positionAngle[i] = row->getPositionAngle()[i].get();
			positionAngleDim[0] = row->getPositionAngle().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter positionAngleErr, in a row of the Source table, given a key
 *
 */

#define sdm_addSourcePositionAngleErr  sdm_addsourcepositionangleerr_
extern "C" int sdm_addSourcePositionAngleErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * positionAngleErr, int * positionAngleErrDim);

int sdm_addSourcePositionAngleErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * positionAngleErr, int * positionAngleErrDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Angle >  positionAngleErrVec(positionAngleErrDim[0]);
		for (int i=0;i<positionAngleErrDim[0];i++)
			positionAngleErrVec[i]= Angle(positionAngleErr[i] );
		row->setPositionAngleErr(positionAngleErrVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter positionAngleErr, in a row of the Source table, given a key
 *
 */

#define sdm_getSourcePositionAngleErr  sdm_getsourcepositionangleerr_
extern "C" int sdm_getSourcePositionAngleErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * positionAngleErr, int * positionAngleErrDim);

int sdm_getSourcePositionAngleErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * positionAngleErr, int * positionAngleErrDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPositionAngleErrExists()) {
			// attr.CppType: vector<Angle > attr.isOneD: true
			for (int i=0; i<min((int)row->getPositionAngleErr().size(),positionAngleErrDim[1]); i++)
				positionAngleErr[i] = row->getPositionAngleErr()[i].get();
			positionAngleErrDim[0] = row->getPositionAngleErr().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter size, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceSize  sdm_addsourcesize_
extern "C" int sdm_addSourceSize(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * size, int * sizeDim);

int sdm_addSourceSize(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * size, int * sizeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par size:
		vector<vector<Angle > >  sizeVec(sizeDim[2]);
		for (int i=0;i<sizeDim[2];i++) {
			sizeVec[i].resize(sizeDim[0]);
			for (int j=0;j<sizeDim[0];j++)
				sizeVec[i][j]= Angle(size[i*(sizeDim[1])+j]);
		}
		row->setSize(sizeVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter size, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceSize  sdm_getsourcesize_
extern "C" int sdm_getSourceSize(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * size, int * sizeDim);

int sdm_getSourceSize(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * size, int * sizeDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSizeExists()) {
			// attr.CppType: vector<vector<Angle > > attr.isOneD: false
			int maxDimZeroSize = 0;
			for (int i=0; i< min((int)row->getSize().size(),sizeDim[3]) ;i++) {
				maxDimZeroSize = max((int)row->getSize()[i].size(),maxDimZeroSize);
				for (int j=0; j<min((int)row->getSize()[i].size(),sizeDim[1]) ;j++) {
					size[i*sizeDim[1]+j] = row->getSize()[i][j].get();
				}
			}
			sizeDim[0] = maxDimZeroSize;
			sizeDim[2] = row->getSize().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter sizeErr, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceSizeErr  sdm_addsourcesizeerr_
extern "C" int sdm_addSourceSizeErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * sizeErr, int * sizeErrDim);

int sdm_addSourceSizeErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * sizeErr, int * sizeErrDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par sizeErr:
		vector<vector<Angle > >  sizeErrVec(sizeErrDim[2]);
		for (int i=0;i<sizeErrDim[2];i++) {
			sizeErrVec[i].resize(sizeErrDim[0]);
			for (int j=0;j<sizeErrDim[0];j++)
				sizeErrVec[i][j]= Angle(sizeErr[i*(sizeErrDim[1])+j]);
		}
		row->setSizeErr(sizeErrVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter sizeErr, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceSizeErr  sdm_getsourcesizeerr_
extern "C" int sdm_getSourceSizeErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * sizeErr, int * sizeErrDim);

int sdm_getSourceSizeErr(int * sourceId, int64_t * timeInterval, int * spectralWindowId, double * sizeErr, int * sizeErrDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSizeErrExists()) {
			// attr.CppType: vector<vector<Angle > > attr.isOneD: false
			int maxDimZeroSizeErr = 0;
			for (int i=0; i< min((int)row->getSizeErr().size(),sizeErrDim[3]) ;i++) {
				maxDimZeroSizeErr = max((int)row->getSizeErr()[i].size(),maxDimZeroSizeErr);
				for (int j=0; j<min((int)row->getSizeErr()[i].size(),sizeErrDim[1]) ;j++) {
					sizeErr[i*sizeErrDim[1]+j] = row->getSizeErr()[i][j].get();
				}
			}
			sizeErrDim[0] = maxDimZeroSizeErr;
			sizeErrDim[2] = row->getSizeErr().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter velRefCode, in a row of the Source table, given a key
 *
 */

#define sdm_addSourceVelRefCode  sdm_addsourcevelrefcode_
extern "C" int sdm_addSourceVelRefCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, RadialVelocityReferenceCode * velRefCode);

int sdm_addSourceVelRefCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, RadialVelocityReferenceCode * velRefCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SourceTable &table = dataset->getSource();
	
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setVelRefCode(RadialVelocityReferenceCode(* velRefCode ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter velRefCode, in a row of the Source table, given a key
 *
 */

#define sdm_getSourceVelRefCode  sdm_getsourcevelrefcode_
extern "C" int sdm_getSourceVelRefCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, RadialVelocityReferenceCode * velRefCode);

int sdm_getSourceVelRefCode(int * sourceId, int64_t * timeInterval, int * spectralWindowId, RadialVelocityReferenceCode * velRefCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SourceTable &table = dataset->getSource();
	SourceRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), Tag(*spectralWindowId, TagType::SpectralWindow));
	else
		row = table.getRowByKey( *sourceId, ArrayTimeInterval(*timeInterval), Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isVelRefCodeExists()) {
			*velRefCode = row->getVelRefCode();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace BasebandNameMod;
using namespace NetSidebandMod;
using namespace SidebandProcessingModeMod;
using namespace WindowFunctionMod;
using namespace CorrelationBitMod;
using namespace FrequencyReferenceCodeMod;
using namespace SpectralResolutionTypeMod;


// =================== SpectralWindowTable ============================

extern "C" int sdm_addSpectralWindowRow (BasebandName * basebandName, NetSideband * netSideband, int * numChan, double * refFreq, SidebandProcessingMode * sidebandProcessingMode, double * totBandwidth, WindowFunction * windowFunction);
extern "C" int sdm_getSpectralWindowRow (int * spectralWindowId, BasebandName * basebandName, NetSideband * netSideband, int * numChan, double * refFreq, SidebandProcessingMode * sidebandProcessingMode, double * totBandwidth, WindowFunction * windowFunction);


extern "C" int sdm_getSpectralWindowTableSize ();

extern "C" int sdm_getSpectralWindowKeys (int * spectralWindowId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addSpectralWindowRow (BasebandName * basebandName, NetSideband * netSideband, int * numChan, double * refFreq, SidebandProcessingMode * sidebandProcessingMode, double * totBandwidth, WindowFunction * windowFunction){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;

	// basebandName is an enumeration
	// BasebandName * basebandName =  (int) basebandName;
	// netSideband is an enumeration
	// NetSideband * netSideband =  (int) netSideband;
	// sidebandProcessingMode is an enumeration
	// SidebandProcessingMode * sidebandProcessingMode =  (int) sidebandProcessingMode;
	// windowFunction is an enumeration
	// WindowFunction * windowFunction =  (int) windowFunction;
	
	// Create new row
  
	row = table.newRow(*basebandName, *netSideband, *numChan, Frequency(*refFreq), *sidebandProcessingMode, Frequency(*totBandwidth), *windowFunction);

	// Add row
	SpectralWindowRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the SpectralWindowTable" << endl;
	}
	
	// return atoi((retRow->getSpectralWindowId().getId()).c_str());
	return retRow->getSpectralWindowId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a SpectralWindowRow* given a key.
 */
int sdm_getSpectralWindowRow (int * spectralWindowId, BasebandName * basebandName, NetSideband * netSideband, int * numChan, double * refFreq, SidebandProcessingMode * sidebandProcessingMode, double * totBandwidth, WindowFunction * windowFunction) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		//  attr.NameS:  basebandName  attr.UpperCaseName: BasebandName
		*basebandName = row->getBasebandName();
		//  attr.NameS:  netSideband  attr.UpperCaseName: NetSideband
		*netSideband = row->getNetSideband();
		//  attr.NameS:  numChan  attr.UpperCaseName: NumChan
		*numChan = row->getNumChan();
		//  attr.NameS:  refFreq  attr.UpperCaseName: RefFreq
		*refFreq = row->getRefFreq().get();
		//  attr.NameS:  sidebandProcessingMode  attr.UpperCaseName: SidebandProcessingMode
		*sidebandProcessingMode = row->getSidebandProcessingMode();
		//  attr.NameS:  totBandwidth  attr.UpperCaseName: TotBandwidth
		*totBandwidth = row->getTotBandwidth().get();
		//  attr.NameS:  windowFunction  attr.UpperCaseName: WindowFunction
		*windowFunction = row->getWindowFunction();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getSpectralWindowTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
SpectralWindowTable &table = dataset->getSpectralWindow();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getSpectralWindowKeys(int * spectralWindowId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	vector< SpectralWindowRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// spectralWindowId[i] = atoi((row[i]->getSpectralWindowId().getId()).c_str());
				spectralWindowId[i] = row[i]->getSpectralWindowId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter chanFreqStart, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowChanFreqStart  sdm_addspectralwindowchanfreqstart_
extern "C" int sdm_addSpectralWindowChanFreqStart(int * spectralWindowId, double * chanFreqStart);

int sdm_addSpectralWindowChanFreqStart(int * spectralWindowId, double * chanFreqStart) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setChanFreqStart(Frequency(* chanFreqStart ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter chanFreqStart, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowChanFreqStart  sdm_getspectralwindowchanfreqstart_
extern "C" int sdm_getSpectralWindowChanFreqStart(int * spectralWindowId, double * chanFreqStart);

int sdm_getSpectralWindowChanFreqStart(int * spectralWindowId, double * chanFreqStart) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isChanFreqStartExists()) {
			*chanFreqStart = row->getChanFreqStart().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter chanFreqStep, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowChanFreqStep  sdm_addspectralwindowchanfreqstep_
extern "C" int sdm_addSpectralWindowChanFreqStep(int * spectralWindowId, double * chanFreqStep);

int sdm_addSpectralWindowChanFreqStep(int * spectralWindowId, double * chanFreqStep) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setChanFreqStep(Frequency(* chanFreqStep ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter chanFreqStep, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowChanFreqStep  sdm_getspectralwindowchanfreqstep_
extern "C" int sdm_getSpectralWindowChanFreqStep(int * spectralWindowId, double * chanFreqStep);

int sdm_getSpectralWindowChanFreqStep(int * spectralWindowId, double * chanFreqStep) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isChanFreqStepExists()) {
			*chanFreqStep = row->getChanFreqStep().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter chanFreqArray, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowChanFreqArray  sdm_addspectralwindowchanfreqarray_
extern "C" int sdm_addSpectralWindowChanFreqArray(int * spectralWindowId, double * chanFreqArray, int * chanFreqArrayDim);

int sdm_addSpectralWindowChanFreqArray(int * spectralWindowId, double * chanFreqArray, int * chanFreqArrayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Frequency >  chanFreqArrayVec(chanFreqArrayDim[0]);
		for (int i=0;i<chanFreqArrayDim[0];i++)
			chanFreqArrayVec[i]= Frequency(chanFreqArray[i] );
		row->setChanFreqArray(chanFreqArrayVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter chanFreqArray, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowChanFreqArray  sdm_getspectralwindowchanfreqarray_
extern "C" int sdm_getSpectralWindowChanFreqArray(int * spectralWindowId, double * chanFreqArray, int * chanFreqArrayDim);

int sdm_getSpectralWindowChanFreqArray(int * spectralWindowId, double * chanFreqArray, int * chanFreqArrayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isChanFreqArrayExists()) {
			// attr.CppType: vector<Frequency > attr.isOneD: true
			for (int i=0; i<min((int)row->getChanFreqArray().size(),chanFreqArrayDim[1]); i++)
				chanFreqArray[i] = row->getChanFreqArray()[i].get();
			chanFreqArrayDim[0] = row->getChanFreqArray().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter chanWidth, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowChanWidth  sdm_addspectralwindowchanwidth_
extern "C" int sdm_addSpectralWindowChanWidth(int * spectralWindowId, double * chanWidth);

int sdm_addSpectralWindowChanWidth(int * spectralWindowId, double * chanWidth) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setChanWidth(Frequency(* chanWidth ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter chanWidth, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowChanWidth  sdm_getspectralwindowchanwidth_
extern "C" int sdm_getSpectralWindowChanWidth(int * spectralWindowId, double * chanWidth);

int sdm_getSpectralWindowChanWidth(int * spectralWindowId, double * chanWidth) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isChanWidthExists()) {
			*chanWidth = row->getChanWidth().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter chanWidthArray, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowChanWidthArray  sdm_addspectralwindowchanwidtharray_
extern "C" int sdm_addSpectralWindowChanWidthArray(int * spectralWindowId, double * chanWidthArray, int * chanWidthArrayDim);

int sdm_addSpectralWindowChanWidthArray(int * spectralWindowId, double * chanWidthArray, int * chanWidthArrayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Frequency >  chanWidthArrayVec(chanWidthArrayDim[0]);
		for (int i=0;i<chanWidthArrayDim[0];i++)
			chanWidthArrayVec[i]= Frequency(chanWidthArray[i] );
		row->setChanWidthArray(chanWidthArrayVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter chanWidthArray, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowChanWidthArray  sdm_getspectralwindowchanwidtharray_
extern "C" int sdm_getSpectralWindowChanWidthArray(int * spectralWindowId, double * chanWidthArray, int * chanWidthArrayDim);

int sdm_getSpectralWindowChanWidthArray(int * spectralWindowId, double * chanWidthArray, int * chanWidthArrayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isChanWidthArrayExists()) {
			// attr.CppType: vector<Frequency > attr.isOneD: true
			for (int i=0; i<min((int)row->getChanWidthArray().size(),chanWidthArrayDim[1]); i++)
				chanWidthArray[i] = row->getChanWidthArray()[i].get();
			chanWidthArrayDim[0] = row->getChanWidthArray().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter correlationBit, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowCorrelationBit  sdm_addspectralwindowcorrelationbit_
extern "C" int sdm_addSpectralWindowCorrelationBit(int * spectralWindowId, CorrelationBit * correlationBit);

int sdm_addSpectralWindowCorrelationBit(int * spectralWindowId, CorrelationBit * correlationBit) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCorrelationBit(CorrelationBit(* correlationBit ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter correlationBit, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowCorrelationBit  sdm_getspectralwindowcorrelationbit_
extern "C" int sdm_getSpectralWindowCorrelationBit(int * spectralWindowId, CorrelationBit * correlationBit);

int sdm_getSpectralWindowCorrelationBit(int * spectralWindowId, CorrelationBit * correlationBit) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCorrelationBitExists()) {
			*correlationBit = row->getCorrelationBit();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter effectiveBw, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowEffectiveBw  sdm_addspectralwindoweffectivebw_
extern "C" int sdm_addSpectralWindowEffectiveBw(int * spectralWindowId, double * effectiveBw);

int sdm_addSpectralWindowEffectiveBw(int * spectralWindowId, double * effectiveBw) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setEffectiveBw(Frequency(* effectiveBw ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter effectiveBw, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowEffectiveBw  sdm_getspectralwindoweffectivebw_
extern "C" int sdm_getSpectralWindowEffectiveBw(int * spectralWindowId, double * effectiveBw);

int sdm_getSpectralWindowEffectiveBw(int * spectralWindowId, double * effectiveBw) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isEffectiveBwExists()) {
			*effectiveBw = row->getEffectiveBw().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter effectiveBwArray, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowEffectiveBwArray  sdm_addspectralwindoweffectivebwarray_
extern "C" int sdm_addSpectralWindowEffectiveBwArray(int * spectralWindowId, double * effectiveBwArray, int * effectiveBwArrayDim);

int sdm_addSpectralWindowEffectiveBwArray(int * spectralWindowId, double * effectiveBwArray, int * effectiveBwArrayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Frequency >  effectiveBwArrayVec(effectiveBwArrayDim[0]);
		for (int i=0;i<effectiveBwArrayDim[0];i++)
			effectiveBwArrayVec[i]= Frequency(effectiveBwArray[i] );
		row->setEffectiveBwArray(effectiveBwArrayVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter effectiveBwArray, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowEffectiveBwArray  sdm_getspectralwindoweffectivebwarray_
extern "C" int sdm_getSpectralWindowEffectiveBwArray(int * spectralWindowId, double * effectiveBwArray, int * effectiveBwArrayDim);

int sdm_getSpectralWindowEffectiveBwArray(int * spectralWindowId, double * effectiveBwArray, int * effectiveBwArrayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isEffectiveBwArrayExists()) {
			// attr.CppType: vector<Frequency > attr.isOneD: true
			for (int i=0; i<min((int)row->getEffectiveBwArray().size(),effectiveBwArrayDim[1]); i++)
				effectiveBwArray[i] = row->getEffectiveBwArray()[i].get();
			effectiveBwArrayDim[0] = row->getEffectiveBwArray().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter freqGroup, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowFreqGroup  sdm_addspectralwindowfreqgroup_
extern "C" int sdm_addSpectralWindowFreqGroup(int * spectralWindowId, int * freqGroup);

int sdm_addSpectralWindowFreqGroup(int * spectralWindowId, int * freqGroup) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setFreqGroup(int(* freqGroup ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter freqGroup, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowFreqGroup  sdm_getspectralwindowfreqgroup_
extern "C" int sdm_getSpectralWindowFreqGroup(int * spectralWindowId, int * freqGroup);

int sdm_getSpectralWindowFreqGroup(int * spectralWindowId, int * freqGroup) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFreqGroupExists()) {
			*freqGroup = row->getFreqGroup();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter freqGroupName, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowFreqGroupName  sdm_addspectralwindowfreqgroupname_
extern "C" int sdm_addSpectralWindowFreqGroupName(int * spectralWindowId, char * freqGroupName, int * freqGroupNameDim);

int sdm_addSpectralWindowFreqGroupName(int * spectralWindowId, char * freqGroupName, int * freqGroupNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setFreqGroupName(string(freqGroupName));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter freqGroupName, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowFreqGroupName  sdm_getspectralwindowfreqgroupname_
extern "C" int sdm_getSpectralWindowFreqGroupName(int * spectralWindowId, char * freqGroupName, int * freqGroupNameDim);

int sdm_getSpectralWindowFreqGroupName(int * spectralWindowId, char * freqGroupName, int * freqGroupNameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isFreqGroupNameExists()) {
			if ((int)row->getFreqGroupName().size()<freqGroupNameDim[1])
				strcpy(freqGroupName,row->getFreqGroupName().c_str());
			else
				strncpy(freqGroupName,row->getFreqGroupName().c_str(),freqGroupNameDim[1]);
			freqGroupNameDim[0] = (int)row->getFreqGroupName().size();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter lineArray, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowLineArray  sdm_addspectralwindowlinearray_
extern "C" int sdm_addSpectralWindowLineArray(int * spectralWindowId, bool * lineArray, int * lineArrayDim);

int sdm_addSpectralWindowLineArray(int * spectralWindowId, bool * lineArray, int * lineArrayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<bool >  lineArrayVec(lineArrayDim[0]);
		for (int i=0;i<lineArrayDim[0];i++)
			lineArrayVec[i]= bool(lineArray[i] );
		row->setLineArray(lineArrayVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter lineArray, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowLineArray  sdm_getspectralwindowlinearray_
extern "C" int sdm_getSpectralWindowLineArray(int * spectralWindowId, bool * lineArray, int * lineArrayDim);

int sdm_getSpectralWindowLineArray(int * spectralWindowId, bool * lineArray, int * lineArrayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isLineArrayExists()) {
			// attr.CppType: vector<bool > attr.isOneD: true
			for (int i=0; i<min((int)row->getLineArray().size(),lineArrayDim[1]); i++)
				lineArray[i] = row->getLineArray()[i];
			lineArrayDim[0] = (int)row->getLineArray().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter measFreqRef, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowMeasFreqRef  sdm_addspectralwindowmeasfreqref_
extern "C" int sdm_addSpectralWindowMeasFreqRef(int * spectralWindowId, FrequencyReferenceCode * measFreqRef);

int sdm_addSpectralWindowMeasFreqRef(int * spectralWindowId, FrequencyReferenceCode * measFreqRef) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setMeasFreqRef(FrequencyReferenceCode(* measFreqRef ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter measFreqRef, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowMeasFreqRef  sdm_getspectralwindowmeasfreqref_
extern "C" int sdm_getSpectralWindowMeasFreqRef(int * spectralWindowId, FrequencyReferenceCode * measFreqRef);

int sdm_getSpectralWindowMeasFreqRef(int * spectralWindowId, FrequencyReferenceCode * measFreqRef) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isMeasFreqRefExists()) {
			*measFreqRef = row->getMeasFreqRef();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter name, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowName  sdm_addspectralwindowname_
extern "C" int sdm_addSpectralWindowName(int * spectralWindowId, char * name, int * nameDim);

int sdm_addSpectralWindowName(int * spectralWindowId, char * name, int * nameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setName(string(name));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter name, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowName  sdm_getspectralwindowname_
extern "C" int sdm_getSpectralWindowName(int * spectralWindowId, char * name, int * nameDim);

int sdm_getSpectralWindowName(int * spectralWindowId, char * name, int * nameDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNameExists()) {
			if ((int)row->getName().size()<nameDim[1])
				strcpy(name,row->getName().c_str());
			else
				strncpy(name,row->getName().c_str(),nameDim[1]);
			nameDim[0] = (int)row->getName().size();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter oversampling, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowOversampling  sdm_addspectralwindowoversampling_
extern "C" int sdm_addSpectralWindowOversampling(int * spectralWindowId, bool * oversampling);

int sdm_addSpectralWindowOversampling(int * spectralWindowId, bool * oversampling) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setOversampling(bool(* oversampling ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter oversampling, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowOversampling  sdm_getspectralwindowoversampling_
extern "C" int sdm_getSpectralWindowOversampling(int * spectralWindowId, bool * oversampling);

int sdm_getSpectralWindowOversampling(int * spectralWindowId, bool * oversampling) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isOversamplingExists()) {
			*oversampling = row->getOversampling();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter quantization, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowQuantization  sdm_addspectralwindowquantization_
extern "C" int sdm_addSpectralWindowQuantization(int * spectralWindowId, bool * quantization);

int sdm_addSpectralWindowQuantization(int * spectralWindowId, bool * quantization) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setQuantization(bool(* quantization ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter quantization, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowQuantization  sdm_getspectralwindowquantization_
extern "C" int sdm_getSpectralWindowQuantization(int * spectralWindowId, bool * quantization);

int sdm_getSpectralWindowQuantization(int * spectralWindowId, bool * quantization) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isQuantizationExists()) {
			*quantization = row->getQuantization();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter refChan, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowRefChan  sdm_addspectralwindowrefchan_
extern "C" int sdm_addSpectralWindowRefChan(int * spectralWindowId, double * refChan);

int sdm_addSpectralWindowRefChan(int * spectralWindowId, double * refChan) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setRefChan(double(* refChan ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter refChan, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowRefChan  sdm_getspectralwindowrefchan_
extern "C" int sdm_getSpectralWindowRefChan(int * spectralWindowId, double * refChan);

int sdm_getSpectralWindowRefChan(int * spectralWindowId, double * refChan) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isRefChanExists()) {
			*refChan = row->getRefChan();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter resolution, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowResolution  sdm_addspectralwindowresolution_
extern "C" int sdm_addSpectralWindowResolution(int * spectralWindowId, double * resolution);

int sdm_addSpectralWindowResolution(int * spectralWindowId, double * resolution) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setResolution(Frequency(* resolution ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter resolution, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowResolution  sdm_getspectralwindowresolution_
extern "C" int sdm_getSpectralWindowResolution(int * spectralWindowId, double * resolution);

int sdm_getSpectralWindowResolution(int * spectralWindowId, double * resolution) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isResolutionExists()) {
			*resolution = row->getResolution().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter resolutionArray, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowResolutionArray  sdm_addspectralwindowresolutionarray_
extern "C" int sdm_addSpectralWindowResolutionArray(int * spectralWindowId, double * resolutionArray, int * resolutionArrayDim);

int sdm_addSpectralWindowResolutionArray(int * spectralWindowId, double * resolutionArray, int * resolutionArrayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Frequency >  resolutionArrayVec(resolutionArrayDim[0]);
		for (int i=0;i<resolutionArrayDim[0];i++)
			resolutionArrayVec[i]= Frequency(resolutionArray[i] );
		row->setResolutionArray(resolutionArrayVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter resolutionArray, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowResolutionArray  sdm_getspectralwindowresolutionarray_
extern "C" int sdm_getSpectralWindowResolutionArray(int * spectralWindowId, double * resolutionArray, int * resolutionArrayDim);

int sdm_getSpectralWindowResolutionArray(int * spectralWindowId, double * resolutionArray, int * resolutionArrayDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isResolutionArrayExists()) {
			// attr.CppType: vector<Frequency > attr.isOneD: true
			for (int i=0; i<min((int)row->getResolutionArray().size(),resolutionArrayDim[1]); i++)
				resolutionArray[i] = row->getResolutionArray()[i].get();
			resolutionArrayDim[0] = row->getResolutionArray().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numAssocValues, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowNumAssocValues  sdm_addspectralwindownumassocvalues_
extern "C" int sdm_addSpectralWindowNumAssocValues(int * spectralWindowId, int * numAssocValues);

int sdm_addSpectralWindowNumAssocValues(int * spectralWindowId, int * numAssocValues) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumAssocValues(int(* numAssocValues ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numAssocValues, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowNumAssocValues  sdm_getspectralwindownumassocvalues_
extern "C" int sdm_getSpectralWindowNumAssocValues(int * spectralWindowId, int * numAssocValues);

int sdm_getSpectralWindowNumAssocValues(int * spectralWindowId, int * numAssocValues) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumAssocValuesExists()) {
			*numAssocValues = row->getNumAssocValues();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter assocNature, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowAssocNature  sdm_addspectralwindowassocnature_
extern "C" int sdm_addSpectralWindowAssocNature(int * spectralWindowId, SpectralResolutionType * assocNature, int * assocNatureDim);

int sdm_addSpectralWindowAssocNature(int * spectralWindowId, SpectralResolutionType * assocNature, int * assocNatureDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<SpectralResolutionTypeMod::SpectralResolutionType >  assocNatureVec(assocNatureDim[0]);
		for (int i=0;i<assocNatureDim[0];i++)
			assocNatureVec[i]= SpectralResolutionType(assocNature[i] );
		row->setAssocNature(assocNatureVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter assocNature, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowAssocNature  sdm_getspectralwindowassocnature_
extern "C" int sdm_getSpectralWindowAssocNature(int * spectralWindowId, SpectralResolutionType * assocNature, int * assocNatureDim);

int sdm_getSpectralWindowAssocNature(int * spectralWindowId, SpectralResolutionType * assocNature, int * assocNatureDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAssocNatureExists()) {
			// attr.CppType: vector<SpectralResolutionTypeMod::SpectralResolutionType > attr.isOneD: true
			for (int i=0; i<min((int)row->getAssocNature().size(),assocNatureDim[1]); i++)
				assocNature[i] = row->getAssocNature()[i];
			assocNatureDim[0] = (int)row->getAssocNature().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter assocSpectralWindowId, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowAssocSpectralWindowId  sdm_addspectralwindowassocspectralwindowid_
extern "C" int sdm_addSpectralWindowAssocSpectralWindowId(int * spectralWindowId, int * assocSpectralWindowId, int * assocSpectralWindowIdDim);

int sdm_addSpectralWindowAssocSpectralWindowId(int * spectralWindowId, int * assocSpectralWindowId, int * assocSpectralWindowIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Tag>   assocSpectralWindowIdVec(assocSpectralWindowIdDim[0]);
		for (int i=0;i<assocSpectralWindowIdDim[0];i++)
			assocSpectralWindowIdVec[i]= Tag(assocSpectralWindowId[i] , TagType::SpectralWindow);
		row->setAssocSpectralWindowId(assocSpectralWindowIdVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter assocSpectralWindowId, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowAssocSpectralWindowId  sdm_getspectralwindowassocspectralwindowid_
extern "C" int sdm_getSpectralWindowAssocSpectralWindowId(int * spectralWindowId, int * assocSpectralWindowId, int * assocSpectralWindowIdDim);

int sdm_getSpectralWindowAssocSpectralWindowId(int * spectralWindowId, int * assocSpectralWindowId, int * assocSpectralWindowIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isAssocSpectralWindowIdExists()) {
			// attr.CppType: vector<Tag>  attr.isOneD: true
			for (int i=0; i<min((int)row->getAssocSpectralWindowId().size(),assocSpectralWindowIdDim[1]); i++)
			// assocSpectralWindowId[i] = atoi((row->getAssocSpectralWindowId()[i]).getId().c_str());
			assocSpectralWindowId[i] = row->getAssocSpectralWindowId()[i].getTagValue();
			assocSpectralWindowIdDim[0] = (int)row->getAssocSpectralWindowId().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter imageSpectralWindowId, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowImageSpectralWindowId  sdm_addspectralwindowimagespectralwindowid_
extern "C" int sdm_addSpectralWindowImageSpectralWindowId(int * spectralWindowId, int * imageSpectralWindowId);

int sdm_addSpectralWindowImageSpectralWindowId(int * spectralWindowId, int * imageSpectralWindowId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setImageSpectralWindowId(Tag(* imageSpectralWindowId , TagType::SpectralWindow));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter imageSpectralWindowId, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowImageSpectralWindowId  sdm_getspectralwindowimagespectralwindowid_
extern "C" int sdm_getSpectralWindowImageSpectralWindowId(int * spectralWindowId, int * imageSpectralWindowId);

int sdm_getSpectralWindowImageSpectralWindowId(int * spectralWindowId, int * imageSpectralWindowId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isImageSpectralWindowIdExists()) {
			// *imageSpectralWindowId = atoi((row->getImageSpectralWindowId().getId()).c_str());
			*imageSpectralWindowId = row->getImageSpectralWindowId().getTagValue();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter dopplerId, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_addSpectralWindowDopplerId  sdm_addspectralwindowdopplerid_
extern "C" int sdm_addSpectralWindowDopplerId(int * spectralWindowId, int * dopplerId);

int sdm_addSpectralWindowDopplerId(int * spectralWindowId, int * dopplerId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SpectralWindowTable &table = dataset->getSpectralWindow();
	
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDopplerId(int(* dopplerId ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter dopplerId, in a row of the SpectralWindow table, given a key
 *
 */

#define sdm_getSpectralWindowDopplerId  sdm_getspectralwindowdopplerid_
extern "C" int sdm_getSpectralWindowDopplerId(int * spectralWindowId, int * dopplerId);

int sdm_getSpectralWindowDopplerId(int * spectralWindowId, int * dopplerId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SpectralWindowTable &table = dataset->getSpectralWindow();
	SpectralWindowRow *row = 0;
	row = table.getRowByKey( Tag(*spectralWindowId, TagType::SpectralWindow));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDopplerIdExists()) {
			*dopplerId = row->getDopplerId();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace DetectorBandTypeMod;


// =================== SquareLawDetectorTable ============================

extern "C" int sdm_addSquareLawDetectorRow (int * numBand, DetectorBandType * bandType);
extern "C" int sdm_getSquareLawDetectorRow (int * squareLawDetectorId, int * numBand, DetectorBandType * bandType);


extern "C" int sdm_getSquareLawDetectorTableSize ();

extern "C" int sdm_getSquareLawDetectorKeys (int * squareLawDetectorId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addSquareLawDetectorRow (int * numBand, DetectorBandType * bandType){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	SquareLawDetectorTable &table = dataset->getSquareLawDetector();
	SquareLawDetectorRow *row = 0;

	// bandType is an enumeration
	// DetectorBandType * bandType =  (int) bandType;
	
	// Create new row
  
	row = table.newRow(*numBand, *bandType);

	// Add row
	SquareLawDetectorRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the SquareLawDetectorTable" << endl;
	}
	
	// return atoi((retRow->getSquareLawDetectorId().getId()).c_str());
	return retRow->getSquareLawDetectorId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a SquareLawDetectorRow* given a key.
 */
int sdm_getSquareLawDetectorRow (int * squareLawDetectorId, int * numBand, DetectorBandType * bandType) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SquareLawDetectorTable &table = dataset->getSquareLawDetector();
	SquareLawDetectorRow *row = 0;
	// row = table.getRowByKey( Tag(*modeId, TagType::SquareLawDetector));
	row = table.getRowByKey( Tag(*squareLawDetectorId, TagType::SquareLawDetector));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  squareLawDetectorId  attr.UpperCaseName: SquareLawDetectorId
		//  attr.NameS:  numBand  attr.UpperCaseName: NumBand
		*numBand = row->getNumBand();
		//  attr.NameS:  bandType  attr.UpperCaseName: BandType
		*bandType = row->getBandType();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getSquareLawDetectorTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
SquareLawDetectorTable &table = dataset->getSquareLawDetector();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getSquareLawDetectorKeys(int * squareLawDetectorId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	SquareLawDetectorTable &table = dataset->getSquareLawDetector();
	
	vector< SquareLawDetectorRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// squareLawDetectorId[i] = atoi((row[i]->getSquareLawDetectorId().getId()).c_str());
				squareLawDetectorId[i] = row[i]->getSquareLawDetectorId().getTagValue();
  		}
  		
		return size;
  	}
}





using namespace CalibrationDeviceMod;


// =================== StateTable ============================

extern "C" int sdm_addStateRow (CalibrationDevice * calDeviceName, bool * sig, bool * ref, bool * onSky);
extern "C" int sdm_getStateRow (int * stateId, CalibrationDevice * calDeviceName, bool * sig, bool * ref, bool * onSky);


extern "C" int sdm_getStateTableSize ();

extern "C" int sdm_getStateKeys (int * stateId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addStateRow (CalibrationDevice * calDeviceName, bool * sig, bool * ref, bool * onSky){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	StateTable &table = dataset->getState();
	StateRow *row = 0;

	// calDeviceName is an enumeration
	// CalibrationDevice * calDeviceName =  (int) calDeviceName;
	
	// Create new row
  
	row = table.newRow(*calDeviceName, *sig, *ref, *onSky);

	// Add row
	StateRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the StateTable" << endl;
	}
	
	// return atoi((retRow->getStateId().getId()).c_str());
	return retRow->getStateId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a StateRow* given a key.
 */
int sdm_getStateRow (int * stateId, CalibrationDevice * calDeviceName, bool * sig, bool * ref, bool * onSky) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	StateTable &table = dataset->getState();
	StateRow *row = 0;
	row = table.getRowByKey( Tag(*stateId, TagType::State));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  stateId  attr.UpperCaseName: StateId
		//  attr.NameS:  calDeviceName  attr.UpperCaseName: CalDeviceName
		*calDeviceName = row->getCalDeviceName();
		//  attr.NameS:  sig  attr.UpperCaseName: Sig
		*sig = row->getSig();
		//  attr.NameS:  ref  attr.UpperCaseName: Ref
		*ref = row->getRef();
		//  attr.NameS:  onSky  attr.UpperCaseName: OnSky
		*onSky = row->getOnSky();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getStateTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
StateTable &table = dataset->getState();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getStateKeys(int * stateId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	StateTable &table = dataset->getState();
	
	vector< StateRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// stateId[i] = atoi((row[i]->getStateId().getId()).c_str());
				stateId[i] = row[i]->getStateId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter weight, in a row of the State table, given a key
 *
 */

#define sdm_addStateWeight  sdm_addstateweight_
extern "C" int sdm_addStateWeight(int * stateId, float * weight);

int sdm_addStateWeight(int * stateId, float * weight) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	StateTable &table = dataset->getState();
	
	StateRow *row = 0;
	row = table.getRowByKey( Tag(*stateId, TagType::State));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setWeight(float(* weight ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter weight, in a row of the State table, given a key
 *
 */

#define sdm_getStateWeight  sdm_getstateweight_
extern "C" int sdm_getStateWeight(int * stateId, float * weight);

int sdm_getStateWeight(int * stateId, float * weight) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	StateTable &table = dataset->getState();
	StateRow *row = 0;
	row = table.getRowByKey( Tag(*stateId, TagType::State));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isWeightExists()) {
			*weight = row->getWeight();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace StationTypeMod;


// =================== StationTable ============================

extern "C" int sdm_addStationRow (char * name, int * nameDim, double * position, int * positionDim, StationType * type);
extern "C" int sdm_getStationRow (int * stationId, char * name, int * nameDim, double * position, int * positionDim, StationType * type);


extern "C" int sdm_getStationTableSize ();

extern "C" int sdm_getStationKeys (int * stationId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addStationRow (char * name, int * nameDim, double * position, int * positionDim, StationType * type){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	StationTable &table = dataset->getStation();
	StationRow *row = 0;

	// position is an Array
	// position is OneD
	vector<Length >  positionVec(positionDim[0]);
	for (int i=0;i<positionDim[0];i++)
		positionVec[i]= Length(position[i]   );
	// type is an enumeration
	// StationType * type =  (int) type;
	
	// Create new row
  
	row = table.newRow(string(name), positionVec, *type);

	// Add row
	StationRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the StationTable" << endl;
	}
	
	// return atoi((retRow->getStationId().getId()).c_str());
	return retRow->getStationId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a StationRow* given a key.
 */
int sdm_getStationRow (int * stationId, char * name, int * nameDim, double * position, int * positionDim, StationType * type) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	StationTable &table = dataset->getStation();
	StationRow *row = 0;
	row = table.getRowByKey( Tag(*stationId, TagType::Station));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  stationId  attr.UpperCaseName: StationId
		//  attr.NameS:  name  attr.UpperCaseName: Name
		if ((int)row->getName().size()<nameDim[1])
			strcpy(name,row->getName().c_str());
		else
			strncpy(name,row->getName().c_str(),nameDim[1]);
		nameDim[0] = (int)row->getName().size();
		//  attr.NameS:  position  attr.UpperCaseName: Position
		
		vector<Length >  positionVec = row->getPosition();
		
		for (int i=0; i<min((int)positionVec.size(),positionDim[1]); i++)
			position[i] = positionVec[i].get();
		positionDim[0] = positionVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  type  attr.UpperCaseName: Type
		*type = row->getType();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getStationTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
StationTable &table = dataset->getStation();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getStationKeys(int * stationId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	StationTable &table = dataset->getStation();
	
	vector< StationRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// stationId[i] = atoi((row[i]->getStationId().getId()).c_str());
				stationId[i] = row[i]->getStationId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter time, in a row of the Station table, given a key
 *
 */

#define sdm_addStationTime  sdm_addstationtime_
extern "C" int sdm_addStationTime(int * stationId, int64_t * time);

int sdm_addStationTime(int * stationId, int64_t * time) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	StationTable &table = dataset->getStation();
	
	StationRow *row = 0;
	row = table.getRowByKey( Tag(*stationId, TagType::Station));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTime(ArrayTime(* time ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter time, in a row of the Station table, given a key
 *
 */

#define sdm_getStationTime  sdm_getstationtime_
extern "C" int sdm_getStationTime(int * stationId, int64_t * time);

int sdm_getStationTime(int * stationId, int64_t * time) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	StationTable &table = dataset->getStation();
	StationRow *row = 0;
	row = table.getRowByKey( Tag(*stationId, TagType::Station));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTimeExists()) {
			*time     = row->getTime().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace SubscanIntentMod;
using namespace SwitchingModeMod;
using namespace CorrelatorCalibrationMod;


// =================== SubscanTable ============================

extern "C" int sdm_addSubscanRow (int * execBlockId, int * scanNumber, int * subscanNumber, int64_t * startTime, int64_t * endTime, char * fieldName, int * fieldNameDim, SubscanIntent * subscanIntent, int * numIntegration, int * numSubintegration, int * numSubintegrationDim);
extern "C" int sdm_getSubscanRow (int * execBlockId, int * scanNumber, int * subscanNumber, int64_t * startTime, int64_t * endTime, char * fieldName, int * fieldNameDim, SubscanIntent * subscanIntent, int * numIntegration, int * numSubintegration, int * numSubintegrationDim);


extern "C" int sdm_getSubscanTableSize ();

extern "C" int sdm_getSubscanKeys (int * execBlockId, int * scanNumber, int * subscanNumber);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addSubscanRow (int * execBlockId, int * scanNumber, int * subscanNumber, int64_t * startTime, int64_t * endTime, char * fieldName, int * fieldNameDim, SubscanIntent * subscanIntent, int * numIntegration, int * numSubintegration, int * numSubintegrationDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	SubscanTable &table = dataset->getSubscan();
	SubscanRow *row = 0;

	// subscanIntent is an enumeration
	// SubscanIntent * subscanIntent =  (int) subscanIntent;
	// numSubintegration is an Array
	// numSubintegration is OneD
	vector<int >  numSubintegrationVec(numSubintegrationDim[0]);
	for (int i=0;i<numSubintegrationDim[0];i++)
		numSubintegrationVec[i]= int(numSubintegration[i]   );
	
	// Create new row
  
	row = table.newRow(Tag(*execBlockId,TagType::ExecBlock), *scanNumber, *subscanNumber, ArrayTime(*startTime), ArrayTime(*endTime), string(fieldName), *subscanIntent, *numIntegration, numSubintegrationVec);

	// Add row
	SubscanRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the SubscanTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a SubscanRow* given a key.
 */
int sdm_getSubscanRow (int * execBlockId, int * scanNumber, int * subscanNumber, int64_t * startTime, int64_t * endTime, char * fieldName, int * fieldNameDim, SubscanIntent * subscanIntent, int * numIntegration, int * numSubintegration, int * numSubintegrationDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SubscanTable &table = dataset->getSubscan();
	SubscanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber, *subscanNumber);
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  execBlockId  attr.UpperCaseName: ExecBlockId
		//  attr.NameS:  scanNumber  attr.UpperCaseName: ScanNumber
		//  attr.NameS:  subscanNumber  attr.UpperCaseName: SubscanNumber
		//  attr.NameS:  startTime  attr.UpperCaseName: StartTime
		*startTime     = row->getStartTime().get();
		//  attr.NameS:  endTime  attr.UpperCaseName: EndTime
		*endTime     = row->getEndTime().get();
		//  attr.NameS:  fieldName  attr.UpperCaseName: FieldName
		if ((int)row->getFieldName().size()<fieldNameDim[1])
			strcpy(fieldName,row->getFieldName().c_str());
		else
			strncpy(fieldName,row->getFieldName().c_str(),fieldNameDim[1]);
		fieldNameDim[0] = (int)row->getFieldName().size();
		//  attr.NameS:  subscanIntent  attr.UpperCaseName: SubscanIntent
		*subscanIntent = row->getSubscanIntent();
		//  attr.NameS:  numIntegration  attr.UpperCaseName: NumIntegration
		*numIntegration = row->getNumIntegration();
		//  attr.NameS:  numSubintegration  attr.UpperCaseName: NumSubintegration
		
		vector<int >  numSubintegrationVec = row->getNumSubintegration();
		
		for (int i=0; i<min((int)numSubintegrationVec.size(),numSubintegrationDim[1]); i++)
			numSubintegration[i] = numSubintegrationVec[i];
		numSubintegrationDim[0] = (int)numSubintegrationVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getSubscanTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
SubscanTable &table = dataset->getSubscan();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getSubscanKeys(int * execBlockId, int * scanNumber, int * subscanNumber) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	SubscanTable &table = dataset->getSubscan();
	
	vector< SubscanRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// execBlockId[i] = atoi((row[i]->getExecBlockId().getId()).c_str());
				execBlockId[i] = row[i]->getExecBlockId().getTagValue();
	  		scanNumber[i] = row[i]->getScanNumber();
	  		subscanNumber[i] = row[i]->getSubscanNumber();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter subscanMode, in a row of the Subscan table, given a key
 *
 */

#define sdm_addSubscanSubscanMode  sdm_addsubscansubscanmode_
extern "C" int sdm_addSubscanSubscanMode(int * execBlockId, int * scanNumber, int * subscanNumber, SwitchingMode * subscanMode);

int sdm_addSubscanSubscanMode(int * execBlockId, int * scanNumber, int * subscanNumber, SwitchingMode * subscanMode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SubscanTable &table = dataset->getSubscan();
	
	SubscanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber, *subscanNumber);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSubscanMode(SwitchingMode(* subscanMode ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter subscanMode, in a row of the Subscan table, given a key
 *
 */

#define sdm_getSubscanSubscanMode  sdm_getsubscansubscanmode_
extern "C" int sdm_getSubscanSubscanMode(int * execBlockId, int * scanNumber, int * subscanNumber, SwitchingMode * subscanMode);

int sdm_getSubscanSubscanMode(int * execBlockId, int * scanNumber, int * subscanNumber, SwitchingMode * subscanMode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SubscanTable &table = dataset->getSubscan();
	SubscanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber, *subscanNumber);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSubscanModeExists()) {
			*subscanMode = row->getSubscanMode();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter correlatorCalibration, in a row of the Subscan table, given a key
 *
 */

#define sdm_addSubscanCorrelatorCalibration  sdm_addsubscancorrelatorcalibration_
extern "C" int sdm_addSubscanCorrelatorCalibration(int * execBlockId, int * scanNumber, int * subscanNumber, CorrelatorCalibration * correlatorCalibration);

int sdm_addSubscanCorrelatorCalibration(int * execBlockId, int * scanNumber, int * subscanNumber, CorrelatorCalibration * correlatorCalibration) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SubscanTable &table = dataset->getSubscan();
	
	SubscanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber, *subscanNumber);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCorrelatorCalibration(CorrelatorCalibration(* correlatorCalibration ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter correlatorCalibration, in a row of the Subscan table, given a key
 *
 */

#define sdm_getSubscanCorrelatorCalibration  sdm_getsubscancorrelatorcalibration_
extern "C" int sdm_getSubscanCorrelatorCalibration(int * execBlockId, int * scanNumber, int * subscanNumber, CorrelatorCalibration * correlatorCalibration);

int sdm_getSubscanCorrelatorCalibration(int * execBlockId, int * scanNumber, int * subscanNumber, CorrelatorCalibration * correlatorCalibration) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SubscanTable &table = dataset->getSubscan();
	SubscanRow *row = 0;
	row = table.getRowByKey( Tag(*execBlockId, TagType::ExecBlock), *scanNumber, *subscanNumber);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCorrelatorCalibrationExists()) {
			*correlatorCalibration = row->getCorrelatorCalibration();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace DirectionReferenceCodeMod;


// =================== SwitchCycleTable ============================

extern "C" int sdm_addSwitchCycleRow (int * numStep, float * weightArray, int * weightArrayDim, double * dirOffsetArray, int * dirOffsetArrayDim, double * freqOffsetArray, int * freqOffsetArrayDim, int64_t * stepDurationArray, int * stepDurationArrayDim);
extern "C" int sdm_getSwitchCycleRow (int * switchCycleId, int * numStep, float * weightArray, int * weightArrayDim, double * dirOffsetArray, int * dirOffsetArrayDim, double * freqOffsetArray, int * freqOffsetArrayDim, int64_t * stepDurationArray, int * stepDurationArrayDim);


extern "C" int sdm_getSwitchCycleTableSize ();

extern "C" int sdm_getSwitchCycleKeys (int * switchCycleId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addSwitchCycleRow (int * numStep, float * weightArray, int * weightArrayDim, double * dirOffsetArray, int * dirOffsetArrayDim, double * freqOffsetArray, int * freqOffsetArrayDim, int64_t * stepDurationArray, int * stepDurationArrayDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	SwitchCycleTable &table = dataset->getSwitchCycle();
	SwitchCycleRow *row = 0;

	// weightArray is an Array
	// weightArray is OneD
	vector<float >  weightArrayVec(weightArrayDim[0]);
	for (int i=0;i<weightArrayDim[0];i++)
		weightArrayVec[i]= float(weightArray[i]   );
	// dirOffsetArray is an Array
	// dirOffsetArray is 2 D
	vector<vector<Angle > >  dirOffsetArrayVec(dirOffsetArrayDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<dirOffsetArrayDim[2];i++) {
		dirOffsetArrayVec[i].resize(dirOffsetArrayDim[0]);
		for (int j=0;j<dirOffsetArrayDim[0];j++)
			dirOffsetArrayVec[i][j]= Angle(dirOffsetArray[i*dirOffsetArrayDim[1]+j]  );
	
	
	}
	// freqOffsetArray is an Array
	// freqOffsetArray is OneD
	vector<Frequency >  freqOffsetArrayVec(freqOffsetArrayDim[0]);
	for (int i=0;i<freqOffsetArrayDim[0];i++)
		freqOffsetArrayVec[i]= Frequency(freqOffsetArray[i]   );
	// stepDurationArray is an Array
	// stepDurationArray is OneD
	vector<Interval >  stepDurationArrayVec(stepDurationArrayDim[0]);
	for (int i=0;i<stepDurationArrayDim[0];i++)
		stepDurationArrayVec[i]= Interval(stepDurationArray[i]   );
	
	// Create new row
  
	row = table.newRow(*numStep, weightArrayVec, dirOffsetArrayVec, freqOffsetArrayVec, stepDurationArrayVec);

	// Add row
	SwitchCycleRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the SwitchCycleTable" << endl;
	}
	
	// return atoi((retRow->getSwitchCycleId().getId()).c_str());
	return retRow->getSwitchCycleId().getTagValue();
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a SwitchCycleRow* given a key.
 */
int sdm_getSwitchCycleRow (int * switchCycleId, int * numStep, float * weightArray, int * weightArrayDim, double * dirOffsetArray, int * dirOffsetArrayDim, double * freqOffsetArray, int * freqOffsetArrayDim, int64_t * stepDurationArray, int * stepDurationArrayDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SwitchCycleTable &table = dataset->getSwitchCycle();
	SwitchCycleRow *row = 0;
	row = table.getRowByKey( Tag(*switchCycleId, TagType::SwitchCycle));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  switchCycleId  attr.UpperCaseName: SwitchCycleId
		//  attr.NameS:  numStep  attr.UpperCaseName: NumStep
		*numStep = row->getNumStep();
		//  attr.NameS:  weightArray  attr.UpperCaseName: WeightArray
		
		vector<float >  weightArrayVec = row->getWeightArray();
		
		for (int i=0; i<min((int)weightArrayVec.size(),weightArrayDim[1]); i++)
			weightArray[i] = weightArrayVec[i];
		weightArrayDim[0] = (int)weightArrayVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  dirOffsetArray  attr.UpperCaseName: DirOffsetArray
		
		vector<vector<Angle > >  dirOffsetArrayVec = row->getDirOffsetArray();
		
		int maxDimZeroDirOffsetArray = 0;
		for (int i=0; i< min((int)dirOffsetArrayVec.size(),dirOffsetArrayDim[3]) ;i++) {
			maxDimZeroDirOffsetArray = max((int)dirOffsetArrayVec[i].size(),maxDimZeroDirOffsetArray);
			for (int j=0; j<min((int)dirOffsetArrayVec[i].size(),dirOffsetArrayDim[1]) ;j++) {
				dirOffsetArray[i*dirOffsetArrayDim[1]+j] = dirOffsetArrayVec[i][j].get();
			}
		}
		dirOffsetArrayDim[0] = maxDimZeroDirOffsetArray;
		dirOffsetArrayDim[2] = dirOffsetArrayVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  freqOffsetArray  attr.UpperCaseName: FreqOffsetArray
		
		vector<Frequency >  freqOffsetArrayVec = row->getFreqOffsetArray();
		
		for (int i=0; i<min((int)freqOffsetArrayVec.size(),freqOffsetArrayDim[1]); i++)
			freqOffsetArray[i] = freqOffsetArrayVec[i].get();
		freqOffsetArrayDim[0] = freqOffsetArrayVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  stepDurationArray  attr.UpperCaseName: StepDurationArray
		
		vector<Interval >  stepDurationArrayVec = row->getStepDurationArray();
		
		for (int i=0; i<min((int)stepDurationArrayVec.size(),stepDurationArrayDim[1]); i++)
			stepDurationArray[i] = stepDurationArrayVec[i].get();
		stepDurationArrayDim[0] = stepDurationArrayVec.size(); // return dimension of the ASDM table
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getSwitchCycleTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
SwitchCycleTable &table = dataset->getSwitchCycle();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getSwitchCycleKeys(int * switchCycleId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	SwitchCycleTable &table = dataset->getSwitchCycle();
	
	vector< SwitchCycleRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// switchCycleId[i] = atoi((row[i]->getSwitchCycleId().getId()).c_str());
				switchCycleId[i] = row[i]->getSwitchCycleId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter directionCode, in a row of the SwitchCycle table, given a key
 *
 */

#define sdm_addSwitchCycleDirectionCode  sdm_addswitchcycledirectioncode_
extern "C" int sdm_addSwitchCycleDirectionCode(int * switchCycleId, DirectionReferenceCode * directionCode);

int sdm_addSwitchCycleDirectionCode(int * switchCycleId, DirectionReferenceCode * directionCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SwitchCycleTable &table = dataset->getSwitchCycle();
	
	SwitchCycleRow *row = 0;
	row = table.getRowByKey( Tag(*switchCycleId, TagType::SwitchCycle));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDirectionCode(DirectionReferenceCode(* directionCode ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter directionCode, in a row of the SwitchCycle table, given a key
 *
 */

#define sdm_getSwitchCycleDirectionCode  sdm_getswitchcycledirectioncode_
extern "C" int sdm_getSwitchCycleDirectionCode(int * switchCycleId, DirectionReferenceCode * directionCode);

int sdm_getSwitchCycleDirectionCode(int * switchCycleId, DirectionReferenceCode * directionCode) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SwitchCycleTable &table = dataset->getSwitchCycle();
	SwitchCycleRow *row = 0;
	row = table.getRowByKey( Tag(*switchCycleId, TagType::SwitchCycle));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDirectionCodeExists()) {
			*directionCode = row->getDirectionCode();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter directionEquinox, in a row of the SwitchCycle table, given a key
 *
 */

#define sdm_addSwitchCycleDirectionEquinox  sdm_addswitchcycledirectionequinox_
extern "C" int sdm_addSwitchCycleDirectionEquinox(int * switchCycleId, int64_t * directionEquinox);

int sdm_addSwitchCycleDirectionEquinox(int * switchCycleId, int64_t * directionEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SwitchCycleTable &table = dataset->getSwitchCycle();
	
	SwitchCycleRow *row = 0;
	row = table.getRowByKey( Tag(*switchCycleId, TagType::SwitchCycle));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDirectionEquinox(ArrayTime(* directionEquinox ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter directionEquinox, in a row of the SwitchCycle table, given a key
 *
 */

#define sdm_getSwitchCycleDirectionEquinox  sdm_getswitchcycledirectionequinox_
extern "C" int sdm_getSwitchCycleDirectionEquinox(int * switchCycleId, int64_t * directionEquinox);

int sdm_getSwitchCycleDirectionEquinox(int * switchCycleId, int64_t * directionEquinox) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SwitchCycleTable &table = dataset->getSwitchCycle();
	SwitchCycleRow *row = 0;
	row = table.getRowByKey( Tag(*switchCycleId, TagType::SwitchCycle));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDirectionEquinoxExists()) {
			*directionEquinox     = row->getDirectionEquinox().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}




// =================== SysCalTable ============================

extern "C" int sdm_addSysCalRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor, int * numChan);
extern "C" int sdm_getSysCalRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor, int * numChan);


extern "C" int sdm_getSysCalTableSize ();

extern "C" int sdm_getSysCalKeys (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addSysCalRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor, int * numChan){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;

	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId, *numReceptor, *numChan);
	} else {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId, *numReceptor, *numChan);
	}

	// Add row
	SysCalRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the SysCalTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a SysCalRow* given a key.
 */
int sdm_getSysCalRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, int * numReceptor, int * numChan) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  feedId  attr.UpperCaseName: FeedId
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		//  attr.NameS:  numChan  attr.UpperCaseName: NumChan
		*numChan = row->getNumChan();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getSysCalTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
SysCalTable &table = dataset->getSysCal();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getSysCalKeys(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	
	vector< SysCalRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		// spectralWindowId[i] = atoi((row[i]->getSpectralWindowId().getId()).c_str());
				spectralWindowId[i] = row[i]->getSpectralWindowId().getTagValue();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
	  		feedId[i] = row[i]->getFeedId();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter tcalFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTcalFlag  sdm_addsyscaltcalflag_
extern "C" int sdm_addSysCalTcalFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tcalFlag);

int sdm_addSysCalTcalFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tcalFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTcalFlag(bool(* tcalFlag ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tcalFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTcalFlag  sdm_getsyscaltcalflag_
extern "C" int sdm_getSysCalTcalFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tcalFlag);

int sdm_getSysCalTcalFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tcalFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTcalFlagExists()) {
			*tcalFlag = row->getTcalFlag();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter tcalSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTcalSpectrum  sdm_addsyscaltcalspectrum_
extern "C" int sdm_addSysCalTcalSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tcalSpectrum, int * tcalSpectrumDim);

int sdm_addSysCalTcalSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tcalSpectrum, int * tcalSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par tcalSpectrum:
		vector<vector<Temperature > >  tcalSpectrumVec(tcalSpectrumDim[2]);
		for (int i=0;i<tcalSpectrumDim[2];i++) {
			tcalSpectrumVec[i].resize(tcalSpectrumDim[0]);
			for (int j=0;j<tcalSpectrumDim[0];j++)
				tcalSpectrumVec[i][j]= Temperature(tcalSpectrum[i*(tcalSpectrumDim[1])+j]);
		}
		row->setTcalSpectrum(tcalSpectrumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tcalSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTcalSpectrum  sdm_getsyscaltcalspectrum_
extern "C" int sdm_getSysCalTcalSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tcalSpectrum, int * tcalSpectrumDim);

int sdm_getSysCalTcalSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tcalSpectrum, int * tcalSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTcalSpectrumExists()) {
			// attr.CppType: vector<vector<Temperature > > attr.isOneD: false
			int maxDimZeroTcalSpectrum = 0;
			for (int i=0; i< min((int)row->getTcalSpectrum().size(),tcalSpectrumDim[3]) ;i++) {
				maxDimZeroTcalSpectrum = max((int)row->getTcalSpectrum()[i].size(),maxDimZeroTcalSpectrum);
				for (int j=0; j<min((int)row->getTcalSpectrum()[i].size(),tcalSpectrumDim[1]) ;j++) {
					tcalSpectrum[i*tcalSpectrumDim[1]+j] = row->getTcalSpectrum()[i][j].get();
				}
			}
			tcalSpectrumDim[0] = maxDimZeroTcalSpectrum;
			tcalSpectrumDim[2] = row->getTcalSpectrum().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter trxFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTrxFlag  sdm_addsyscaltrxflag_
extern "C" int sdm_addSysCalTrxFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * trxFlag);

int sdm_addSysCalTrxFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * trxFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTrxFlag(bool(* trxFlag ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter trxFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTrxFlag  sdm_getsyscaltrxflag_
extern "C" int sdm_getSysCalTrxFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * trxFlag);

int sdm_getSysCalTrxFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * trxFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTrxFlagExists()) {
			*trxFlag = row->getTrxFlag();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter trxSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTrxSpectrum  sdm_addsyscaltrxspectrum_
extern "C" int sdm_addSysCalTrxSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * trxSpectrum, int * trxSpectrumDim);

int sdm_addSysCalTrxSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * trxSpectrum, int * trxSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par trxSpectrum:
		vector<vector<Temperature > >  trxSpectrumVec(trxSpectrumDim[2]);
		for (int i=0;i<trxSpectrumDim[2];i++) {
			trxSpectrumVec[i].resize(trxSpectrumDim[0]);
			for (int j=0;j<trxSpectrumDim[0];j++)
				trxSpectrumVec[i][j]= Temperature(trxSpectrum[i*(trxSpectrumDim[1])+j]);
		}
		row->setTrxSpectrum(trxSpectrumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter trxSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTrxSpectrum  sdm_getsyscaltrxspectrum_
extern "C" int sdm_getSysCalTrxSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * trxSpectrum, int * trxSpectrumDim);

int sdm_getSysCalTrxSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * trxSpectrum, int * trxSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTrxSpectrumExists()) {
			// attr.CppType: vector<vector<Temperature > > attr.isOneD: false
			int maxDimZeroTrxSpectrum = 0;
			for (int i=0; i< min((int)row->getTrxSpectrum().size(),trxSpectrumDim[3]) ;i++) {
				maxDimZeroTrxSpectrum = max((int)row->getTrxSpectrum()[i].size(),maxDimZeroTrxSpectrum);
				for (int j=0; j<min((int)row->getTrxSpectrum()[i].size(),trxSpectrumDim[1]) ;j++) {
					trxSpectrum[i*trxSpectrumDim[1]+j] = row->getTrxSpectrum()[i][j].get();
				}
			}
			trxSpectrumDim[0] = maxDimZeroTrxSpectrum;
			trxSpectrumDim[2] = row->getTrxSpectrum().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter tskyFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTskyFlag  sdm_addsyscaltskyflag_
extern "C" int sdm_addSysCalTskyFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tskyFlag);

int sdm_addSysCalTskyFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tskyFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTskyFlag(bool(* tskyFlag ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tskyFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTskyFlag  sdm_getsyscaltskyflag_
extern "C" int sdm_getSysCalTskyFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tskyFlag);

int sdm_getSysCalTskyFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tskyFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTskyFlagExists()) {
			*tskyFlag = row->getTskyFlag();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter tskySpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTskySpectrum  sdm_addsyscaltskyspectrum_
extern "C" int sdm_addSysCalTskySpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tskySpectrum, int * tskySpectrumDim);

int sdm_addSysCalTskySpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tskySpectrum, int * tskySpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par tskySpectrum:
		vector<vector<Temperature > >  tskySpectrumVec(tskySpectrumDim[2]);
		for (int i=0;i<tskySpectrumDim[2];i++) {
			tskySpectrumVec[i].resize(tskySpectrumDim[0]);
			for (int j=0;j<tskySpectrumDim[0];j++)
				tskySpectrumVec[i][j]= Temperature(tskySpectrum[i*(tskySpectrumDim[1])+j]);
		}
		row->setTskySpectrum(tskySpectrumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tskySpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTskySpectrum  sdm_getsyscaltskyspectrum_
extern "C" int sdm_getSysCalTskySpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tskySpectrum, int * tskySpectrumDim);

int sdm_getSysCalTskySpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tskySpectrum, int * tskySpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTskySpectrumExists()) {
			// attr.CppType: vector<vector<Temperature > > attr.isOneD: false
			int maxDimZeroTskySpectrum = 0;
			for (int i=0; i< min((int)row->getTskySpectrum().size(),tskySpectrumDim[3]) ;i++) {
				maxDimZeroTskySpectrum = max((int)row->getTskySpectrum()[i].size(),maxDimZeroTskySpectrum);
				for (int j=0; j<min((int)row->getTskySpectrum()[i].size(),tskySpectrumDim[1]) ;j++) {
					tskySpectrum[i*tskySpectrumDim[1]+j] = row->getTskySpectrum()[i][j].get();
				}
			}
			tskySpectrumDim[0] = maxDimZeroTskySpectrum;
			tskySpectrumDim[2] = row->getTskySpectrum().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter tsysFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTsysFlag  sdm_addsyscaltsysflag_
extern "C" int sdm_addSysCalTsysFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tsysFlag);

int sdm_addSysCalTsysFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tsysFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTsysFlag(bool(* tsysFlag ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tsysFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTsysFlag  sdm_getsyscaltsysflag_
extern "C" int sdm_getSysCalTsysFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tsysFlag);

int sdm_getSysCalTsysFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tsysFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTsysFlagExists()) {
			*tsysFlag = row->getTsysFlag();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter tsysSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTsysSpectrum  sdm_addsyscaltsysspectrum_
extern "C" int sdm_addSysCalTsysSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tsysSpectrum, int * tsysSpectrumDim);

int sdm_addSysCalTsysSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tsysSpectrum, int * tsysSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par tsysSpectrum:
		vector<vector<Temperature > >  tsysSpectrumVec(tsysSpectrumDim[2]);
		for (int i=0;i<tsysSpectrumDim[2];i++) {
			tsysSpectrumVec[i].resize(tsysSpectrumDim[0]);
			for (int j=0;j<tsysSpectrumDim[0];j++)
				tsysSpectrumVec[i][j]= Temperature(tsysSpectrum[i*(tsysSpectrumDim[1])+j]);
		}
		row->setTsysSpectrum(tsysSpectrumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tsysSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTsysSpectrum  sdm_getsyscaltsysspectrum_
extern "C" int sdm_getSysCalTsysSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tsysSpectrum, int * tsysSpectrumDim);

int sdm_getSysCalTsysSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, double * tsysSpectrum, int * tsysSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTsysSpectrumExists()) {
			// attr.CppType: vector<vector<Temperature > > attr.isOneD: false
			int maxDimZeroTsysSpectrum = 0;
			for (int i=0; i< min((int)row->getTsysSpectrum().size(),tsysSpectrumDim[3]) ;i++) {
				maxDimZeroTsysSpectrum = max((int)row->getTsysSpectrum()[i].size(),maxDimZeroTsysSpectrum);
				for (int j=0; j<min((int)row->getTsysSpectrum()[i].size(),tsysSpectrumDim[1]) ;j++) {
					tsysSpectrum[i*tsysSpectrumDim[1]+j] = row->getTsysSpectrum()[i][j].get();
				}
			}
			tsysSpectrumDim[0] = maxDimZeroTsysSpectrum;
			tsysSpectrumDim[2] = row->getTsysSpectrum().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter tantFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTantFlag  sdm_addsyscaltantflag_
extern "C" int sdm_addSysCalTantFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tantFlag);

int sdm_addSysCalTantFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tantFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTantFlag(bool(* tantFlag ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tantFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTantFlag  sdm_getsyscaltantflag_
extern "C" int sdm_getSysCalTantFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tantFlag);

int sdm_getSysCalTantFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tantFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTantFlagExists()) {
			*tantFlag = row->getTantFlag();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter tantSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTantSpectrum  sdm_addsyscaltantspectrum_
extern "C" int sdm_addSysCalTantSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * tantSpectrum, int * tantSpectrumDim);

int sdm_addSysCalTantSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * tantSpectrum, int * tantSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par tantSpectrum:
		vector<vector<float > >  tantSpectrumVec(tantSpectrumDim[2]);
		for (int i=0;i<tantSpectrumDim[2];i++) {
			tantSpectrumVec[i].resize(tantSpectrumDim[0]);
			for (int j=0;j<tantSpectrumDim[0];j++)
				tantSpectrumVec[i][j]= float(tantSpectrum[i*(tantSpectrumDim[1])+j]);
		}
		row->setTantSpectrum(tantSpectrumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tantSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTantSpectrum  sdm_getsyscaltantspectrum_
extern "C" int sdm_getSysCalTantSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * tantSpectrum, int * tantSpectrumDim);

int sdm_getSysCalTantSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * tantSpectrum, int * tantSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTantSpectrumExists()) {
			// attr.CppType: vector<vector<float > > attr.isOneD: false
			int maxDimZeroTantSpectrum = 0;
			for (int i=0;i<min((int)row->getTantSpectrum().size(),tantSpectrumDim[3]) ;i++) {
				maxDimZeroTantSpectrum = max((int)row->getTantSpectrum()[i].size(),maxDimZeroTantSpectrum);
				for (int j=0;j<min((int)row->getTantSpectrum()[i].size(),tantSpectrumDim[1]) ;j++) {
					tantSpectrum[i*tantSpectrumDim[1]+j]= row->getTantSpectrum()[i][j];
				}
			}
			tantSpectrumDim[0] = maxDimZeroTantSpectrum;
			tantSpectrumDim[2] = row->getTantSpectrum().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter tantTsysFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTantTsysFlag  sdm_addsyscaltanttsysflag_
extern "C" int sdm_addSysCalTantTsysFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tantTsysFlag);

int sdm_addSysCalTantTsysFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tantTsysFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTantTsysFlag(bool(* tantTsysFlag ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tantTsysFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTantTsysFlag  sdm_getsyscaltanttsysflag_
extern "C" int sdm_getSysCalTantTsysFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tantTsysFlag);

int sdm_getSysCalTantTsysFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * tantTsysFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTantTsysFlagExists()) {
			*tantTsysFlag = row->getTantTsysFlag();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter tantTsysSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalTantTsysSpectrum  sdm_addsyscaltanttsysspectrum_
extern "C" int sdm_addSysCalTantTsysSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * tantTsysSpectrum, int * tantTsysSpectrumDim);

int sdm_addSysCalTantTsysSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * tantTsysSpectrum, int * tantTsysSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par tantTsysSpectrum:
		vector<vector<float > >  tantTsysSpectrumVec(tantTsysSpectrumDim[2]);
		for (int i=0;i<tantTsysSpectrumDim[2];i++) {
			tantTsysSpectrumVec[i].resize(tantTsysSpectrumDim[0]);
			for (int j=0;j<tantTsysSpectrumDim[0];j++)
				tantTsysSpectrumVec[i][j]= float(tantTsysSpectrum[i*(tantTsysSpectrumDim[1])+j]);
		}
		row->setTantTsysSpectrum(tantTsysSpectrumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter tantTsysSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalTantTsysSpectrum  sdm_getsyscaltanttsysspectrum_
extern "C" int sdm_getSysCalTantTsysSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * tantTsysSpectrum, int * tantTsysSpectrumDim);

int sdm_getSysCalTantTsysSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * tantTsysSpectrum, int * tantTsysSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTantTsysSpectrumExists()) {
			// attr.CppType: vector<vector<float > > attr.isOneD: false
			int maxDimZeroTantTsysSpectrum = 0;
			for (int i=0;i<min((int)row->getTantTsysSpectrum().size(),tantTsysSpectrumDim[3]) ;i++) {
				maxDimZeroTantTsysSpectrum = max((int)row->getTantTsysSpectrum()[i].size(),maxDimZeroTantTsysSpectrum);
				for (int j=0;j<min((int)row->getTantTsysSpectrum()[i].size(),tantTsysSpectrumDim[1]) ;j++) {
					tantTsysSpectrum[i*tantTsysSpectrumDim[1]+j]= row->getTantTsysSpectrum()[i][j];
				}
			}
			tantTsysSpectrumDim[0] = maxDimZeroTantTsysSpectrum;
			tantTsysSpectrumDim[2] = row->getTantTsysSpectrum().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter phaseDiffFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalPhaseDiffFlag  sdm_addsyscalphasediffflag_
extern "C" int sdm_addSysCalPhaseDiffFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * phaseDiffFlag);

int sdm_addSysCalPhaseDiffFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * phaseDiffFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setPhaseDiffFlag(bool(* phaseDiffFlag ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter phaseDiffFlag, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalPhaseDiffFlag  sdm_getsyscalphasediffflag_
extern "C" int sdm_getSysCalPhaseDiffFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * phaseDiffFlag);

int sdm_getSysCalPhaseDiffFlag(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, bool * phaseDiffFlag) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPhaseDiffFlagExists()) {
			*phaseDiffFlag = row->getPhaseDiffFlag();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter phaseDiffSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_addSysCalPhaseDiffSpectrum  sdm_addsyscalphasediffspectrum_
extern "C" int sdm_addSysCalPhaseDiffSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * phaseDiffSpectrum, int * phaseDiffSpectrumDim);

int sdm_addSysCalPhaseDiffSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * phaseDiffSpectrum, int * phaseDiffSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysCalTable &table = dataset->getSysCal();
	
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		//... 2 dimensions optional par phaseDiffSpectrum:
		vector<vector<float > >  phaseDiffSpectrumVec(phaseDiffSpectrumDim[2]);
		for (int i=0;i<phaseDiffSpectrumDim[2];i++) {
			phaseDiffSpectrumVec[i].resize(phaseDiffSpectrumDim[0]);
			for (int j=0;j<phaseDiffSpectrumDim[0];j++)
				phaseDiffSpectrumVec[i][j]= float(phaseDiffSpectrum[i*(phaseDiffSpectrumDim[1])+j]);
		}
		row->setPhaseDiffSpectrum(phaseDiffSpectrumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter phaseDiffSpectrum, in a row of the SysCal table, given a key
 *
 */

#define sdm_getSysCalPhaseDiffSpectrum  sdm_getsyscalphasediffspectrum_
extern "C" int sdm_getSysCalPhaseDiffSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * phaseDiffSpectrum, int * phaseDiffSpectrumDim);

int sdm_getSysCalPhaseDiffSpectrum(int * antennaId, int * spectralWindowId, int64_t * timeInterval, int * feedId, float * phaseDiffSpectrum, int * phaseDiffSpectrumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysCalTable &table = dataset->getSysCal();
	SysCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *feedId);
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *feedId);
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPhaseDiffSpectrumExists()) {
			// attr.CppType: vector<vector<float > > attr.isOneD: false
			int maxDimZeroPhaseDiffSpectrum = 0;
			for (int i=0;i<min((int)row->getPhaseDiffSpectrum().size(),phaseDiffSpectrumDim[3]) ;i++) {
				maxDimZeroPhaseDiffSpectrum = max((int)row->getPhaseDiffSpectrum()[i].size(),maxDimZeroPhaseDiffSpectrum);
				for (int j=0;j<min((int)row->getPhaseDiffSpectrum()[i].size(),phaseDiffSpectrumDim[1]) ;j++) {
					phaseDiffSpectrum[i*phaseDiffSpectrumDim[1]+j]= row->getPhaseDiffSpectrum()[i][j];
				}
			}
			phaseDiffSpectrumDim[0] = maxDimZeroPhaseDiffSpectrum;
			phaseDiffSpectrumDim[2] = row->getPhaseDiffSpectrum().size();  // return dimension of the ASDM table

		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}




// =================== SysPowerTable ============================

extern "C" int sdm_addSysPowerRow (int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, int * numReceptor);
extern "C" int sdm_getSysPowerRow (int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, int * numReceptor);


extern "C" int sdm_getSysPowerTableSize ();

extern "C" int sdm_getSysPowerKeys (int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addSysPowerRow (int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, int * numReceptor){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	SysPowerTable &table = dataset->getSysPower();
	SysPowerRow *row = 0;

	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *numReceptor);
	} else {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval), *numReceptor);
	}

	// Add row
	SysPowerRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the SysPowerTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a SysPowerRow* given a key.
 */
int sdm_getSysPowerRow (int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, int * numReceptor) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysPowerTable &table = dataset->getSysPower();
	SysPowerRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		//  attr.NameS:  feedId  attr.UpperCaseName: FeedId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  numReceptor  attr.UpperCaseName: NumReceptor
		*numReceptor = row->getNumReceptor();
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getSysPowerTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
SysPowerTable &table = dataset->getSysPower();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getSysPowerKeys(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	SysPowerTable &table = dataset->getSysPower();
	
	vector< SysPowerRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		// spectralWindowId[i] = atoi((row[i]->getSpectralWindowId().getId()).c_str());
				spectralWindowId[i] = row[i]->getSpectralWindowId().getTagValue();
	  		feedId[i] = row[i]->getFeedId();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter switchedPowerDifference, in a row of the SysPower table, given a key
 *
 */

#define sdm_addSysPowerSwitchedPowerDifference  sdm_addsyspowerswitchedpowerdifference_
extern "C" int sdm_addSysPowerSwitchedPowerDifference(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * switchedPowerDifference, int * switchedPowerDifferenceDim);

int sdm_addSysPowerSwitchedPowerDifference(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * switchedPowerDifference, int * switchedPowerDifferenceDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysPowerTable &table = dataset->getSysPower();
	
	SysPowerRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<float >  switchedPowerDifferenceVec(switchedPowerDifferenceDim[0]);
		for (int i=0;i<switchedPowerDifferenceDim[0];i++)
			switchedPowerDifferenceVec[i]= float(switchedPowerDifference[i] );
		row->setSwitchedPowerDifference(switchedPowerDifferenceVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter switchedPowerDifference, in a row of the SysPower table, given a key
 *
 */

#define sdm_getSysPowerSwitchedPowerDifference  sdm_getsyspowerswitchedpowerdifference_
extern "C" int sdm_getSysPowerSwitchedPowerDifference(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * switchedPowerDifference, int * switchedPowerDifferenceDim);

int sdm_getSysPowerSwitchedPowerDifference(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * switchedPowerDifference, int * switchedPowerDifferenceDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysPowerTable &table = dataset->getSysPower();
	SysPowerRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSwitchedPowerDifferenceExists()) {
			// attr.CppType: vector<float > attr.isOneD: true
			for (int i=0; i<min((int)row->getSwitchedPowerDifference().size(),switchedPowerDifferenceDim[1]); i++)
				switchedPowerDifference[i] = row->getSwitchedPowerDifference()[i];
			switchedPowerDifferenceDim[0] = (int)row->getSwitchedPowerDifference().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter switchedPowerSum, in a row of the SysPower table, given a key
 *
 */

#define sdm_addSysPowerSwitchedPowerSum  sdm_addsyspowerswitchedpowersum_
extern "C" int sdm_addSysPowerSwitchedPowerSum(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * switchedPowerSum, int * switchedPowerSumDim);

int sdm_addSysPowerSwitchedPowerSum(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * switchedPowerSum, int * switchedPowerSumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysPowerTable &table = dataset->getSysPower();
	
	SysPowerRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<float >  switchedPowerSumVec(switchedPowerSumDim[0]);
		for (int i=0;i<switchedPowerSumDim[0];i++)
			switchedPowerSumVec[i]= float(switchedPowerSum[i] );
		row->setSwitchedPowerSum(switchedPowerSumVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter switchedPowerSum, in a row of the SysPower table, given a key
 *
 */

#define sdm_getSysPowerSwitchedPowerSum  sdm_getsyspowerswitchedpowersum_
extern "C" int sdm_getSysPowerSwitchedPowerSum(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * switchedPowerSum, int * switchedPowerSumDim);

int sdm_getSysPowerSwitchedPowerSum(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * switchedPowerSum, int * switchedPowerSumDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysPowerTable &table = dataset->getSysPower();
	SysPowerRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSwitchedPowerSumExists()) {
			// attr.CppType: vector<float > attr.isOneD: true
			for (int i=0; i<min((int)row->getSwitchedPowerSum().size(),switchedPowerSumDim[1]); i++)
				switchedPowerSum[i] = row->getSwitchedPowerSum()[i];
			switchedPowerSumDim[0] = (int)row->getSwitchedPowerSum().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter requantizerGain, in a row of the SysPower table, given a key
 *
 */

#define sdm_addSysPowerRequantizerGain  sdm_addsyspowerrequantizergain_
extern "C" int sdm_addSysPowerRequantizerGain(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * requantizerGain, int * requantizerGainDim);

int sdm_addSysPowerRequantizerGain(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * requantizerGain, int * requantizerGainDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	SysPowerTable &table = dataset->getSysPower();
	
	SysPowerRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<float >  requantizerGainVec(requantizerGainDim[0]);
		for (int i=0;i<requantizerGainDim[0];i++)
			requantizerGainVec[i]= float(requantizerGain[i] );
		row->setRequantizerGain(requantizerGainVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter requantizerGain, in a row of the SysPower table, given a key
 *
 */

#define sdm_getSysPowerRequantizerGain  sdm_getsyspowerrequantizergain_
extern "C" int sdm_getSysPowerRequantizerGain(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * requantizerGain, int * requantizerGainDim);

int sdm_getSysPowerRequantizerGain(int * antennaId, int * spectralWindowId, int * feedId, int64_t * timeInterval, float * requantizerGain, int * requantizerGainDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	SysPowerTable &table = dataset->getSysPower();
	SysPowerRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), *feedId, ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isRequantizerGainExists()) {
			// attr.CppType: vector<float > attr.isOneD: true
			for (int i=0; i<min((int)row->getRequantizerGain().size(),requantizerGainDim[1]); i++)
				requantizerGain[i] = row->getRequantizerGain()[i];
			requantizerGainDim[0] = (int)row->getRequantizerGain().size();  // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}




// =================== TotalPowerTable ============================

extern "C" int sdm_addTotalPowerRow (int64_t * time, int * configDescriptionId, int * fieldId, int * scanNumber, int * subscanNumber, int * integrationNumber, double * uvw, int * uvwDim, int64_t * exposure, int * exposureDim, int64_t * timeCentroid, int * timeCentroidDim, float * floatData, int * floatDataDim, int * flagAnt, int * flagAntDim, int * flagPol, int * flagPolDim, int64_t * interval, int * stateId, int * stateIdDim, int * execBlockId);
extern "C" int sdm_getTotalPowerRow (int64_t * time, int * configDescriptionId, int * fieldId, int * scanNumber, int * subscanNumber, int * integrationNumber, double * uvw, int * uvwDim, int64_t * exposure, int * exposureDim, int64_t * timeCentroid, int * timeCentroidDim, float * floatData, int * floatDataDim, int * flagAnt, int * flagAntDim, int * flagPol, int * flagPolDim, int64_t * interval, int * stateId, int * stateIdDim, int * execBlockId);


extern "C" int sdm_getTotalPowerTableSize ();

extern "C" int sdm_getTotalPowerKeys (int64_t * time, int * configDescriptionId, int * fieldId);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addTotalPowerRow (int64_t * time, int * configDescriptionId, int * fieldId, int * scanNumber, int * subscanNumber, int * integrationNumber, double * uvw, int * uvwDim, int64_t * exposure, int * exposureDim, int64_t * timeCentroid, int * timeCentroidDim, float * floatData, int * floatDataDim, int * flagAnt, int * flagAntDim, int * flagPol, int * flagPolDim, int64_t * interval, int * stateId, int * stateIdDim, int * execBlockId){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	TotalPowerTable &table = dataset->getTotalPower();
	TotalPowerRow *row = 0;

	// uvw is an Array
	// uvw is 2 D
	vector<vector<Length > >  uvwVec(uvwDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<uvwDim[2];i++) {
		uvwVec[i].resize(uvwDim[0]);
		for (int j=0;j<uvwDim[0];j++)
			uvwVec[i][j]= Length(uvw[i*uvwDim[1]+j]  );
	
	
	}
	// exposure is an Array
	// exposure is 2 D
	vector<vector<Interval > >  exposureVec(exposureDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<exposureDim[2];i++) {
		exposureVec[i].resize(exposureDim[0]);
		for (int j=0;j<exposureDim[0];j++)
			exposureVec[i][j]= Interval(exposure[i*exposureDim[1]+j]  );
	
	
	}
	// timeCentroid is an Array
	// timeCentroid is 2 D
	vector<vector<ArrayTime > >  timeCentroidVec(timeCentroidDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<timeCentroidDim[2];i++) {
		timeCentroidVec[i].resize(timeCentroidDim[0]);
		for (int j=0;j<timeCentroidDim[0];j++)
			timeCentroidVec[i][j]= ArrayTime(timeCentroid[i*timeCentroidDim[1]+j]  );
	
	
	}
	// floatData is an Array
	// floatData is 3 D
	vector<vector<vector<float > > >  floatDataVec(floatDataDim[4]);   // Inversion of dim in fortran/C
	for (int i=0;i<floatDataDim[4];i++) {
		floatDataVec[i].resize(floatDataDim[2]);
		for (int j=0;j<floatDataDim[2];j++) {
			floatDataVec[i][j].resize(floatDataDim[0]);
			for (int k=0;k<floatDataDim[0];k++)
		    floatDataVec[i][j][k]= float(floatData[(i*floatDataDim[3]+j)*floatDataDim[1]+k] );
		}
	}
	// flagAnt is an Array
	// flagAnt is OneD
	vector<int >  flagAntVec(flagAntDim[0]);
	for (int i=0;i<flagAntDim[0];i++)
		flagAntVec[i]= int(flagAnt[i]   );
	// flagPol is an Array
	// flagPol is 2 D
	vector<vector<int > >  flagPolVec(flagPolDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<flagPolDim[2];i++) {
		flagPolVec[i].resize(flagPolDim[0]);
		for (int j=0;j<flagPolDim[0];j++)
			flagPolVec[i][j]= int(flagPol[i*flagPolDim[1]+j]  );
	
	
	}
	// stateId is an Array
	// stateId is OneD
	vector<Tag>   stateIdVec(stateIdDim[0]);
	for (int i=0;i<stateIdDim[0];i++)
		stateIdVec[i]= Tag(stateId[i]   , TagType::State);
	
	// Create new row
  
	row = table.newRow(ArrayTime(*time), Tag(*configDescriptionId,TagType::ConfigDescription), Tag(*fieldId,TagType::Field), *scanNumber, *subscanNumber, *integrationNumber, uvwVec, exposureVec, timeCentroidVec, floatDataVec, flagAntVec, flagPolVec, Interval(*interval), stateIdVec, Tag(*execBlockId,TagType::ExecBlock));

	// Add row
	TotalPowerRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the TotalPowerTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a TotalPowerRow* given a key.
 */
int sdm_getTotalPowerRow (int64_t * time, int * configDescriptionId, int * fieldId, int * scanNumber, int * subscanNumber, int * integrationNumber, double * uvw, int * uvwDim, int64_t * exposure, int * exposureDim, int64_t * timeCentroid, int * timeCentroidDim, float * floatData, int * floatDataDim, int * flagAnt, int * flagAntDim, int * flagPol, int * flagPolDim, int64_t * interval, int * stateId, int * stateIdDim, int * execBlockId) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	TotalPowerRow *row = 0;
	row = table.getRowByKey( ArrayTime(*time), Tag(*configDescriptionId, TagType::ConfigDescription), Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  time  attr.UpperCaseName: Time
		//  attr.NameS:  configDescriptionId  attr.UpperCaseName: ConfigDescriptionId
		//  attr.NameS:  fieldId  attr.UpperCaseName: FieldId
		//  attr.NameS:  scanNumber  attr.UpperCaseName: ScanNumber
		*scanNumber = row->getScanNumber();
		//  attr.NameS:  subscanNumber  attr.UpperCaseName: SubscanNumber
		*subscanNumber = row->getSubscanNumber();
		//  attr.NameS:  integrationNumber  attr.UpperCaseName: IntegrationNumber
		*integrationNumber = row->getIntegrationNumber();
		//  attr.NameS:  uvw  attr.UpperCaseName: Uvw
		
		vector<vector<Length > >  uvwVec = row->getUvw();
		
		int maxDimZeroUvw = 0;
		for (int i=0; i< min((int)uvwVec.size(),uvwDim[3]) ;i++) {
			maxDimZeroUvw = max((int)uvwVec[i].size(),maxDimZeroUvw);
			for (int j=0; j<min((int)uvwVec[i].size(),uvwDim[1]) ;j++) {
				uvw[i*uvwDim[1]+j] = uvwVec[i][j].get();
			}
		}
		uvwDim[0] = maxDimZeroUvw;
		uvwDim[2] = uvwVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  exposure  attr.UpperCaseName: Exposure
		
		vector<vector<Interval > >  exposureVec = row->getExposure();
		
		int maxDimZeroExposure = 0;
		for (int i=0; i< min((int)exposureVec.size(),exposureDim[3]) ;i++) {
			maxDimZeroExposure = max((int)exposureVec[i].size(),maxDimZeroExposure);
			for (int j=0; j<min((int)exposureVec[i].size(),exposureDim[1]) ;j++) {
				exposure[i*exposureDim[1]+j] = exposureVec[i][j].get();
			}
		}
		exposureDim[0] = maxDimZeroExposure;
		exposureDim[2] = exposureVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  timeCentroid  attr.UpperCaseName: TimeCentroid
		
		vector<vector<ArrayTime > >  timeCentroidVec = row->getTimeCentroid();
		
		int maxDimZeroTimeCentroid = 0;
		for (int i=0; i< min((int)timeCentroidVec.size(),timeCentroidDim[3]) ;i++) {
			maxDimZeroTimeCentroid = max((int)timeCentroidVec[i].size(),maxDimZeroTimeCentroid);
			for (int j=0; j<min((int)timeCentroidVec[i].size(),timeCentroidDim[1]) ;j++) {
				timeCentroid[i*timeCentroidDim[1]+j] = timeCentroidVec[i][j].get();
			}
		}
		timeCentroidDim[0] = maxDimZeroTimeCentroid;
		timeCentroidDim[2] = timeCentroidVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  floatData  attr.UpperCaseName: FloatData
		
		vector<vector<vector<float > > >  floatDataVec = row->getFloatData();
		int maxDimTwoFloatData = 0;
		int maxDimZeroFloatData = 0;
		for (int i=0; i<  min((int)floatDataVec.size(),floatDataDim[5]) ;i++) {
			maxDimTwoFloatData = max((int)floatDataVec[i].size(),maxDimTwoFloatData);
			for (int j=0;j< min((int)floatDataVec[i].size(),floatDataDim[3]) ;j++) {
				maxDimZeroFloatData = max((int)floatDataVec[i][j].size(),maxDimZeroFloatData);
				for (int k=0; k< min((int)floatDataVec[i][j].size(),floatDataDim[1]) ;k++) {
floatData[(i*floatDataDim[3]+j)*floatDataDim[1]+k]= floatDataVec[i][j][k];
				}
			}
		}
		floatDataDim[0] = maxDimZeroFloatData;
		floatDataDim[2] = maxDimTwoFloatData;
		floatDataDim[4] = floatDataVec.size();  // return dimension of the ASDM table
		//  attr.NameS:  flagAnt  attr.UpperCaseName: FlagAnt
		
		vector<int >  flagAntVec = row->getFlagAnt();
		
		for (int i=0; i<min((int)flagAntVec.size(),flagAntDim[1]); i++)
			flagAnt[i] = flagAntVec[i];
		flagAntDim[0] = (int)flagAntVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  flagPol  attr.UpperCaseName: FlagPol
		
		vector<vector<int > >  flagPolVec = row->getFlagPol();
		
		int maxDimZeroFlagPol = 0;
		for (int i=0;i<min((int)flagPolVec.size(),flagPolDim[3]) ;i++) {
			maxDimZeroFlagPol = max((int)flagPolVec[i].size(),maxDimZeroFlagPol);
			for (int j=0;j<min((int)flagPolVec[i].size(),flagPolDim[1]) ;j++) {
				flagPol[i*flagPolDim[1]+j]= flagPolVec[i][j];
			}
		}
		flagPolDim[0] = maxDimZeroFlagPol;
		flagPolDim[2] = flagPolVec.size();  // return dimension of the ASDM
		
		
		//  attr.NameS:  interval  attr.UpperCaseName: Interval
		*interval = row->getInterval().get();
		//  attr.NameS:  stateId  attr.UpperCaseName: StateId
		
		vector<Tag>   stateIdVec = row->getStateId();
		
		for (int i=0; i<min((int)stateIdVec.size(),stateIdDim[1]); i++)
			//stateId[i] = atoi((row->getStateId()[i]).getId().c_str());
		stateId[i] = stateIdVec[i].getTagValue();
		stateIdDim[0] = (int)stateIdVec.size();  // return dimension of the ASDM table
		
		
		//  attr.NameS:  execBlockId  attr.UpperCaseName: ExecBlockId
		// *execBlockId = atoi((row->getExecBlockId().getId()).c_str());
		*execBlockId = row->getExecBlockId().getTagValue();
		
		return 1;   // 1 means that the line has been found
	}	
}


// -------------------------------------------
// Columns get methods
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column Time of Table TotalPower.
 */
#define sdm_getTotalPowerTimeColumn  sdm_gettotalpowertimecolumn_
extern "C" int sdm_getTotalPowerTimeColumn(int64_t * time);
int sdm_getTotalPowerTimeColumn (int64_t * time) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  time  Column: Time
			// Scalar column of ArrayTime
			time[ir]     = row[ir]->getTime().get();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column ConfigDescriptionId of Table TotalPower.
 */
#define sdm_getTotalPowerConfigDescriptionIdColumn  sdm_gettotalpowerconfigdescriptionidcolumn_
extern "C" int sdm_getTotalPowerConfigDescriptionIdColumn(int * configDescriptionId);
int sdm_getTotalPowerConfigDescriptionIdColumn (int * configDescriptionId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  configDescriptionId  Column: ConfigDescriptionId
			// Scalar column of Tag
			configDescriptionId[ir] = row[ir]->getConfigDescriptionId().getTagValue();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column FieldId of Table TotalPower.
 */
#define sdm_getTotalPowerFieldIdColumn  sdm_gettotalpowerfieldidcolumn_
extern "C" int sdm_getTotalPowerFieldIdColumn(int * fieldId);
int sdm_getTotalPowerFieldIdColumn (int * fieldId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  fieldId  Column: FieldId
			// Scalar column of Tag
			fieldId[ir] = row[ir]->getFieldId().getTagValue();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column ScanNumber of Table TotalPower.
 */
#define sdm_getTotalPowerScanNumberColumn  sdm_gettotalpowerscannumbercolumn_
extern "C" int sdm_getTotalPowerScanNumberColumn(int * scanNumber);
int sdm_getTotalPowerScanNumberColumn (int * scanNumber) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  scanNumber  Column: ScanNumber
			// Scalar column of int
			scanNumber[ir] = row[ir]->getScanNumber();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column SubscanNumber of Table TotalPower.
 */
#define sdm_getTotalPowerSubscanNumberColumn  sdm_gettotalpowersubscannumbercolumn_
extern "C" int sdm_getTotalPowerSubscanNumberColumn(int * subscanNumber);
int sdm_getTotalPowerSubscanNumberColumn (int * subscanNumber) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  subscanNumber  Column: SubscanNumber
			// Scalar column of int
			subscanNumber[ir] = row[ir]->getSubscanNumber();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column IntegrationNumber of Table TotalPower.
 */
#define sdm_getTotalPowerIntegrationNumberColumn  sdm_gettotalpowerintegrationnumbercolumn_
extern "C" int sdm_getTotalPowerIntegrationNumberColumn(int * integrationNumber);
int sdm_getTotalPowerIntegrationNumberColumn (int * integrationNumber) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  integrationNumber  Column: IntegrationNumber
			// Scalar column of int
			integrationNumber[ir] = row[ir]->getIntegrationNumber();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column Uvw of Table TotalPower.
 */
#define sdm_getTotalPowerUvwColumn  sdm_gettotalpoweruvwcolumn_
extern "C" int sdm_getTotalPowerUvwColumn(double * uvw, int * uvwDim);
int sdm_getTotalPowerUvwColumn (double * uvw, int * uvwDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  uvw  Column: Uvw
			vector<vector<Length > >  uvwVec = row[ir]->getUvw();
			// TwoD column of Length
			int maxDimZeroUvw = 0;
			for (int i=0; i<min((int)uvwVec.size(),uvwDim[3]); i++) {
				maxDimZeroUvw = max((int)uvwVec[i].size(),maxDimZeroUvw);
				for (int j=0; j<min((int)uvwVec[i].size(), uvwDim[1]) ;j++) {
					uvw[(ir*uvwDim[3]+i)*uvwDim[1]+j]= uvwVec[i][j].get();;
				}
			}
	  			uvwDim[ir*4] = maxDimZeroUvw; // return the maximum of inner dimension
         		uvwDim[ir*4+2] = uvwVec.size();  // return the outer dimension
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column Exposure of Table TotalPower.
 */
#define sdm_getTotalPowerExposureColumn  sdm_gettotalpowerexposurecolumn_
extern "C" int sdm_getTotalPowerExposureColumn(int64_t * exposure, int * exposureDim);
int sdm_getTotalPowerExposureColumn (int64_t * exposure, int * exposureDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  exposure  Column: Exposure
			vector<vector<Interval > >  exposureVec = row[ir]->getExposure();
			// TwoD column of Interval
			int maxDimZeroExposure = 0;
			for (int i=0; i<min((int)exposureVec.size(),exposureDim[3]); i++) {
				maxDimZeroExposure = max((int)exposureVec[i].size(),maxDimZeroExposure);
				for (int j=0; j<min((int)exposureVec[i].size(), exposureDim[1]) ;j++) {
					exposure[(ir*exposureDim[3]+i)*exposureDim[1]+j]= exposureVec[i][j].get();;
				}
			}
	  			exposureDim[ir*4] = maxDimZeroExposure; // return the maximum of inner dimension
         		exposureDim[ir*4+2] = exposureVec.size();  // return the outer dimension
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column TimeCentroid of Table TotalPower.
 */
#define sdm_getTotalPowerTimeCentroidColumn  sdm_gettotalpowertimecentroidcolumn_
extern "C" int sdm_getTotalPowerTimeCentroidColumn(int64_t * timeCentroid, int * timeCentroidDim);
int sdm_getTotalPowerTimeCentroidColumn (int64_t * timeCentroid, int * timeCentroidDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  timeCentroid  Column: TimeCentroid
			vector<vector<ArrayTime > >  timeCentroidVec = row[ir]->getTimeCentroid();
			// TwoD column of ArrayTime
			int maxDimZeroTimeCentroid = 0;
			for (int i=0; i<min((int)timeCentroidVec.size(),timeCentroidDim[3]); i++) {
				maxDimZeroTimeCentroid = max((int)timeCentroidVec[i].size(),maxDimZeroTimeCentroid);
				for (int j=0; j<min((int)timeCentroidVec[i].size(), timeCentroidDim[1]) ;j++) {
					timeCentroid[(ir*timeCentroidDim[3]+i)*timeCentroidDim[1]+j]= timeCentroidVec[i][j].get();;
				}
			}
	  			timeCentroidDim[ir*4] = maxDimZeroTimeCentroid; // return the maximum of inner dimension
         		timeCentroidDim[ir*4+2] = timeCentroidVec.size();  // return the outer dimension
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column FloatData of Table TotalPower.
 */
#define sdm_getTotalPowerFloatDataColumn  sdm_gettotalpowerfloatdatacolumn_
extern "C" int sdm_getTotalPowerFloatDataColumn(float * floatData, int * floatDataDim);
int sdm_getTotalPowerFloatDataColumn (float * floatData, int * floatDataDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  floatData  Column: FloatData
			vector<vector<vector<float > > >  floatDataVec = row[ir]->getFloatData();
			// ThreeD column of float
			int maxDimTwoFloatData = 0;
			int maxDimZeroFloatData = 0;
			for (int i=0; i<  min((int)floatDataVec.size(),floatDataDim[5]) ;i++) {
				maxDimTwoFloatData = max((int)floatDataVec[i].size(),maxDimTwoFloatData);
				for (int j=0;j< min((int)floatDataVec[i].size(),floatDataDim[3]) ;j++) {
					maxDimZeroFloatData = max((int)floatDataVec[i][j].size(),maxDimZeroFloatData);
					for (int k=0; k< min((int)floatDataVec[i][j].size(),floatDataDim[1]) ;k++) {
						floatData[((ir*floatDataDim[5]+i)*floatDataDim[3]+j)*floatDataDim[1]+k] = floatDataVec[i][j][k];
					}
				}
			}
			floatDataDim[ir*2] = maxDimZeroFloatData;
			floatDataDim[ir*2+2] = maxDimTwoFloatData;
			floatDataDim[ir*2+4] = floatDataVec.size();  // return dimension of the ASDM table 
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column FlagAnt of Table TotalPower.
 */
#define sdm_getTotalPowerFlagAntColumn  sdm_gettotalpowerflagantcolumn_
extern "C" int sdm_getTotalPowerFlagAntColumn(int * flagAnt, int * flagAntDim);
int sdm_getTotalPowerFlagAntColumn (int * flagAnt, int * flagAntDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  flagAnt  Column: FlagAnt
			vector<int >  flagAntVec = row[ir]->getFlagAnt();
			// OneD column of int
			for (int i=0; i<min((int)flagAntVec.size(),flagAntDim[1]); i++) {
				flagAnt[ir*flagAntDim[1]+i] = flagAntVec[i];
			}
			flagAntDim[ir*2] = (int)flagAntVec.size();  // return dimension of the vector in each row
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column FlagPol of Table TotalPower.
 */
#define sdm_getTotalPowerFlagPolColumn  sdm_gettotalpowerflagpolcolumn_
extern "C" int sdm_getTotalPowerFlagPolColumn(int * flagPol, int * flagPolDim);
int sdm_getTotalPowerFlagPolColumn (int * flagPol, int * flagPolDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  flagPol  Column: FlagPol
			vector<vector<int > >  flagPolVec = row[ir]->getFlagPol();
			// TwoD column of int
			int maxDimZeroFlagPol = 0;
			for (int i=0; i<min((int)flagPolVec.size(),flagPolDim[3]); i++) {
				maxDimZeroFlagPol = max((int)flagPolVec[i].size(),maxDimZeroFlagPol);
				for (int j=0; j<min((int)flagPolVec[i].size(), flagPolDim[1]) ;j++) {
					flagPol[(ir*flagPolDim[3]+i)*flagPolDim[1]+j]= flagPolVec[i][j];
				}
			}
	  			flagPolDim[ir*4] = maxDimZeroFlagPol; // return the maximum of inner dimension
         		flagPolDim[ir*4+2] = flagPolVec.size();  // return the outer dimension
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column Interval of Table TotalPower.
 */
#define sdm_getTotalPowerIntervalColumn  sdm_gettotalpowerintervalcolumn_
extern "C" int sdm_getTotalPowerIntervalColumn(int64_t * interval);
int sdm_getTotalPowerIntervalColumn (int64_t * interval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  interval  Column: Interval
			// Scalar column of Interval
			interval[ir] = row[ir]->getInterval().get();
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column StateId of Table TotalPower.
 */
#define sdm_getTotalPowerStateIdColumn  sdm_gettotalpowerstateidcolumn_
extern "C" int sdm_getTotalPowerStateIdColumn(int * stateId, int * stateIdDim);
int sdm_getTotalPowerStateIdColumn (int * stateId, int * stateIdDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  stateId  Column: StateId
			vector<Tag>   stateIdVec = row[ir]->getStateId();
			// OneD column of Tag
			for (int i=0; i<min((int)stateIdVec.size(),stateIdDim[1]); i++) {
stateId[ir*stateIdDim[1]+i] = stateIdVec[i].getTagValue();
			}
			stateIdDim[ir*2] = (int)stateIdVec.size();  // return dimension of the vector in each row
		}
	}
	return size ;   // return the size of the table  
}
// -------------------------------------------
// NEW METHOD
/**
 * Returns the column ExecBlockId of Table TotalPower.
 */
#define sdm_getTotalPowerExecBlockIdColumn  sdm_gettotalpowerexecblockidcolumn_
extern "C" int sdm_getTotalPowerExecBlockIdColumn(int * execBlockId);
int sdm_getTotalPowerExecBlockIdColumn (int * execBlockId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	vector< TotalPowerRow * > row = table.get();
	int size = (int)table.get().size();
	if (size==0) {
		return 0;
	} else {
		for (int ir=0; ir<size; ir++) {
			// Table:  execBlockId  Column: ExecBlockId
			// Scalar column of Tag
			execBlockId[ir] = row[ir]->getExecBlockId().getTagValue();
		}
	}
	return size ;   // return the size of the table  
}


// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getTotalPowerTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
TotalPowerTable &table = dataset->getTotalPower();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getTotalPowerKeys(int64_t * time, int * configDescriptionId, int * fieldId) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	TotalPowerTable &table = dataset->getTotalPower();
	
	vector< TotalPowerRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		time[i] = row[i]->getTime().get();
	  		// configDescriptionId[i] = atoi((row[i]->getConfigDescriptionId().getId()).c_str());
				configDescriptionId[i] = row[i]->getConfigDescriptionId().getTagValue();
	  		// fieldId[i] = atoi((row[i]->getFieldId().getId()).c_str());
				fieldId[i] = row[i]->getFieldId().getTagValue();
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter subintegrationNumber, in a row of the TotalPower table, given a key
 *
 */

#define sdm_addTotalPowerSubintegrationNumber  sdm_addtotalpowersubintegrationnumber_
extern "C" int sdm_addTotalPowerSubintegrationNumber(int64_t * time, int * configDescriptionId, int * fieldId, int * subintegrationNumber);

int sdm_addTotalPowerSubintegrationNumber(int64_t * time, int * configDescriptionId, int * fieldId, int * subintegrationNumber) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	TotalPowerTable &table = dataset->getTotalPower();
	
	TotalPowerRow *row = 0;
	row = table.getRowByKey( ArrayTime(*time), Tag(*configDescriptionId, TagType::ConfigDescription), Tag(*fieldId, TagType::Field));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setSubintegrationNumber(int(* subintegrationNumber ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter subintegrationNumber, in a row of the TotalPower table, given a key
 *
 */

#define sdm_getTotalPowerSubintegrationNumber  sdm_gettotalpowersubintegrationnumber_
extern "C" int sdm_getTotalPowerSubintegrationNumber(int64_t * time, int * configDescriptionId, int * fieldId, int * subintegrationNumber);

int sdm_getTotalPowerSubintegrationNumber(int64_t * time, int * configDescriptionId, int * fieldId, int * subintegrationNumber) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	TotalPowerTable &table = dataset->getTotalPower();
	TotalPowerRow *row = 0;
	row = table.getRowByKey( ArrayTime(*time), Tag(*configDescriptionId, TagType::ConfigDescription), Tag(*fieldId, TagType::Field));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isSubintegrationNumberExists()) {
			*subintegrationNumber = row->getSubintegrationNumber();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}




// =================== WeatherTable ============================

extern "C" int sdm_addWeatherRow (int * stationId, int64_t * timeInterval);
extern "C" int sdm_getWeatherRow (int * stationId, int64_t * timeInterval);


extern "C" int sdm_getWeatherTableSize ();

extern "C" int sdm_getWeatherKeys (int * stationId, int64_t * timeInterval);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addWeatherRow (int * stationId, int64_t * timeInterval){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;

	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*stationId,TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	} else {
		row = table.newRow(Tag(*stationId,TagType::Station), ArrayTimeInterval(*timeInterval));
	}

	// Add row
	WeatherRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the WeatherTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a WeatherRow* given a key.
 */
int sdm_getWeatherRow (int * stationId, int64_t * timeInterval) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  stationId  attr.UpperCaseName: StationId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getWeatherTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
WeatherTable &table = dataset->getWeather();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getWeatherKeys(int * stationId, int64_t * timeInterval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	
	vector< WeatherRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// stationId[i] = atoi((row[i]->getStationId().getId()).c_str());
				stationId[i] = row[i]->getStationId().getTagValue();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
  		}
  		
		return size;
  	}
}




// -------------------------------------------
/**
 * Set the optional parameter pressure, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherPressure  sdm_addweatherpressure_
extern "C" int sdm_addWeatherPressure(int * stationId, int64_t * timeInterval, double * pressure);

int sdm_addWeatherPressure(int * stationId, int64_t * timeInterval, double * pressure) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setPressure(Pressure(* pressure ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter pressure, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherPressure  sdm_getweatherpressure_
extern "C" int sdm_getWeatherPressure(int * stationId, int64_t * timeInterval, double * pressure);

int sdm_getWeatherPressure(int * stationId, int64_t * timeInterval, double * pressure) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isPressureExists()) {
			*pressure = row->getPressure().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter relHumidity, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherRelHumidity  sdm_addweatherrelhumidity_
extern "C" int sdm_addWeatherRelHumidity(int * stationId, int64_t * timeInterval, double * relHumidity);

int sdm_addWeatherRelHumidity(int * stationId, int64_t * timeInterval, double * relHumidity) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setRelHumidity(Humidity(* relHumidity ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter relHumidity, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherRelHumidity  sdm_getweatherrelhumidity_
extern "C" int sdm_getWeatherRelHumidity(int * stationId, int64_t * timeInterval, double * relHumidity);

int sdm_getWeatherRelHumidity(int * stationId, int64_t * timeInterval, double * relHumidity) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isRelHumidityExists()) {
			*relHumidity = row->getRelHumidity().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter temperature, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherTemperature  sdm_addweathertemperature_
extern "C" int sdm_addWeatherTemperature(int * stationId, int64_t * timeInterval, double * temperature);

int sdm_addWeatherTemperature(int * stationId, int64_t * timeInterval, double * temperature) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setTemperature(Temperature(* temperature ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter temperature, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherTemperature  sdm_getweathertemperature_
extern "C" int sdm_getWeatherTemperature(int * stationId, int64_t * timeInterval, double * temperature);

int sdm_getWeatherTemperature(int * stationId, int64_t * timeInterval, double * temperature) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTemperatureExists()) {
			*temperature = row->getTemperature().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter windDirection, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherWindDirection  sdm_addweatherwinddirection_
extern "C" int sdm_addWeatherWindDirection(int * stationId, int64_t * timeInterval, double * windDirection);

int sdm_addWeatherWindDirection(int * stationId, int64_t * timeInterval, double * windDirection) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setWindDirection(Angle(* windDirection ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter windDirection, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherWindDirection  sdm_getweatherwinddirection_
extern "C" int sdm_getWeatherWindDirection(int * stationId, int64_t * timeInterval, double * windDirection);

int sdm_getWeatherWindDirection(int * stationId, int64_t * timeInterval, double * windDirection) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isWindDirectionExists()) {
			*windDirection = row->getWindDirection().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter windSpeed, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherWindSpeed  sdm_addweatherwindspeed_
extern "C" int sdm_addWeatherWindSpeed(int * stationId, int64_t * timeInterval, double * windSpeed);

int sdm_addWeatherWindSpeed(int * stationId, int64_t * timeInterval, double * windSpeed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setWindSpeed(Speed(* windSpeed ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter windSpeed, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherWindSpeed  sdm_getweatherwindspeed_
extern "C" int sdm_getWeatherWindSpeed(int * stationId, int64_t * timeInterval, double * windSpeed);

int sdm_getWeatherWindSpeed(int * stationId, int64_t * timeInterval, double * windSpeed) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isWindSpeedExists()) {
			*windSpeed = row->getWindSpeed().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter windMax, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherWindMax  sdm_addweatherwindmax_
extern "C" int sdm_addWeatherWindMax(int * stationId, int64_t * timeInterval, double * windMax);

int sdm_addWeatherWindMax(int * stationId, int64_t * timeInterval, double * windMax) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setWindMax(Speed(* windMax ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter windMax, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherWindMax  sdm_getweatherwindmax_
extern "C" int sdm_getWeatherWindMax(int * stationId, int64_t * timeInterval, double * windMax);

int sdm_getWeatherWindMax(int * stationId, int64_t * timeInterval, double * windMax) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isWindMaxExists()) {
			*windMax = row->getWindMax().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter dewPoint, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherDewPoint  sdm_addweatherdewpoint_
extern "C" int sdm_addWeatherDewPoint(int * stationId, int64_t * timeInterval, double * dewPoint);

int sdm_addWeatherDewPoint(int * stationId, int64_t * timeInterval, double * dewPoint) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setDewPoint(Temperature(* dewPoint ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter dewPoint, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherDewPoint  sdm_getweatherdewpoint_
extern "C" int sdm_getWeatherDewPoint(int * stationId, int64_t * timeInterval, double * dewPoint);

int sdm_getWeatherDewPoint(int * stationId, int64_t * timeInterval, double * dewPoint) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isDewPointExists()) {
			*dewPoint = row->getDewPoint().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numLayer, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherNumLayer  sdm_addweathernumlayer_
extern "C" int sdm_addWeatherNumLayer(int * stationId, int64_t * timeInterval, int * numLayer);

int sdm_addWeatherNumLayer(int * stationId, int64_t * timeInterval, int * numLayer) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumLayer(int(* numLayer ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numLayer, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherNumLayer  sdm_getweathernumlayer_
extern "C" int sdm_getWeatherNumLayer(int * stationId, int64_t * timeInterval, int * numLayer);

int sdm_getWeatherNumLayer(int * stationId, int64_t * timeInterval, int * numLayer) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumLayerExists()) {
			*numLayer = row->getNumLayer();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter layerHeight, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherLayerHeight  sdm_addweatherlayerheight_
extern "C" int sdm_addWeatherLayerHeight(int * stationId, int64_t * timeInterval, double * layerHeight, int * layerHeightDim);

int sdm_addWeatherLayerHeight(int * stationId, int64_t * timeInterval, double * layerHeight, int * layerHeightDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Length >  layerHeightVec(layerHeightDim[0]);
		for (int i=0;i<layerHeightDim[0];i++)
			layerHeightVec[i]= Length(layerHeight[i] );
		row->setLayerHeight(layerHeightVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter layerHeight, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherLayerHeight  sdm_getweatherlayerheight_
extern "C" int sdm_getWeatherLayerHeight(int * stationId, int64_t * timeInterval, double * layerHeight, int * layerHeightDim);

int sdm_getWeatherLayerHeight(int * stationId, int64_t * timeInterval, double * layerHeight, int * layerHeightDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isLayerHeightExists()) {
			// attr.CppType: vector<Length > attr.isOneD: true
			for (int i=0; i<min((int)row->getLayerHeight().size(),layerHeightDim[1]); i++)
				layerHeight[i] = row->getLayerHeight()[i].get();
			layerHeightDim[0] = row->getLayerHeight().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter temperatureProfile, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherTemperatureProfile  sdm_addweathertemperatureprofile_
extern "C" int sdm_addWeatherTemperatureProfile(int * stationId, int64_t * timeInterval, double * temperatureProfile, int * temperatureProfileDim);

int sdm_addWeatherTemperatureProfile(int * stationId, int64_t * timeInterval, double * temperatureProfile, int * temperatureProfileDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  temperatureProfileVec(temperatureProfileDim[0]);
		for (int i=0;i<temperatureProfileDim[0];i++)
			temperatureProfileVec[i]= Temperature(temperatureProfile[i] );
		row->setTemperatureProfile(temperatureProfileVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter temperatureProfile, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherTemperatureProfile  sdm_getweathertemperatureprofile_
extern "C" int sdm_getWeatherTemperatureProfile(int * stationId, int64_t * timeInterval, double * temperatureProfile, int * temperatureProfileDim);

int sdm_getWeatherTemperatureProfile(int * stationId, int64_t * timeInterval, double * temperatureProfile, int * temperatureProfileDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isTemperatureProfileExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getTemperatureProfile().size(),temperatureProfileDim[1]); i++)
				temperatureProfile[i] = row->getTemperatureProfile()[i].get();
			temperatureProfileDim[0] = row->getTemperatureProfile().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter cloudMonitor, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherCloudMonitor  sdm_addweathercloudmonitor_
extern "C" int sdm_addWeatherCloudMonitor(int * stationId, int64_t * timeInterval, double * cloudMonitor);

int sdm_addWeatherCloudMonitor(int * stationId, int64_t * timeInterval, double * cloudMonitor) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setCloudMonitor(Temperature(* cloudMonitor ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter cloudMonitor, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherCloudMonitor  sdm_getweathercloudmonitor_
extern "C" int sdm_getWeatherCloudMonitor(int * stationId, int64_t * timeInterval, double * cloudMonitor);

int sdm_getWeatherCloudMonitor(int * stationId, int64_t * timeInterval, double * cloudMonitor) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isCloudMonitorExists()) {
			*cloudMonitor = row->getCloudMonitor().get();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter numWVR, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherNumWVR  sdm_addweathernumwvr_
extern "C" int sdm_addWeatherNumWVR(int * stationId, int64_t * timeInterval, int * numWVR);

int sdm_addWeatherNumWVR(int * stationId, int64_t * timeInterval, int * numWVR) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setNumWVR(int(* numWVR ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter numWVR, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherNumWVR  sdm_getweathernumwvr_
extern "C" int sdm_getWeatherNumWVR(int * stationId, int64_t * timeInterval, int * numWVR);

int sdm_getWeatherNumWVR(int * stationId, int64_t * timeInterval, int * numWVR) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isNumWVRExists()) {
			*numWVR = row->getNumWVR();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter wvrTemp, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherWvrTemp  sdm_addweatherwvrtemp_
extern "C" int sdm_addWeatherWvrTemp(int * stationId, int64_t * timeInterval, double * wvrTemp, int * wvrTempDim);

int sdm_addWeatherWvrTemp(int * stationId, int64_t * timeInterval, double * wvrTemp, int * wvrTempDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		vector<Temperature >  wvrTempVec(wvrTempDim[0]);
		for (int i=0;i<wvrTempDim[0];i++)
			wvrTempVec[i]= Temperature(wvrTemp[i] );
		row->setWvrTemp(wvrTempVec);
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter wvrTemp, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherWvrTemp  sdm_getweatherwvrtemp_
extern "C" int sdm_getWeatherWvrTemp(int * stationId, int64_t * timeInterval, double * wvrTemp, int * wvrTempDim);

int sdm_getWeatherWvrTemp(int * stationId, int64_t * timeInterval, double * wvrTemp, int * wvrTempDim) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isWvrTempExists()) {
			// attr.CppType: vector<Temperature > attr.isOneD: true
			for (int i=0; i<min((int)row->getWvrTemp().size(),wvrTempDim[1]); i++)
				wvrTemp[i] = row->getWvrTemp()[i].get();
			wvrTempDim[0] = row->getWvrTemp().size(); // return dimension of the ASDM table
			
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}

// -------------------------------------------
/**
 * Set the optional parameter water, in a row of the Weather table, given a key
 *
 */

#define sdm_addWeatherWater  sdm_addweatherwater_
extern "C" int sdm_addWeatherWater(int * stationId, int64_t * timeInterval, double * water);

int sdm_addWeatherWater(int * stationId, int64_t * timeInterval, double * water) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WeatherTable &table = dataset->getWeather();
	
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		// case: scalar attribute.
		row->setWater(double(* water ));
		
	}
	
	return 0;
}


// -------------------------------------------
/**
 * Get the optional parameter water, in a row of the Weather table, given a key
 *
 */

#define sdm_getWeatherWater  sdm_getweatherwater_
extern "C" int sdm_getWeatherWater(int * stationId, int64_t * timeInterval, double * water);

int sdm_getWeatherWater(int * stationId, int64_t * timeInterval, double * water) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	
	WeatherTable &table = dataset->getWeather();
	WeatherRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*stationId, TagType::Station), ArrayTimeInterval(*timeInterval));
	
	if (row==0) {
		return -1;     // No row corresponding to the key
	} else {
		if (row->isWaterExists()) {
			*water = row->getWater();
		} else {
			return 1; // return 1 if optional parameter is absent, but row exists.
		}
	}
	
	return 0;
}


using namespace WVRMethodMod;


// =================== WVMCalTable ============================

extern "C" int sdm_addWVMCalRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, WVRMethod * wvrMethod, double * polyFreqLimits, int * polyFreqLimitsDim, int * numInputAntenna, int * numChan, int * numPoly, float * pathCoeff, int * pathCoeffDim, double * refTemp, int * refTempDim, int * inputAntennaId, int * inputAntennaIdDim);
extern "C" int sdm_getWVMCalRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, WVRMethod * wvrMethod, double * polyFreqLimits, int * polyFreqLimitsDim, int * numInputAntenna, int * numChan, int * numPoly, float * pathCoeff, int * pathCoeffDim, double * refTemp, int * refTempDim, int * inputAntennaId, int * inputAntennaIdDim);


extern "C" int sdm_getWVMCalTableSize ();

extern "C" int sdm_getWVMCalKeys (int * antennaId, int * spectralWindowId, int64_t * timeInterval);


/**
 * Create a new row initialized to the specified values.
 * @return a pointer on the created and initialized row.
 */

int  sdm_addWVMCalRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, WVRMethod * wvrMethod, double * polyFreqLimits, int * polyFreqLimitsDim, int * numInputAntenna, int * numChan, int * numPoly, float * pathCoeff, int * pathCoeffDim, double * refTemp, int * refTempDim, int * inputAntennaId, int * inputAntennaIdDim){


	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	   	return -1;
	}
	
	try {
	WVMCalTable &table = dataset->getWVMCal();
	WVMCalRow *row = 0;

	// wvrMethod is an enumeration
	// WVRMethod * wvrMethod =  (int) wvrMethod;
	// polyFreqLimits is an Array
	// polyFreqLimits is OneD
	vector<Frequency >  polyFreqLimitsVec(polyFreqLimitsDim[0]);
	for (int i=0;i<polyFreqLimitsDim[0];i++)
		polyFreqLimitsVec[i]= Frequency(polyFreqLimits[i]   );
	// pathCoeff is an Array
	// pathCoeff is 3 D
	vector<vector<vector<float > > >  pathCoeffVec(pathCoeffDim[4]);   // Inversion of dim in fortran/C
	for (int i=0;i<pathCoeffDim[4];i++) {
		pathCoeffVec[i].resize(pathCoeffDim[2]);
		for (int j=0;j<pathCoeffDim[2];j++) {
			pathCoeffVec[i][j].resize(pathCoeffDim[0]);
			for (int k=0;k<pathCoeffDim[0];k++)
		    pathCoeffVec[i][j][k]= float(pathCoeff[(i*pathCoeffDim[3]+j)*pathCoeffDim[1]+k] );
		}
	}
	// refTemp is an Array
	// refTemp is 2 D
	vector<vector<Temperature > >  refTempVec(refTempDim[2]);   // Inversion of dim in fortran/C
	for (int i=0;i<refTempDim[2];i++) {
		refTempVec[i].resize(refTempDim[0]);
		for (int j=0;j<refTempDim[0];j++)
			refTempVec[i][j]= Temperature(refTemp[i*refTempDim[1]+j]  );
	
	
	}
	// inputAntennaId is an Array
	// inputAntennaId is OneD
	vector<Tag>   inputAntennaIdVec(inputAntennaIdDim[0]);
	for (int i=0;i<inputAntennaIdDim[0];i++)
		inputAntennaIdVec[i]= Tag(inputAntennaId[i]   , TagType::Antenna);
	
	// Create new row
  
	if (*(timeInterval+1)>0) {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)), *wvrMethod, polyFreqLimitsVec, *numInputAntenna, *numChan, *numPoly, pathCoeffVec, refTempVec, inputAntennaIdVec);
	} else {
		row = table.newRow(Tag(*antennaId,TagType::Antenna), Tag(*spectralWindowId,TagType::SpectralWindow), ArrayTimeInterval(*timeInterval), *wvrMethod, polyFreqLimitsVec, *numInputAntenna, *numChan, *numPoly, pathCoeffVec, refTempVec, inputAntennaIdVec);
	}

	// Add row
	WVMCalRow *retRow = table.add(row);

	if (retRow != row) {
		//    cout << "Attempt to store a row identical to a row present in the WVMCalTable" << endl;
	}
	
	return 0;    // No autoIncrementable attribute
	}
  	catch (DuplicateKey e) {  // exception thrown if duplicate key and no autoIncrementable attribute
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
	catch (InvalidArgumentException e)  { // exception thrown if Invalid Argument
		cout << e.getMessage() << endl;
		return 0;   // No autoIncrementable attribute
	}
}
// -------------------------------------------


/**
 * Returns a WVMCalRow* given a key.
 */
int sdm_getWVMCalRow (int * antennaId, int * spectralWindowId, int64_t * timeInterval, WVRMethod * wvrMethod, double * polyFreqLimits, int * polyFreqLimitsDim, int * numInputAntenna, int * numChan, int * numPoly, float * pathCoeff, int * pathCoeffDim, double * refTemp, int * refTempDim, int * inputAntennaId, int * inputAntennaIdDim) {
	
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
		return -1;
	}
	WVMCalTable &table = dataset->getWVMCal();
	WVMCalRow *row = 0;
	if (*(timeInterval+1)>0)  
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval, *(timeInterval+1)));
	else
		row = table.getRowByKey( Tag(*antennaId, TagType::Antenna), Tag(*spectralWindowId, TagType::SpectralWindow), ArrayTimeInterval(*timeInterval));
	
	
	if (row==0) {
		return -1;
	} else {
		// copy all elements of row in method parameters
		// example: *pressure      = row->getPressure().get();
		//  attr.NameS:  antennaId  attr.UpperCaseName: AntennaId
		//  attr.NameS:  spectralWindowId  attr.UpperCaseName: SpectralWindowId
		//  attr.NameS:  timeInterval  attr.UpperCaseName: TimeInterval
		//  attr.NameS:  wvrMethod  attr.UpperCaseName: WvrMethod
		*wvrMethod = row->getWvrMethod();
		//  attr.NameS:  polyFreqLimits  attr.UpperCaseName: PolyFreqLimits
		
		vector<Frequency >  polyFreqLimitsVec = row->getPolyFreqLimits();
		
		for (int i=0; i<min((int)polyFreqLimitsVec.size(),polyFreqLimitsDim[1]); i++)
			polyFreqLimits[i] = polyFreqLimitsVec[i].get();
		polyFreqLimitsDim[0] = polyFreqLimitsVec.size(); // return dimension of the ASDM table
		
		//  attr.NameS:  numInputAntenna  attr.UpperCaseName: NumInputAntenna
		*numInputAntenna = row->getNumInputAntenna();
		//  attr.NameS:  numChan  attr.UpperCaseName: NumChan
		*numChan = row->getNumChan();
		//  attr.NameS:  numPoly  attr.UpperCaseName: NumPoly
		*numPoly = row->getNumPoly();
		//  attr.NameS:  pathCoeff  attr.UpperCaseName: PathCoeff
		
		vector<vector<vector<float > > >  pathCoeffVec = row->getPathCoeff();
		int maxDimTwoPathCoeff = 0;
		int maxDimZeroPathCoeff = 0;
		for (int i=0; i<  min((int)pathCoeffVec.size(),pathCoeffDim[5]) ;i++) {
			maxDimTwoPathCoeff = max((int)pathCoeffVec[i].size(),maxDimTwoPathCoeff);
			for (int j=0;j< min((int)pathCoeffVec[i].size(),pathCoeffDim[3]) ;j++) {
				maxDimZeroPathCoeff = max((int)pathCoeffVec[i][j].size(),maxDimZeroPathCoeff);
				for (int k=0; k< min((int)pathCoeffVec[i][j].size(),pathCoeffDim[1]) ;k++) {
pathCoeff[(i*pathCoeffDim[3]+j)*pathCoeffDim[1]+k]= pathCoeffVec[i][j][k];
				}
			}
		}
		pathCoeffDim[0] = maxDimZeroPathCoeff;
		pathCoeffDim[2] = maxDimTwoPathCoeff;
		pathCoeffDim[4] = pathCoeffVec.size();  // return dimension of the ASDM table
		//  attr.NameS:  refTemp  attr.UpperCaseName: RefTemp
		
		vector<vector<Temperature > >  refTempVec = row->getRefTemp();
		
		int maxDimZeroRefTemp = 0;
		for (int i=0; i< min((int)refTempVec.size(),refTempDim[3]) ;i++) {
			maxDimZeroRefTemp = max((int)refTempVec[i].size(),maxDimZeroRefTemp);
			for (int j=0; j<min((int)refTempVec[i].size(),refTempDim[1]) ;j++) {
				refTemp[i*refTempDim[1]+j] = refTempVec[i][j].get();
			}
		}
		refTempDim[0] = maxDimZeroRefTemp;
		refTempDim[2] = refTempVec.size();  // return dimension of the ASDM table
		
		//  attr.NameS:  inputAntennaId  attr.UpperCaseName: InputAntennaId
		
		vector<Tag>   inputAntennaIdVec = row->getInputAntennaId();
		
		for (int i=0; i<min((int)inputAntennaIdVec.size(),inputAntennaIdDim[1]); i++)
			//inputAntennaId[i] = atoi((row->getInputAntennaId()[i]).getId().c_str());
		inputAntennaId[i] = inputAntennaIdVec[i].getTagValue();
		inputAntennaIdDim[0] = (int)inputAntennaIdVec.size();  // return dimension of the ASDM table
		
		
		
		return 1;   // 1 means that the line has been found
	}	
}




// -------------------------------------------
/**
 * Return the size of a table
 *  0  if table is empty
 * -1 if table does not exist
 *
 */

int sdm_getWVMCalTableSize() {
	if (dataset==0) {
    cout<<"No dataset initialized"<<endl;
    return -1;
}
WVMCalTable &table = dataset->getWVMCal();
	int size = (int)table.get().size();
	return size;
}


// -------------------------------------------
/**
 * Return key arrays
 *  0  if table is empty
 * -1 if table does not exist
 *
 */
int sdm_getWVMCalKeys(int * antennaId, int * spectralWindowId, int64_t * timeInterval) {
	if (dataset==0) {
		cout<<"No dataset initialized"<<endl;
	    return -1;
	}
	
	WVMCalTable &table = dataset->getWVMCal();
	
	vector< WVMCalRow * > row = table.get();
  	int size = (int)table.get().size();

 	if (size==0) {
		return 0;
  	} else {
  		for (int i=0;i<size;i++) {
	  		// antennaId[i] = atoi((row[i]->getAntennaId().getId()).c_str());
				antennaId[i] = row[i]->getAntennaId().getTagValue();
	  		// spectralWindowId[i] = atoi((row[i]->getSpectralWindowId().getId()).c_str());
				spectralWindowId[i] = row[i]->getSpectralWindowId().getTagValue();
	  		timeInterval[2*i]   = row[i]->getTimeInterval().getStartInNanoSeconds();
				timeInterval[2*i+1]  = row[i]->getTimeInterval().getDurationInNanoSeconds();
	  		//cout<<"ArrayTimeInterval in key"<<endl;
  		}
  		
		return size;
  	}
}








