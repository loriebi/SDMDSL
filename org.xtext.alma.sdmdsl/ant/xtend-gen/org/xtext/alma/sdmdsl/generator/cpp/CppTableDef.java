package org.xtext.alma.sdmdsl.generator.cpp;

import alma.hla.datamodel.meta.asdm.ASDMAttribute;
import alma.hla.datamodel.meta.asdm.AlmaTable;
import alma.hla.datamodel.meta.asdm.AlmaTableContainer;
import alma.hla.datamodel.meta.asdm.TableKey;
import java.util.HashSet;
import java.util.List;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.xtext.alma.sdmdsl.generator.sdmfilesystem.SDMFileSystemAccess;

@SuppressWarnings("all")
public class CppTableDef {
  private AlmaTableContainer container = AlmaTableContainer.getInstance();
  
  public void doGenerate(final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    SDMFileSystemAccess sdmFsa = ((SDMFileSystemAccess) fsa);
    List<AlmaTable> _tables = this.container.getTables();
    for (final AlmaTable table : _tables) {
      {
        String _name = table.getName();
        String _plus = ("include/" + _name);
        String _plus_1 = (_plus + "Table.h");
        sdmFsa.setFile(_plus_1);
        CharSequence _generateCppTableDef = this.generateCppTableDef(table);
        sdmFsa.generateFile(_generateCppTableDef);
      }
    }
  }
  
  public CharSequence generateCppTableDef(final AlmaTable table) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ALMA - Atacama Large Millimeter Array");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* (c) European Southern Observatory, 2002");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* (c) Associated Universities Inc., 2002");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Copyright by ESO (in the framework of the ALMA collaboration),");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Copyright by AUI (in the framework of the ALMA collaboration),");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* All rights reserved.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* This library is free software; you can redistribute it and/or");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* modify it under the terms of the GNU Lesser General Public");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* License as published by the Free software Foundation; either");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* version 2.1 of the License, or (at your option) any later version.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* This library is distributed in the hope that it will be useful,");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* but WITHOUT ANY WARRANTY, without even the implied warranty of");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Lesser General Public License for more details.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* You should have received a copy of the GNU Lesser General Public");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* License along with this library; if not, write to the Free Software");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Foundation, Inc., 59 Temple Place, Suite 330, Boston,");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* MA 02111-1307  USA");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Warning!");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*  -------------------------------------------------------------------- ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* | This is generated code!  Do not modify this file.                  |");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* | If you do, all changes will be lost when the file is re-generated. |");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*  --------------------------------------------------------------------");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* File ");
    String _name = table.getName();
    _builder.append(_name, " ");
    _builder.append("Table.h");
    _builder.newLineIfNotEmpty();
    _builder.append(" ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append(" ");
    _builder.newLine();
    _builder.append("#ifndef ");
    String _name_1 = table.getName();
    _builder.append(_name_1, "");
    _builder.append("Table_CLASS");
    _builder.newLineIfNotEmpty();
    _builder.append("#define ");
    String _name_2 = table.getName();
    _builder.append(_name_2, "");
    _builder.append("Table_CLASS");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("#include <string>");
    _builder.newLine();
    _builder.append("#include <vector>");
    _builder.newLine();
    _builder.append("#include <map>");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    {
      HashSet<String> _usedExtendedTypes = table.getUsedExtendedTypes();
      for(final String et : _usedExtendedTypes) {
        {
          boolean _or = false;
          boolean _or_1 = false;
          boolean _or_2 = false;
          boolean _or_3 = false;
          boolean _or_4 = false;
          boolean _or_5 = false;
          boolean _or_6 = false;
          boolean _or_7 = false;
          boolean _equals = et.equals("Boolean");
          if (_equals) {
            _or_7 = true;
          } else {
            boolean _equals_1 = et.equals("Byte");
            _or_7 = _equals_1;
          }
          if (_or_7) {
            _or_6 = true;
          } else {
            boolean _equals_2 = et.equals("Character");
            _or_6 = _equals_2;
          }
          if (_or_6) {
            _or_5 = true;
          } else {
            boolean _equals_3 = et.equals("Complex");
            _or_5 = _equals_3;
          }
          if (_or_5) {
            _or_4 = true;
          } else {
            boolean _equals_4 = et.equals("Double");
            _or_4 = _equals_4;
          }
          if (_or_4) {
            _or_3 = true;
          } else {
            boolean _equals_5 = et.equals("Float");
            _or_3 = _equals_5;
          }
          if (_or_3) {
            _or_2 = true;
          } else {
            boolean _equals_6 = et.equals("Integer");
            _or_2 = _equals_6;
          }
          if (_or_2) {
            _or_1 = true;
          } else {
            boolean _equals_7 = et.equals("Long");
            _or_1 = _equals_7;
          }
          if (_or_1) {
            _or = true;
          } else {
            boolean _equals_8 = et.equals("Short");
            _or = _equals_8;
          }
          if (_or) {
            _builder.append("#include <");
            _builder.append(et, "");
            _builder.append("Wrapper.h>");
            _builder.newLineIfNotEmpty();
          } else {
            _builder.append("#include <");
            _builder.append(et, "");
            _builder.append(".h>");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    {
      List<ASDMAttribute> _intrinsic = table.getIntrinsic();
      for(final ASDMAttribute attr : _intrinsic) {
        {
          boolean _isEnumeration = attr.isEnumeration();
          if (_isEnumeration) {
            _builder.append("#include \"C");
            String _typeName = attr.getTypeName();
            _builder.append(_typeName, "");
            _builder.append(".h\"");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.newLine();
    _builder.newLine();
    _builder.append("#include <ConversionException.h>");
    _builder.newLine();
    _builder.append("#include <DuplicateKey.h>");
    _builder.newLine();
    _builder.append("#include <UniquenessViolationException.h>");
    _builder.newLine();
    _builder.append("#include <NoSuchRow.h>");
    _builder.newLine();
    _builder.append("#include <DuplicateKey.h>");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("#ifndef WITHOUT_ACS");
    _builder.newLine();
    _builder.append("#include <asdmIDLC.h>");
    _builder.newLine();
    _builder.append("#endif");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("#include <Representable.h>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#include <pthread.h>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("namespace asdm {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("//class asdm::");
    String _name_3 = this.container.getName();
    _builder.append(_name_3, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("//class asdm::");
    String _name_4 = table.getName();
    _builder.append(_name_4, "");
    _builder.append("Row;");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("class ");
    String _name_5 = this.container.getName();
    _builder.append(_name_5, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("class ");
    String _name_6 = table.getName();
    _builder.append(_name_6, "");
    _builder.append("Row;");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("/**");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* The ");
    String _name_7 = table.getName();
    _builder.append(_name_7, " ");
    _builder.append("Table class is an Alma table.");
    _builder.newLineIfNotEmpty();
    _builder.append(" ");
    _builder.append("* <BR>");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* \\par Role");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    String _doc = table.getDoc();
    _builder.append(_doc, " ");
    _builder.newLineIfNotEmpty();
    _builder.append(" ");
    _builder.append("* <BR>");
    _builder.newLine();
    _builder.append(" ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Generated from model\'s revision \"");
    int _revision = AlmaTable.getRevision();
    _builder.append(_revision, " ");
    _builder.append("\", branch ");
    String _branch = AlmaTable.getBranch();
    _builder.append(_branch, " ");
    _builder.newLineIfNotEmpty();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* <TABLE BORDER=\"1\">");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* <CAPTION> Attributes of ");
    String _name_8 = table.getName();
    _builder.append(_name_8, " ");
    _builder.append(" </CAPTION>");
    _builder.newLineIfNotEmpty();
    _builder.append(" ");
    _builder.append("* <TR BGCOLOR=\"#AAAAAA\"> <TH> Name </TH> <TH> Type </TH> <TH> Expected shape  </TH> <TH> Comment </TH></TR>");
    _builder.newLine();
    {
      List<ASDMAttribute> _keyAttributes = table.getKeyAttributes();
      int _size = _keyAttributes.size();
      boolean _notEquals = (_size != 0);
      if (_notEquals) {
        _builder.append(" ");
        _builder.append("* <TR> <TH BGCOLOR=\"#CCCCCC\" colspan=\"4\" align=\"center\"> Key </TD></TR>");
        _builder.newLine();
        {
          List<ASDMAttribute> _keyAttributes_1 = table.getKeyAttributes();
          for(final ASDMAttribute kat : _keyAttributes_1) {
            _builder.append(" ");
            _builder.append("* <TR>");
            _builder.newLine();
            {
              boolean _isAutoIncrementable = kat.isAutoIncrementable();
              if (_isAutoIncrementable) {
                _builder.append(" ");
                _builder.append("* <TD><I> ");
                String _name_9 = kat.getName();
                _builder.append(_name_9, " ");
                _builder.append(" </I></TD>");
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append(" ");
                _builder.append("* <TD> ");
                String _name_10 = kat.getName();
                _builder.append(_name_10, " ");
                _builder.append(" </TD>");
                _builder.newLineIfNotEmpty();
              }
            }
            _builder.append(" ");
            _builder.append("* <TD> ");
            String _CppType = kat.CppType();
            _builder.append(_CppType, " ");
            _builder.append("</TD>");
            _builder.newLineIfNotEmpty();
            _builder.append(" ");
            _builder.append("* <TD> &nbsp; </TD>");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* <TD> &nbsp;");
            String _ShortDocumentation = kat.ShortDocumentation();
            _builder.append(_ShortDocumentation, " ");
            _builder.append(" </TD>");
            _builder.newLineIfNotEmpty();
            _builder.append(" ");
            _builder.append("* </TR>");
            _builder.newLine();
          }
        }
      }
    }
    {
      List<ASDMAttribute> _requiredValueAttributes = table.getRequiredValueAttributes();
      int _size_1 = _requiredValueAttributes.size();
      boolean _notEquals_1 = (_size_1 != 0);
      if (_notEquals_1) {
        _builder.append(" ");
        _builder.append("* <TR> <TH BGCOLOR=\"#CCCCCC\"  colspan=\"4\" valign=\"center\"> Value <br> (Mandatory) </TH></TR>");
        _builder.newLine();
        {
          List<ASDMAttribute> _requiredValueAttributes_1 = table.getRequiredValueAttributes();
          for(final ASDMAttribute rvat : _requiredValueAttributes_1) {
            _builder.append("* <TR>");
            _builder.newLine();
            _builder.append("* <TD> ");
            String _name_11 = rvat.getName();
            _builder.append(_name_11, "");
            _builder.append(" ");
            {
              boolean _isDimensionPar = rvat.isDimensionPar();
              if (_isDimensionPar) {
                _builder.append("(");
                String _LatexSymbol = rvat.LatexSymbol();
                _builder.append(_LatexSymbol, "");
                _builder.append(")");
              }
            }
            _builder.append("</TD>");
            _builder.newLineIfNotEmpty();
            _builder.append("* <TD> ");
            String _CppType_1 = rvat.CppType();
            _builder.append(_CppType_1, "");
            _builder.append(" </TD>");
            _builder.newLineIfNotEmpty();
            _builder.append("* <TD> ");
            {
              boolean _isArray = rvat.isArray();
              if (_isArray) {
                _builder.append(" ");
                String _CppTypeDescription = rvat.CppTypeDescription();
                _builder.append(_CppTypeDescription, "");
              } else {
                _builder.append(" &nbsp; ");
              }
            }
            _builder.append(" </TD>");
            _builder.newLineIfNotEmpty();
            _builder.append("* <TD> &nbsp;");
            String _ShortDocumentation_1 = rvat.ShortDocumentation();
            _builder.append(_ShortDocumentation_1, "");
            _builder.append(" </TD>");
            _builder.newLineIfNotEmpty();
            _builder.append("* </TR>");
            _builder.newLine();
          }
        }
      }
    }
    {
      List<ASDMAttribute> _optionalValueAttributes = table.getOptionalValueAttributes();
      int _size_2 = _optionalValueAttributes.size();
      boolean _notEquals_2 = (_size_2 != 0);
      if (_notEquals_2) {
        _builder.append(" ");
        _builder.append("* <TR> <TH BGCOLOR=\"#CCCCCC\"  colspan=\"4\" valign=\"center\"> Value <br> (Optional) </TH></TR>");
        _builder.newLine();
        {
          List<ASDMAttribute> _optionalValueAttributes_1 = table.getOptionalValueAttributes();
          for(final ASDMAttribute ovat : _optionalValueAttributes_1) {
            _builder.append("* <TR>");
            _builder.newLine();
            _builder.append("* <TD> ");
            String _name_12 = ovat.getName();
            _builder.append(_name_12, "");
            {
              boolean _isDimensionPar_1 = ovat.isDimensionPar();
              if (_isDimensionPar_1) {
                _builder.append("(");
                String _LatexSymbol_1 = ovat.LatexSymbol();
                _builder.append(_LatexSymbol_1, "");
                _builder.append(")");
              }
            }
            _builder.append("</TD>");
            _builder.newLineIfNotEmpty();
            _builder.append("* <TD> ");
            String _CppType_2 = ovat.CppType();
            _builder.append(_CppType_2, "");
            _builder.append(" </TD>");
            _builder.newLineIfNotEmpty();
            _builder.append("* <TD> ");
            {
              boolean _isArray_1 = ovat.isArray();
              if (_isArray_1) {
                _builder.append(" ");
                String _CppTypeDescription_1 = ovat.CppTypeDescription();
                _builder.append(_CppTypeDescription_1, "");
                _builder.append(" ");
              } else {
                _builder.append(" &nbsp;");
              }
            }
            _builder.append(" </TD>");
            _builder.newLineIfNotEmpty();
            _builder.append("* <TD>&nbsp; ");
            String _ShortDocumentation_2 = ovat.ShortDocumentation();
            _builder.append(_ShortDocumentation_2, "");
            _builder.append(" </TD>");
            _builder.newLineIfNotEmpty();
            _builder.append("* </TR>");
            _builder.newLine();
          }
        }
      }
    }
    _builder.append(" ");
    _builder.append("* </TABLE>");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*/");
    _builder.newLine();
    _builder.newLine();
    _builder.append("class ");
    String _name_13 = table.getName();
    _builder.append(_name_13, "");
    _builder.append("Table : public Representable {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("friend class ");
    String _name_14 = this.container.getName();
    _builder.append(_name_14, "\t");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public:");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Return the list of field names that make up key ");
    TableKey _key = table.getKey();
    String _name_15 = _key.getName();
    _builder.append(_name_15, "\t ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("* as an array of strings.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return a vector of string.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("static const std::vector<std::string>& get");
    TableKey _key_1 = table.getKey();
    String _UpperCaseName = _key_1.UpperCaseName();
    _builder.append(_UpperCaseName, "\t");
    _builder.append("Name();");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("virtual ~");
    String _name_16 = table.getName();
    _builder.append(_name_16, "\t");
    _builder.append("Table();");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Return the container to which this table belongs.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return the ");
    String _name_17 = this.container.getName();
    _builder.append(_name_17, "\t ");
    _builder.append(" containing this table.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    String _name_18 = this.container.getName();
    _builder.append(_name_18, "\t");
    _builder.append(" &getContainer() const;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Return the number of rows in the table.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return the number of rows in an unsigned int.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("unsigned int size() const;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Return the name of this table.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* This is a instance method of the class.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return the name of this table in a string.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("std::string getName() const;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Return the name of this table.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* This is a static method of the class.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return the name of this table in a string.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("static std::string name() ;\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Return the version information about this table.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("std::string getVersion() const ;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Return the names of the attributes of this table.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return a vector of string");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("static const std::vector<std::string>& getAttributesNames();");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Return the default sorted list of attributes names in the binary representation of the table.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return a const reference to a vector of string");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("static const std::vector<std::string>& defaultAttributesNamesInBin();");
    _builder.newLine();
    _builder.append("\t ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Return this table\'s Entity.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Entity getEntity() const;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Set this table\'s Entity.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param e An entity. ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void setEntity(Entity e);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Produces an XML representation conform");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* to the schema defined for ");
    String _name_19 = table.getName();
    _builder.append(_name_19, "\t ");
    _builder.append(" (");
    String _name_20 = table.getName();
    _builder.append(_name_20, "\t ");
    _builder.append("Table.xsd).");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @returns a string containing the XML representation.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @throws ConversionException");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("std::string toXML()  ;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("#ifndef WITHOUT_ACS");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// Conversion Methods");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Convert this table into a ");
    String _name_21 = table.getName();
    _builder.append(_name_21, "\t ");
    _builder.append("TableIDL CORBA structure.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return a pointer to a ");
    String _name_22 = table.getName();
    _builder.append(_name_22, "\t ");
    _builder.append("TableIDL");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("asdmIDL::");
    String _name_23 = table.getName();
    _builder.append(_name_23, "\t");
    _builder.append("TableIDL *toIDL() ;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Fills the CORBA data structure passed in parameter");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* with the content of this table.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param x a reference to the asdmIDL::");
    String _name_24 = table.getName();
    _builder.append(_name_24, "\t ");
    _builder.append("TableIDL to be populated");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("* with the content of this.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("void toIDL(asdmIDL::");
    String _name_25 = table.getName();
    _builder.append(_name_25, "\t ");
    _builder.append("TableIDL& x) const;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.newLine();
    _builder.append("#endif");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#ifndef WITHOUT_ACS");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Populate this table from the content of a ");
    String _name_26 = table.getName();
    _builder.append(_name_26, "\t ");
    _builder.append("TableIDL Corba structure.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @throws DuplicateKey Thrown if the method tries to add a row having a key that is already in the table.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @throws ConversionException");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void fromIDL(asdmIDL::");
    String _name_27 = table.getName();
    _builder.append(_name_27, "\t");
    _builder.append("TableIDL x) ;");
    _builder.newLineIfNotEmpty();
    _builder.append("#endif");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// ====> Row creation.");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Create a new row with default values.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return a pointer on a ");
    String _name_28 = table.getName();
    _builder.append(_name_28, "\t ");
    _builder.append("Row");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    String _name_29 = table.getName();
    _builder.append(_name_29, "\t");
    _builder.append("Row *newRow();");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    {
      List<ASDMAttribute> _requiredNoAutoIncrementableAttributes = table.getRequiredNoAutoIncrementableAttributes();
      int _size_3 = _requiredNoAutoIncrementableAttributes.size();
      boolean _notEquals_3 = (_size_3 != 0);
      if (_notEquals_3) {
        _builder.append("\t");
        _builder.append("/**");
        _builder.newLine();
        _builder.append("\t");
        _builder.append(" ");
        _builder.append("* Create a new row initialized to the specified values.");
        _builder.newLine();
        _builder.append("\t");
        _builder.append(" ");
        _builder.append("* @return a pointer on the created and initialized row.");
        _builder.newLine();
        {
          List<ASDMAttribute> _requiredNoAutoIncrementableAttributes_1 = table.getRequiredNoAutoIncrementableAttributes();
          for(final ASDMAttribute attr_1 : _requiredNoAutoIncrementableAttributes_1) {
            _builder.append("\t");
            _builder.append("* @param ");
            String _name_30 = attr_1.getName();
            _builder.append(_name_30, "\t");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.append(" ");
        _builder.append("*/");
        _builder.newLine();
        _builder.append("\t");
        String _name_31 = table.getName();
        _builder.append(_name_31, "\t");
        _builder.append("Row *newRow(");
        String _RequiredNoAutoIncrementableCpp = table.RequiredNoAutoIncrementableCpp();
        _builder.append(_RequiredNoAutoIncrementableCpp, "\t");
        _builder.append(");");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.newLine();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Create a new row using a copy constructor mechanism.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* The method creates a new ");
    String _name_32 = table.getName();
    _builder.append(_name_32, "\t ");
    _builder.append("Row owned by this. Each attribute of the created row ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("* is a (deep) copy of the corresponding attribute of row. The method does not add ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* the created row to this, its simply parents it to this, a call to the add method");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* has to be done in order to get the row added (very likely after having modified");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* some of its attributes).");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* If row is null then the method returns a new ");
    String _name_33 = table.getName();
    _builder.append(_name_33, "\t ");
    _builder.append("Row with default values for its attributes. ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param row the row which is to be copied.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t ");
    String _name_34 = table.getName();
    _builder.append(_name_34, "\t ");
    _builder.append("Row *newRow(");
    String _name_35 = table.getName();
    _builder.append(_name_35, "\t ");
    _builder.append("Row *row); ");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// ====> Append a row to its table.");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//");
    _builder.newLine();
    {
      boolean _NoAutoIncrementableAttribute = table.NoAutoIncrementableAttribute();
      boolean _not = (!_NoAutoIncrementableAttribute);
      if (_not) {
        _builder.newLine();
        {
          boolean _isTemporal = table.isTemporal();
          if (_isTemporal) {
            _builder.newLine();
            _builder.newLine();
            _builder.append("/** ");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* Add a row.");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* If there table contains a row whose key\'s fields except² ");
            ASDMAttribute _TheAutoIncrementableAttribute = table.TheAutoIncrementableAttribute();
            String _name_36 = _TheAutoIncrementableAttribute.getName();
            _builder.append(_name_36, " ");
            _builder.append(" are equal");
            _builder.newLineIfNotEmpty();
            _builder.append(" ");
            _builder.append("* to x\'s ones then return a pointer on this row (i.e. no actual insertion is performed) ");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* otherwise add x to the table and return x.");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* @param x . A pointer on the row to be added.");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* @returns a pointer to a ");
            String _name_37 = table.getName();
            _builder.append(_name_37, " ");
            _builder.append("Row.");
            _builder.newLineIfNotEmpty();
            _builder.append(" ");
            _builder.append("*/");
            _builder.newLine();
          } else {
            _builder.newLine();
            _builder.append("/** ");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* Add a row.");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* If there table contains a row whose key\'s fields are equal");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* to x\'s ones then return a pointer on this row (i.e. no actual insertion is performed) ");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* otherwise add x to the table and return x.");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* @param x . A pointer on the row to be added.");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* @returns a pointer to a ");
            String _name_38 = table.getName();
            _builder.append(_name_38, " ");
            _builder.append("Row.\t ");
            _builder.newLineIfNotEmpty();
            _builder.append(" ");
            _builder.append("*/\t");
            _builder.newLine();
          }
        }
        _builder.append("\t \t ");
        String _name_39 = table.getName();
        _builder.append(_name_39, "\t \t ");
        _builder.append("Row* add(");
        String _name_40 = table.getName();
        _builder.append(_name_40, "\t \t ");
        _builder.append("Row* x) ;");
        _builder.newLineIfNotEmpty();
      } else {
        _builder.newLine();
        _builder.append("/**");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* Add a row.");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* @param x a pointer to the ");
        String _name_41 = table.getName();
        _builder.append(_name_41, " ");
        _builder.append("Row to be added.");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("*");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* @return a pointer to a ");
        String _name_42 = table.getName();
        _builder.append(_name_42, " ");
        _builder.append("Row. If the table contains a ");
        String _name_43 = table.getName();
        _builder.append(_name_43, " ");
        _builder.append("Row whose attributes (key and mandatory values) are equal to x ones");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("* then returns a pointer on that ");
        String _name_44 = table.getName();
        _builder.append(_name_44, " ");
        _builder.append("Row, otherwise returns x.");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("*");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* @throw DuplicateKey { thrown when the table contains a ");
        String _name_45 = table.getName();
        _builder.append(_name_45, " ");
        _builder.append("Row with a key equal to the x one but having");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("* and a value section different from x one }");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("*");
        _builder.newLine();
        {
          boolean _isTemporal_1 = table.isTemporal();
          if (_isTemporal_1) {
            _builder.append("* @note The row is inserted in the table in such a way that all the rows having the same value of");
            _builder.newLine();
            _builder.append("* ( ");
            String _KeyNoAutoIncNoTimeAttributesList = table.KeyNoAutoIncNoTimeAttributesList();
            _builder.append(_KeyNoAutoIncNoTimeAttributesList, "");
            _builder.append(" ) are stored by ascending time.");
            _builder.newLineIfNotEmpty();
            _builder.append("* @see method getByContext.");
            _builder.newLine();
          }
        }
        _builder.append(" ");
        _builder.append("*/");
        _builder.newLine();
        String _name_46 = table.getName();
        _builder.append(_name_46, "");
        _builder.append("Row* add(");
        String _name_47 = table.getName();
        _builder.append(_name_47, "");
        _builder.append("Row* x) ;");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// ====> Methods returning rows.");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Get a collection of pointers on the rows of the table.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return Alls rows in a vector of pointers of ");
    String _name_48 = table.getName();
    _builder.append(_name_48, "\t ");
    _builder.append("Row. The elements of this vector are stored in the order ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("* in which they have been added to the ");
    String _name_49 = table.getName();
    _builder.append(_name_49, "\t ");
    _builder.append("Table.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("std::vector<");
    String _name_50 = table.getName();
    _builder.append(_name_50, "\t");
    _builder.append("Row *> get() ;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Get a const reference on the collection of rows pointers internally hold by the table.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return A const reference of a vector of pointers of ");
    String _name_51 = table.getName();
    _builder.append(_name_51, "\t ");
    _builder.append("Row. The elements of this vector are stored in the order ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("* in which they have been added to the ");
    String _name_52 = table.getName();
    _builder.append(_name_52, "\t ");
    _builder.append("Table.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("const std::vector<");
    String _name_53 = table.getName();
    _builder.append(_name_53, "\t ");
    _builder.append("Row *>& get() const ;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.newLine();
    {
      boolean _and = false;
      boolean _and_1 = false;
      boolean _isTemporal_2 = table.isTemporal();
      if (!_isTemporal_2) {
        _and_1 = false;
      } else {
        boolean _NoAutoIncrementableAttribute_1 = table.NoAutoIncrementableAttribute();
        _and_1 = _NoAutoIncrementableAttribute_1;
      }
      if (!_and_1) {
        _and = false;
      } else {
        List<ASDMAttribute> _keyNoAutoIncrementableAttributes = table.getKeyNoAutoIncrementableAttributes();
        int _size_4 = _keyNoAutoIncrementableAttributes.size();
        boolean _notEquals_4 = (_size_4 != 0);
        _and = _notEquals_4;
      }
      if (_and) {
        _builder.append("/**");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* Returns all the rows sorted by ascending startTime for a given context. ");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* The context is defined by a value of ( ");
        String _KeyNoAutoIncNoTimeAttributesList_1 = table.KeyNoAutoIncNoTimeAttributesList();
        _builder.append(_KeyNoAutoIncNoTimeAttributesList_1, " ");
        _builder.append(" ).");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("*");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* @return a pointer on a vector<");
        String _name_54 = table.getName();
        _builder.append(_name_54, " ");
        _builder.append("Row *>. A null returned value means that the table contains");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("* no ");
        String _name_55 = table.getName();
        _builder.append(_name_55, " ");
        _builder.append("Row for the given ( ");
        String _KeyNoAutoIncNoTimeAttributesList_2 = table.KeyNoAutoIncNoTimeAttributesList();
        _builder.append(_KeyNoAutoIncNoTimeAttributesList_2, " ");
        _builder.append(" ).");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("*");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* @throws IllegalAccessException when a call is done to this method when it\'s called while the dataset has been imported with the ");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* option checkRowUniqueness set to false.");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("*/");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("std::vector <");
        String _name_56 = table.getName();
        _builder.append(_name_56, " ");
        _builder.append("Row*> *getByContext(");
        String _KeyNoAutoIncNoTimeCpp = table.KeyNoAutoIncNoTimeCpp();
        _builder.append(_KeyNoAutoIncNoTimeCpp, " ");
        _builder.append(");");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.newLine();
      }
    }
    _builder.newLine();
    _builder.newLine();
    {
      String _KeyCpp = table.KeyCpp();
      boolean _equals_9 = _KeyCpp.equals("");
      boolean _not_1 = (!_equals_9);
      if (_not_1) {
        _builder.newLine();
        _builder.append("/**");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* Returns a ");
        String _name_57 = table.getName();
        _builder.append(_name_57, " ");
        _builder.append("Row* given a key.");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("* @return a pointer to the row having the key whose values are passed as parameters, or 0 if");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* no row exists for that key.");
        _builder.newLine();
        {
          List<ASDMAttribute> _keyAttributes_2 = table.getKeyAttributes();
          for(final ASDMAttribute attr_2 : _keyAttributes_2) {
            _builder.append("* @param ");
            String _name_58 = attr_2.getName();
            _builder.append(_name_58, "");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append(" ");
        _builder.append("*");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("*/");
        _builder.newLine();
        _builder.append("\t \t");
        String _name_59 = table.getName();
        _builder.append(_name_59, "\t \t");
        _builder.append("Row* getRowByKey(");
        String _KeyCpp_1 = table.KeyCpp();
        _builder.append(_KeyCpp_1, "\t \t");
        _builder.append(");");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.newLine();
    {
      boolean _and_2 = false;
      boolean _NoAutoIncrementableAttribute_2 = table.NoAutoIncrementableAttribute();
      boolean _not_2 = (!_NoAutoIncrementableAttribute_2);
      if (!_not_2) {
        _and_2 = false;
      } else {
        List<ASDMAttribute> _keyNoAutoIncrementableAttributes_1 = table.getKeyNoAutoIncrementableAttributes();
        int _size_5 = _keyNoAutoIncrementableAttributes_1.size();
        boolean _notEquals_5 = (_size_5 != 0);
        _and_2 = _notEquals_5;
      }
      if (_and_2) {
        _builder.append("/**");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* Returns a vector of pointers on rows whose key element ");
        ASDMAttribute _TheAutoIncrementableAttribute_1 = table.TheAutoIncrementableAttribute();
        String _name_60 = _TheAutoIncrementableAttribute_1.getName();
        _builder.append(_name_60, " ");
        _builder.append(" ");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("* is equal to the parameter ");
        ASDMAttribute _TheAutoIncrementableAttribute_2 = table.TheAutoIncrementableAttribute();
        String _name_61 = _TheAutoIncrementableAttribute_2.getName();
        _builder.append(_name_61, " ");
        _builder.append(".");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("* @return a vector of vector <");
        String _name_62 = table.getName();
        _builder.append(_name_62, " ");
        _builder.append("Row *>. A returned vector of size 0 means that no row has been found.");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("* @param ");
        ASDMAttribute _TheAutoIncrementableAttribute_3 = table.TheAutoIncrementableAttribute();
        String _name_63 = _TheAutoIncrementableAttribute_3.getName();
        _builder.append(_name_63, " ");
        _builder.append(" ");
        ASDMAttribute _TheAutoIncrementableAttribute_4 = table.TheAutoIncrementableAttribute();
        String _CppType_3 = _TheAutoIncrementableAttribute_4.CppType();
        _builder.append(_CppType_3, " ");
        _builder.append(" contains the value of");
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("* the autoincrementable attribute that is looked up in the table.");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("*/");
        _builder.newLine();
        _builder.append("std::vector <");
        String _name_64 = table.getName();
        _builder.append(_name_64, "");
        _builder.append("Row *>  getRowBy");
        ASDMAttribute _TheAutoIncrementableAttribute_5 = table.TheAutoIncrementableAttribute();
        String _UpperCaseName_1 = _TheAutoIncrementableAttribute_5.UpperCaseName();
        _builder.append(_UpperCaseName_1, "");
        _builder.append("(");
        ASDMAttribute _TheAutoIncrementableAttribute_6 = table.TheAutoIncrementableAttribute();
        String _CppType_4 = _TheAutoIncrementableAttribute_6.CppType();
        _builder.append(_CppType_4, "");
        _builder.append(");");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.newLine();
    {
      List<ASDMAttribute> _requiredNoAutoIncrementableAttributes_2 = table.getRequiredNoAutoIncrementableAttributes();
      int _size_6 = _requiredNoAutoIncrementableAttributes_2.size();
      boolean _notEquals_6 = (_size_6 != 0);
      if (_notEquals_6) {
        _builder.append("/**");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* Look up the table for a row whose all attributes ");
        {
          boolean _NoAutoIncrementableAttribute_3 = table.NoAutoIncrementableAttribute();
          boolean _not_3 = (!_NoAutoIncrementableAttribute_3);
          if (_not_3) {
            _builder.append(" except the autoincrementable one ");
          }
        }
        _builder.newLineIfNotEmpty();
        _builder.append(" ");
        _builder.append("* are equal to the corresponding parameters of the method.");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("* @return a pointer on this row if any, null otherwise.");
        _builder.newLine();
        _builder.append(" ");
        _builder.append("*");
        _builder.newLine();
        {
          List<ASDMAttribute> _requiredNoAutoIncrementableAttributes_3 = table.getRequiredNoAutoIncrementableAttributes();
          for(final ASDMAttribute attr_3 : _requiredNoAutoIncrementableAttributes_3) {
            _builder.append(" ");
            _builder.append("* @param ");
            String _name_65 = attr_3.getName();
            _builder.append(_name_65, " ");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append(" ");
        _builder.append("*/");
        _builder.newLine();
        String _name_66 = table.getName();
        _builder.append(_name_66, "");
        _builder.append("Row* lookup(");
        String _RequiredNoAutoIncrementableCpp_1 = table.RequiredNoAutoIncrementableCpp();
        _builder.append(_RequiredNoAutoIncrementableCpp_1, "");
        _builder.append("); ");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void setUnknownAttributeBinaryReader(const std::string& attributeName, BinaryAttributeReaderFunctor* barFctr);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("BinaryAttributeReaderFunctor* getUnknownAttributeBinaryReader(const std::string& attributeName) const;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("private:");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Create a ");
    String _name_67 = table.getName();
    _builder.append(_name_67, "\t ");
    _builder.append("Table.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("* <p>");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* This constructor is private because only the");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* container can create tables.  All tables must know the container");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* to which they belong.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param container The container to which this table belongs.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/ ");
    _builder.newLine();
    _builder.append("\t");
    String _name_68 = table.getName();
    _builder.append(_name_68, "\t");
    _builder.append("Table (");
    String _name_69 = this.container.getName();
    _builder.append(_name_69, "\t");
    _builder.append(" & container);");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    String _name_70 = this.container.getName();
    _builder.append(_name_70, "\t");
    _builder.append(" & container;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("bool archiveAsBin; // If true archive binary else archive XML");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("bool fileAsBin ; // If true file binary else file XML\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("std::string version ; ");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Entity entity;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    {
      String _name_71 = table.getName();
      boolean _equals_10 = _name_71.equals("Source");
      if (_equals_10) {
        _builder.append("/*");
        _builder.newLine();
        _builder.append("** Let\'s use a map to implement the condition \"one sourceName -> one sourceId\"");
        _builder.newLine();
        _builder.append("*/");
        _builder.newLine();
        _builder.append("std::map<const std::string, int> name2id_m;");
        _builder.newLine();
      }
    }
    _builder.newLine();
    {
      boolean _and_3 = false;
      boolean _NoAutoIncrementableAttribute_4 = table.NoAutoIncrementableAttribute();
      boolean _not_4 = (!_NoAutoIncrementableAttribute_4);
      if (!_not_4) {
        _and_3 = false;
      } else {
        boolean _isTemporal_3 = table.isTemporal();
        boolean _not_5 = (!_isTemporal_3);
        _and_3 = _not_5;
      }
      if (_and_3) {
        _builder.append("// A map for the autoincrementation algorithm");
        _builder.newLine();
        _builder.append("std::map<std::string,int>  noAutoIncIds;");
        _builder.newLine();
        _builder.append("void autoIncrement(std::string key, ");
        String _name_72 = table.getName();
        _builder.append(_name_72, "");
        _builder.append("Row* x);");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* If this table has an autoincrementable attribute then check if *x verifies the rule of uniqueness and throw exception if not.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Check if *x verifies the key uniqueness rule and throw an exception if not.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Append x to its table.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @throws DuplicateKey");
    _builder.newLine();
    {
      boolean _NoAutoIncrementableAttribute_5 = table.NoAutoIncrementableAttribute();
      boolean _not_6 = (!_NoAutoIncrementableAttribute_5);
      if (_not_6) {
        _builder.append("\t ");
        _builder.append("* @throws UniquenessViolationException");
        _builder.newLine();
      }
    }
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    String _name_73 = table.getName();
    _builder.append(_name_73, "\t");
    _builder.append("Row* checkAndAdd(");
    String _name_74 = table.getName();
    _builder.append(_name_74, "\t");
    _builder.append("Row* x, bool skipCheckUniqueness=false) ;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Brutally append an ");
    String _name_75 = table.getName();
    _builder.append(_name_75, "\t ");
    _builder.append("Row x to the collection of rows already stored in this table. No uniqueness check is done !");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param ");
    String _name_76 = table.getName();
    _builder.append(_name_76, "\t ");
    _builder.append("Row* x a pointer onto the ");
    String _name_77 = table.getName();
    _builder.append(_name_77, "\t ");
    _builder.append("Row to be appended.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("void append(");
    String _name_78 = table.getName();
    _builder.append(_name_78, "\t ");
    _builder.append("Row* x) ;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Brutally append an ");
    String _name_79 = table.getName();
    _builder.append(_name_79, "\t ");
    _builder.append("Row x to the collection of rows already stored in this table. No uniqueness check is done !");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param ");
    String _name_80 = table.getName();
    _builder.append(_name_80, "\t ");
    _builder.append("Row* x a pointer onto the ");
    String _name_81 = table.getName();
    _builder.append(_name_81, "\t ");
    _builder.append("Row to be appended.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("void addWithoutCheckingUnique(");
    String _name_82 = table.getName();
    _builder.append(_name_82, "\t ");
    _builder.append("Row* x) ;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.newLine();
    {
      boolean _isTemporal_4 = table.isTemporal();
      if (_isTemporal_4) {
        {
          ASDMAttribute _TemporalAttribute = table.TemporalAttribute();
          String _JavaType = _TemporalAttribute.JavaType();
          boolean _equals_11 = _JavaType.equals("ArrayTimeInterval");
          if (_equals_11) {
            _builder.newLine();
            _builder.append("/**");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* Insert a ");
            String _name_83 = table.getName();
            _builder.append(_name_83, " ");
            _builder.append("Row* in a vector of ");
            String _name_84 = table.getName();
            _builder.append(_name_84, " ");
            _builder.append("Row* so that it\'s ordered by ascending time.");
            _builder.newLineIfNotEmpty();
            _builder.append(" ");
            _builder.append("*");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("* @param ");
            String _name_85 = table.getName();
            _builder.append(_name_85, " ");
            _builder.append("Row* x . The pointer to be inserted.");
            _builder.newLineIfNotEmpty();
            _builder.append(" ");
            _builder.append("* @param vector <");
            String _name_86 = table.getName();
            _builder.append(_name_86, " ");
            _builder.append("Row*>& row . A reference to the vector where to insert x.");
            _builder.newLineIfNotEmpty();
            _builder.append(" ");
            _builder.append("*");
            _builder.newLine();
            _builder.append(" ");
            _builder.append("*/");
            _builder.newLine();
            _builder.append(" ");
            String _name_87 = table.getName();
            _builder.append(_name_87, " ");
            _builder.append("Row * insertByStartTime(");
            String _name_88 = table.getName();
            _builder.append(_name_88, " ");
            _builder.append("Row* x, std::vector<");
            String _name_89 = table.getName();
            _builder.append(_name_89, " ");
            _builder.append("Row* >& row);");
            _builder.newLineIfNotEmpty();
          } else {
            ASDMAttribute _TemporalAttribute_1 = table.TemporalAttribute();
            String _JavaType_1 = _TemporalAttribute_1.JavaType();
            boolean _equals_12 = _JavaType_1.equals("ArrayTime");
            if (_equals_12) {
              _builder.append(" ");
              _builder.newLine();
              _builder.append("/**");
              _builder.newLine();
              _builder.append(" ");
              _builder.append("* Insert a ");
              String _name_90 = table.getName();
              _builder.append(_name_90, " ");
              _builder.append("Row* in a vector of ");
              String _name_91 = table.getName();
              _builder.append(_name_91, " ");
              _builder.append("Row* so that it\'s ordered by ascending time.");
              _builder.newLineIfNotEmpty();
              _builder.append(" ");
              _builder.append("*");
              _builder.newLine();
              _builder.append(" ");
              _builder.append("* @param ");
              String _name_92 = table.getName();
              _builder.append(_name_92, " ");
              _builder.append("Row* x . The pointer to be inserted.");
              _builder.newLineIfNotEmpty();
              _builder.append(" ");
              _builder.append("* @param vector <");
              String _name_93 = table.getName();
              _builder.append(_name_93, " ");
              _builder.append("Row*>& row . A reference to the vector where to insert x.");
              _builder.newLineIfNotEmpty();
              _builder.append(" ");
              _builder.append("*");
              _builder.newLine();
              _builder.append(" ");
              _builder.append("*/");
              _builder.newLine();
              _builder.append("\t \t");
              String _name_94 = table.getName();
              _builder.append(_name_94, "\t \t");
              _builder.append("Row * insertByTime(");
              String _name_95 = table.getName();
              _builder.append(_name_95, "\t \t");
              _builder.append("Row* x, std::vector<");
              String _name_96 = table.getName();
              _builder.append(_name_96, "\t \t");
              _builder.append("Row *>&row );");
              _builder.newLineIfNotEmpty();
            }
          }
        }
      }
    }
    _builder.newLine();
    _builder.append("// A data structure to store the pointers on the table\'s rows.");
    _builder.newLine();
    _builder.newLine();
    _builder.append("// In all cases we maintain a private vector of ");
    String _name_97 = table.getName();
    _builder.append(_name_97, "");
    _builder.append("Row s.");
    _builder.newLineIfNotEmpty();
    _builder.append("   ");
    _builder.append("std::vector<");
    String _name_98 = table.getName();
    _builder.append(_name_98, "   ");
    _builder.append("Row * > privateRows;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    {
      boolean _isTemporal_5 = table.isTemporal();
      boolean _not_7 = (!_isTemporal_5);
      if (_not_7) {
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("std::vector<");
        String _name_99 = table.getName();
        _builder.append(_name_99, "");
        _builder.append("Row *> row;");
        _builder.newLineIfNotEmpty();
      } else {
        _builder.append("\t");
        _builder.newLine();
        _builder.newLine();
        {
          boolean _NoAutoIncrementableAttribute_6 = table.NoAutoIncrementableAttribute();
          if (_NoAutoIncrementableAttribute_6) {
            _builder.append("\t");
            _builder.newLine();
            {
              List<ASDMAttribute> _keyNoAutoIncNoTimeAttributes = table.getKeyNoAutoIncNoTimeAttributes();
              int _size_7 = _keyNoAutoIncNoTimeAttributes.size();
              boolean _notEquals_7 = (_size_7 != 0);
              if (_notEquals_7) {
                _builder.append("\t");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("typedef std::vector <");
                String _name_100 = table.getName();
                _builder.append(_name_100, "\t");
                _builder.append("Row* > TIME_ROWS;");
                _builder.newLineIfNotEmpty();
                _builder.append("\t");
                _builder.append("std::map<std::string, TIME_ROWS > context;");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("/** ");
                _builder.newLine();
                _builder.append("\t");
                _builder.append(" ");
                _builder.append("* Returns a string built by concatenating the ascii representation of the");
                _builder.newLine();
                _builder.append("\t");
                _builder.append(" ");
                _builder.append("* parameters values suffixed with a \"_\" character.");
                _builder.newLine();
                _builder.append("\t");
                _builder.append(" ");
                _builder.append("*/");
                _builder.newLine();
                _builder.append("\t");
                _builder.append(" ");
                _builder.append("std::string Key(");
                String _KeyNoAutoIncNoTimeCpp_1 = table.KeyNoAutoIncNoTimeCpp();
                _builder.append(_KeyNoAutoIncNoTimeCpp_1, "\t ");
                _builder.append(") ;");
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append("\t");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("std::vector <");
                String _name_101 = table.getName();
                _builder.append(_name_101, "\t");
                _builder.append("Row *> row;");
                _builder.newLineIfNotEmpty();
              }
            }
          } else {
            _builder.append("\t");
            _builder.newLine();
            {
              List<ASDMAttribute> _keyNoAutoIncNoTimeAttributes_1 = table.getKeyNoAutoIncNoTimeAttributes();
              int _size_8 = _keyNoAutoIncNoTimeAttributes_1.size();
              boolean _notEquals_8 = (_size_8 != 0);
              if (_notEquals_8) {
                _builder.append("\t");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("typedef std::vector <std::vector <");
                String _name_102 = table.getName();
                _builder.append(_name_102, "\t");
                _builder.append("Row* > > ID_TIME_ROWS;");
                _builder.newLineIfNotEmpty();
                _builder.append("\t");
                _builder.append("std::map<std::string, ID_TIME_ROWS > context;");
                _builder.newLine();
                _builder.append("\t");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("/** ");
                _builder.newLine();
                _builder.append("\t");
                _builder.append(" ");
                _builder.append("* Returns a string built by concatenating the ascii representation of the");
                _builder.newLine();
                _builder.append("\t");
                _builder.append(" ");
                _builder.append("* parameters values suffixed with a \"_\" character.");
                _builder.newLine();
                _builder.append("\t");
                _builder.append(" ");
                _builder.append("*/");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("std::string Key(");
                String _KeyNoAutoIncNoTimeCpp_2 = table.KeyNoAutoIncNoTimeCpp();
                _builder.append(_KeyNoAutoIncNoTimeCpp_2, "\t");
                _builder.append(");");
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append("\t");
                _builder.append("\t");
                _builder.newLine();
              }
            }
          }
        }
        _builder.append("\t");
        _builder.newLine();
        {
          List<ASDMAttribute> _keyNoAutoIncNoTimeAttributes_2 = table.getKeyNoAutoIncNoTimeAttributes();
          int _size_9 = _keyNoAutoIncNoTimeAttributes_2.size();
          boolean _notEquals_9 = (_size_9 != 0);
          if (_notEquals_9) {
            _builder.append("\t");
            _builder.append("/**");
            _builder.newLine();
            _builder.append("\t");
            _builder.append(" ");
            _builder.append("* Fills the vector vout (passed by reference) with pointers on elements of vin ");
            _builder.newLine();
            _builder.append("\t");
            _builder.append(" ");
            _builder.append("* whose attributes are equal to the corresponding parameters of the method.");
            _builder.newLine();
            _builder.append("\t");
            _builder.append(" ");
            _builder.append("*");
            _builder.newLine();
            _builder.append("\t");
            _builder.append(" ");
            _builder.append("*/");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("void getByKeyNoAutoIncNoTime(std::vector <");
            String _name_103 = table.getName();
            _builder.append(_name_103, "\t");
            _builder.append("Row*>& vin, std::vector <");
            String _name_104 = table.getName();
            _builder.append(_name_104, "\t");
            _builder.append("Row*>& vout,  ");
            String _KeyNoAutoIncNoTimeCpp_3 = table.KeyNoAutoIncNoTimeCpp();
            _builder.append(_KeyNoAutoIncNoTimeCpp_3, "\t");
            _builder.append(");");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void error() ; //throw(ConversionException);");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Populate this table from the content of a XML document that is required to");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* be conform to the XML schema defined for a ");
    String _name_105 = table.getName();
    _builder.append(_name_105, "\t ");
    _builder.append(" (");
    String _name_106 = table.getName();
    _builder.append(_name_106, "\t ");
    _builder.append("Table.xsd).");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("* @throws ConversionException");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void fromXML(std::string& xmlDoc) ;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("std::map<std::string, BinaryAttributeReaderFunctor *> unknownAttributes2Functors;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("* Private methods involved during the build of this table out of the content");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("* of file(s) containing an external representation of a ");
    String _name_107 = table.getName();
    _builder.append(_name_107, "\t  ");
    _builder.append(" table.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t  ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void setFromMIMEFile(const std::string& directory);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/*");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void openMIMEFile(const std::string& directory);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void setFromXMLFile(const std::string& directory);");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Serialize this into a stream of bytes and encapsulates that stream into a MIME message.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @returns a string containing the MIME message.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param byteOrder a const pointer to a static instance of the class ByteOrder.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("std::string toMIME(const asdm::ByteOrder* byteOrder=asdm::ByteOrder::Machine_Endianity);");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append(" \t");
    _builder.append("/** ");
    _builder.newLine();
    _builder.append("     ");
    _builder.append("* Extracts the binary part of a MIME message and deserialize its content");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* to fill this with the result of the deserialization. ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param mimeMsg the string containing the MIME message.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @throws ConversionException");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("void setFromMIME(const std::string & mimeMsg);");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("* Private methods involved during the export of this table into disk file(s).");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("std::string MIMEXMLPart(const asdm::ByteOrder* byteOrder=asdm::ByteOrder::Machine_Endianity);");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("* Stores a representation (binary or XML) of this table into a file.");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("* Depending on the boolean value of its private field fileAsBin a binary serialization  of this (fileAsBin==true)  ");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("* will be saved in a file \"");
    String _name_108 = table.getName();
    _builder.append(_name_108, "\t  ");
    _builder.append(".bin\" or an XML representation (fileAsBin==false) will be saved in a file \"");
    String _name_109 = table.getName();
    _builder.append(_name_109, "\t  ");
    _builder.append(".xml\".");
    _builder.newLineIfNotEmpty();
    _builder.append("\t  ");
    _builder.append("* The file is always written in a directory whose name is passed as a parameter.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param directory The name of directory  where the file containing the table\'s representation will be saved.");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("void toFile(std::string directory);");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t   ");
    _builder.append("* Load the table in memory if necessary.");
    _builder.newLine();
    _builder.append("\t   ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("bool loadInProgress;");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("void checkPresenceInMemory() {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (!presentInMemory && !loadInProgress) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("loadInProgress = true;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("setFromFile(getContainer().getDirectory());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("presentInMemory = true;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("loadInProgress = false;");
    _builder.newLine();
    _builder.append("\t  \t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t  ");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Reads and parses a file containing a representation of a ");
    String _name_110 = table.getName();
    _builder.append(_name_110, "\t ");
    _builder.append("Table as those produced  by the toFile method.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("* This table is populated with the result of the parsing.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param directory The name of the directory containing the file te be read and parsed.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @throws ConversionException If any error occurs while reading the ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* files in the directory or parsing them.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("void setFromFile(const std::string& directory);");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("};");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("} // End namespace asdm");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#endif /* ");
    String _name_111 = table.getName();
    _builder.append(_name_111, "");
    _builder.append("Table_CLASS */");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    return _builder;
  }
}
