package org.xtext.alma.sdmdsl.generator.verbatimfiller;

import alma.hla.datamodel.meta.asdm.AlmaTable;
import alma.hla.datamodel.meta.asdm.AlmaTableContainer;
import java.util.List;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.xtext.alma.sdmdsl.generator.sdmfilesystem.SDMFileSystemAccess;

@SuppressWarnings("all")
public class Name2TableImpl {
  private AlmaTableContainer container = AlmaTableContainer.getInstance();
  
  public void doGenerate(final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    SDMFileSystemAccess sdmFsa = ((SDMFileSystemAccess) fsa);
    sdmFsa.setFile("/tmp/src/Name2TableDef.cpp");
    CharSequence _generateName2TableImpl = this.generateName2TableImpl();
    sdmFsa.generateFile(_generateName2TableImpl);
  }
  
  public CharSequence generateName2TableImpl() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ALMA - Atacama Large Millimeter Array");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* (c) European Southern Observatory, 2002");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* (c) Associated Universities Inc., 2002");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Copyright by ESO (in the framework of the ALMA collaboration),");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Copyright by AUI (in the framework of the ALMA collaboration),");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* All rights reserved.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* This library is free software; you can redistribute it and/or");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* modify it under the terms of the GNU Lesser General Public");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* License as published by the Free software Foundation; either");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* version 2.1 of the License, or (at your option) any later version.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* This library is distributed in the hope that it will be useful,");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* but WITHOUT ANY WARRANTY, without even the implied warranty of");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Lesser General Public License for more details.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* You should have received a copy of the GNU Lesser General Public");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* License along with this library; if not, write to the Free Software");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Foundation, Inc., 59 Temple Place, Suite 330, Boston,");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* MA 02111-1307  USA");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Warning!");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*  -------------------------------------------------------------------- ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* | This is generated code!  Do not modify this file.                  |");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* | If you do, all changes will be lost when the file is re-generated. |");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*  --------------------------------------------------------------------");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* File Name2Table.cpp");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("#include \"ASDMTables.h\"");
    _builder.newLine();
    _builder.append("#include \"Name2Table.h\"");
    _builder.newLine();
    _builder.append("#include \"boost/regex.hpp\"");
    _builder.newLine();
    _builder.append("#include \"boost/tokenizer.hpp\"");
    _builder.newLine();
    _builder.append("#include \"boost/algorithm/string.hpp\"");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#include <casa/Logging.h>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("using namespace boost; ");
    _builder.newLine();
    _builder.append("using namespace std;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("typedef tokenizer<boost::char_separator<char> > my_tok;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("map<string, ASDM_TABLE_BASE*> Name2Table::name2Table_;");
    _builder.newLine();
    _builder.append("bool Name2Table::init_ = Name2Table::init();");
    _builder.newLine();
    _builder.append("set<ASDM_TABLE_BASE*> Name2Table::table_;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("bool Name2Table::init() {");
    _builder.newLine();
    {
      List<AlmaTable> _sortedAlmaTable = this.container.sortedAlmaTable();
      for(final AlmaTable table : _sortedAlmaTable) {
        _builder.append("\t");
        _builder.append("name2Table_[\"");
        String _name = table.getName();
        _builder.append(_name, "\t");
        _builder.append("\"] = ASDM_");
        String _name_1 = table.getName();
        String _upperCase = _name_1.toUpperCase();
        _builder.append(_upperCase, "\t");
        _builder.append("::instance();\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("return true;");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("const set<ASDM_TABLE_BASE*>& Name2Table::find (const vector<string>& name, bool verbose) {");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("LogSinkInterface& lsif = LogSink::globalSink();");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("ostringstream infostream; ");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("// Empty the set just to be sure.");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("table_.clear();");
    _builder.newLine();
    _builder.append("  ");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("// Process each string given as input");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("string wildcard = \"*\";");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("for (unsigned int i = 0; i < name.size(); i++) {");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("// Replace any possible wildcard (*) by a sequences \'(.)*\'");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("string name_ = name.at(i);");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("char_separator<char> sep(\"*\", \"\", boost::keep_empty_tokens);");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("my_tok tokens(name_, sep);");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("ostringstream oss;");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("my_tok::iterator tok_iter = tokens.begin();");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("oss << *tok_iter ;");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("++tok_iter;");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("for (; tok_iter != tokens.end(); ++tok_iter)");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("oss << \"(.)*\" << *tok_iter ; ");
    _builder.newLine();
    _builder.newLine();
    _builder.append("    ");
    _builder.append("// Build a boost regexp out of this string written onto oss.");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("regex expression(oss.str().c_str()); ");
    _builder.newLine();
    _builder.newLine();
    _builder.append("    ");
    _builder.append("// For each table name");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("for (map<string, ASDM_TABLE_BASE*>::const_iterator iter = name2Table_.begin();");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("iter!= name2Table_.end(); iter++) {");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("// Is there a match between the string and the name of the table ?");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("cmatch what; ");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("if(regex_match(iter->first.c_str(), what, expression)) {");
    _builder.newLine();
    _builder.append("      \t");
    _builder.append("string uppername = iter->first; to_upper(uppername);");
    _builder.newLine();
    _builder.append("      \t");
    _builder.append("if (verbose) {");
    _builder.newLine();
    _builder.append("      \t\t");
    _builder.append("infostream.str(\"\");");
    _builder.newLine();
    _builder.append("      \t\t");
    _builder.append("infostream << \"An ASDM_\" << uppername << \" table will be added to the MS\" << endl;");
    _builder.newLine();
    _builder.append("      \t\t");
    _builder.append("LogSink::postGlobally(LogMessage(infostream.str(),");
    _builder.newLine();
    _builder.append("\t\t\t\t\t              \t\t\t ");
    _builder.append("LogOrigin(\"Name2Table\", ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t                                   ");
    _builder.append("\"find (const vector<string>& name, bool verbose=false)\", ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t                                   ");
    _builder.append("WHERE)));");
    _builder.newLine();
    _builder.append("      \t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("table_.insert(iter->second);");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("}");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("}");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("}");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("return table_;");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
}
