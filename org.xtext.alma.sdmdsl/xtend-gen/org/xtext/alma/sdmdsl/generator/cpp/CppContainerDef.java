package org.xtext.alma.sdmdsl.generator.cpp;

import alma.hla.datamodel.meta.asdm.AlmaTable;
import alma.hla.datamodel.meta.asdm.AlmaTableContainer;
import java.util.List;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.xtext.alma.sdmdsl.generator.sdmfilesystem.SDMFileSystemAccess;

@SuppressWarnings("all")
public class CppContainerDef {
  private AlmaTableContainer container = AlmaTableContainer.getInstance();
  
  public void doGenerate(final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    SDMFileSystemAccess sdmFsa = ((SDMFileSystemAccess) fsa);
    String _name = this.container.getName();
    String _plus = ("include/" + _name);
    String _plus_1 = (_plus + ".h");
    sdmFsa.setFile(_plus_1);
    CharSequence _generateCppContainerDef = this.generateCppContainerDef();
    sdmFsa.generateFile(_generateCppContainerDef);
  }
  
  public CharSequence generateCppContainerDef() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ALMA - Atacama Large Millimeter Array");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* (c) European Southern Observatory, 2002");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* (c) Associated Universities Inc., 2002");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Copyright by ESO (in the framework of the ALMA collaboration),");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Copyright by AUI (in the framework of the ALMA collaboration),");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* All rights reserved.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* This library is free software; you can redistribute it and/or");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* modify it under the terms of the GNU Lesser General Public");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* License as published by the Free software Foundation; either");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* version 2.1 of the License, or (at your option) any later version.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* This library is distributed in the hope that it will be useful,");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* but WITHOUT ANY WARRANTY, without even the implied warranty of");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Lesser General Public License for more details.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* You should have received a copy of the GNU Lesser General Public");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* License along with this library; if not, write to the Free Software");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Foundation, Inc., 59 Temple Place, Suite 330, Boston,");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* MA 02111-1307  USA");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Warning!");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*  -------------------------------------------------------------------- ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* | This is generated code!  Do not modify this file.                  |");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* | If you do, all changes will be lost when the file is re-generated. |");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*  --------------------------------------------------------------------");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* File ");
    String _name = this.container.getName();
    _builder.append(_name, " ");
    _builder.append(".h");
    _builder.newLineIfNotEmpty();
    _builder.append(" ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append(" ");
    _builder.newLine();
    _builder.append("#ifndef ");
    String _name_1 = this.container.getName();
    _builder.append(_name_1, "");
    _builder.append("_CLASS");
    _builder.newLineIfNotEmpty();
    _builder.append("#define ");
    String _name_2 = this.container.getName();
    _builder.append(_name_2, "");
    _builder.append("_CLASS");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("#include <vector>");
    _builder.newLine();
    _builder.append("#include <map>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#include <Representable.h>");
    _builder.newLine();
    _builder.append("#include <Entity.h>");
    _builder.newLine();
    _builder.append("#include <EntityId.h>");
    _builder.newLine();
    _builder.append("#include <ArrayTime.h>");
    _builder.newLine();
    _builder.append("#include <IllegalAccessException.h>");
    _builder.newLine();
    _builder.append("#include <InvalidArgumentException.h>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#include <Misc.h>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#ifndef WITHOUT_ACS");
    _builder.newLine();
    _builder.append("#include <asdmIDLC.h> /// <-------------------");
    _builder.newLine();
    _builder.append("//using namespace asdmIDL;   /// <-------------------");
    _builder.newLine();
    _builder.append("#endif");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("/*\\file ");
    String _name_3 = this.container.getName();
    String _plus = (_name_3 + ".h");
    _builder.append(_plus, "");
    _builder.newLineIfNotEmpty();
    _builder.append("    ");
    _builder.append("\\brief Generated from model\'s revision \"");
    String _revision = AlmaTableContainer.getRevision();
    _builder.append(_revision, "    ");
    _builder.append("\", branch \"");
    String _branch = AlmaTableContainer.getBranch();
    _builder.append(_branch, "    ");
    _builder.append("\"");
    _builder.newLineIfNotEmpty();
    _builder.append("*/");
    _builder.newLine();
    _builder.newLine();
    _builder.append("namespace asdm {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    {
      List<AlmaTable> _tables = this.container.getTables();
      for(final AlmaTable table : _tables) {
        _builder.append("\t");
        _builder.append("//class asdm::");
        String _name_4 = table.getName();
        _builder.append(_name_4, "\t");
        _builder.append("Table;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("class ");
        String _name_5 = table.getName();
        _builder.append(_name_5, "\t");
        _builder.append("Table;");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* The ");
    String _name_6 = this.container.getName();
    _builder.append(_name_6, "\t ");
    _builder.append(" class is the container for all tables.  Its instantation");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("* creates a complete set of tables.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Generated from model\'s revision \"");
    String _revision_1 = AlmaTableContainer.getRevision();
    _builder.append(_revision_1, "\t ");
    _builder.append("\", branch \"");
    String _branch_1 = AlmaTableContainer.getBranch();
    _builder.append(_branch_1, "\t ");
    _builder.append("\"");
    _builder.newLineIfNotEmpty();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//class ");
    String _name_7 = this.container.getName();
    _builder.append(_name_7, "\t");
    _builder.append(" : public Representable {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("class ");
    String _name_8 = this.container.getName();
    _builder.append(_name_8, "\t");
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public:");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Constructs an empty ");
    String _name_9 = this.container.getName();
    _builder.append(_name_9, "\t\t ");
    _builder.append(".");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    String _name_10 = this.container.getName();
    _builder.append(_name_10, "\t\t");
    _builder.append(" ();");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("virtual ~");
    String _name_11 = this.container.getName();
    _builder.append(_name_11, "\t\t");
    _builder.append(" ();");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    {
      List<AlmaTable> _tables_1 = this.container.getTables();
      for(final AlmaTable table_1 : _tables_1) {
        _builder.append("\t\t");
        _builder.append("/**");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append(" ");
        _builder.append("* Get the table ");
        String _name_12 = table_1.getName();
        _builder.append(_name_12, "\t\t ");
        _builder.append(".");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append(" ");
        _builder.append("* @return The table ");
        String _name_13 = table_1.getName();
        _builder.append(_name_13, "\t\t ");
        _builder.append(" as a ");
        String _name_14 = table_1.getName();
        _builder.append(_name_14, "\t\t ");
        _builder.append("Table.");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append(" ");
        _builder.append("*/");
        _builder.newLine();
        _builder.append("\t\t");
        String _name_15 = table_1.getName();
        _builder.append(_name_15, "\t\t");
        _builder.append("Table & get");
        String _name_16 = table_1.getName();
        _builder.append(_name_16, "\t\t");
        _builder.append(" () const;");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Produces the XML representation of * this.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @return a string containing the XML representation of this.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @throws ConversionException.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("virtual std::string toXML();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Write this ");
    String _name_17 = this.container.getName();
    _builder.append(_name_17, "\t\t ");
    _builder.append(" dataset to the specified directory");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t ");
    _builder.append("* as a collection of XML documents. ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @param directory The directory to which this dataset is written.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @throws ConversionException If any error occurs in converting the");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* table to XML and writing it to the directory.  This method will");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* not overwrite any existing file; a ConversionException is also");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* thrown in this case.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("void toXML(std::string directory) ;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Get an ASDM dataset, given the full path name of the ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* directory containing the XML version of the dataset.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @param xmlDirectory The full path name of the directory");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* containing this dataset.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @return The complete dataset that belongs to the container");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* in this directory.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @throws ConversionException If any error occurs reading the ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* files in the directory or in converting the tables from XML.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("virtual void fromXML(std::string xml) ;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Get an ");
    String _name_18 = this.container.getName();
    _builder.append(_name_18, "\t\t ");
    _builder.append(" dataset, given the full path name of the ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t ");
    _builder.append("* directory containing the XML version of the dataset.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @param xmlDirectory The full path name of the directory");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* containing this dataset.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @return The complete dataset that belongs to the container");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* in this directory.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @throws ConversionException If any error occurs reading the ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* files in the directory or in converting the tables from XML.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @deprecated");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("static ");
    String _name_19 = this.container.getName();
    _builder.append(_name_19, "\t\t");
    _builder.append(" *getFromXML(std::string xmlDirectory) ;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Serialize this into a stream of bytes and encapsulates that stream into a MIME message.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @returns a string containing the MIME message.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("std::string toMIME();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Extracts the binary part of a MIME message and deserialize its content");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* to fill this with the result of the deserialization. ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @param mimeMsg the string containing the MIME message.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @throws ConversionException");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("void setFromMIME(const std::string & );");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Write this ");
    String _name_20 = this.container.getName();
    _builder.append(_name_20, "\t\t ");
    _builder.append(" dataset to the specified directory");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t ");
    _builder.append("* as a collection of files.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* The container itself is written into an XML file. Each table of the container");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* having at least one row is written into a binary or an XML file depending on");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* the value of its \"fileAsBin\" private field.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @param directory The directory to which this dataset is written.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @throws ConversionException If any error occurs in converting the");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* container or any of its table.  This method will");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* not overwrite any existing file; a ConversionException is also");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* thrown in this case.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("void toFile(std::string directory);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Constructs totally or partially an ASDM dataset from its representation on disk.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Reads and parses a file (");
    String _name_21 = this.container.getName();
    _builder.append(_name_21, "\t\t ");
    _builder.append(".xml) containing the top level element of an ASDM.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t ");
    _builder.append("* Depending on the value of the boolean parameter loadTablesOnDemand the files containing the tables of");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* of the dataset are parsed to populate the dataset in memory immediately (false) or only when an application tries");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* to retrieve values from these tables (true).");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @param directory the name of the directory containing the files.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @param loadTablesOnDemand the tables are read and parsed immediately (false) or only when necessary (true).");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @throws ConversionException If any error occurs while reading the ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* files in the directory or parsing them.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/\t");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("void setFromFile(std::string directory, bool loadTablesOnDemand);");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Constructs an ASDM dataset from its representation on disk.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Reads and parses a file (");
    String _name_22 = this.container.getName();
    _builder.append(_name_22, "\t\t ");
    _builder.append(".xml) containing the top level element of an ASDM and then the files");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t ");
    _builder.append("* containing the representation on disk of the dataset\'s tables. On exit the dataset contains ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* all its tables in memory.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* <b>Backward compatibility.</b> This method presents some level of backward compatibility in the sense that it does its best to check if the dataset needs to be");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* transformed on the fly to the currently defined format prior being parsed and converted to its in memory representation. In order to do that it may need ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* to find the version information of the dataset and possibly its origin (i.e. which telescope has created it). Based on these informations it decides if");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* if a transformation has to be applied on the fly or if the dataset can be processed as is.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* <b>Helping backward compatibility</b> It may happen though that the algorithm which searches the dataset for its version information and its origin fails, while the user knows");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* that his/her dataset can be parsed. Then the method\'s behaviour can be controlled by using the second (and optional) argument <code>parse</code> which has ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* to be an instance of ASDMParseOptions. See below the description of this argument to undersand how to use it.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @param directory the name of the directory containing the files.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @param parse an instance of ASDMParseOptions which can be used to tailor the behaviour of the method. Please read the definition of ASDMParseOptions to");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* see how the logic of the method can be controlled. Most of the time it wont be necessary to specify this argument hence the fact it\'s optional. The typical ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* cases when one may have to use this argument are :");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* <ul>");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* <li> The version information cannot be derived from the content of the ASDM and you want to force the method to consider its format as the most recent one or the older one. ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* In such a case present an ASDMParseOptions instance onto which you have applied <code>.asV3()</code> or <code>.asV2()</code></li>. ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* <li> The origin of the data cannot be retrieved from the content of the ASDM; this happens when the dataset has not ExecbBlock table. Then one can help the method ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* by providing an instance of ASDMParseOptions onto which one of <code>.asALMA()</code>, <code>.asIRAM_PDB()</code>, <code>.asEVLA()</code> has been applied.</li>");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* <li> One wants to control if all the tables of the dataset must be parsed and put into memory during the execution of the method or if one prefers to load them on ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* on demand (i.e. a table is loaded in memory only the first time it\'s referred by the code.). One will present an instance of ASDMParseOptions onto which <code>.loadTablesOnDemand(b)</code>");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* hase been called where <code>b</code> is boolean value interpreted as follows :  <code>true</code> <->\"load on demand\" and <code>false</code> <-> \"load the tables immediately.\" </li>");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* </ul>");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @throws ConversionException If any error occurs while reading the ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* files in the directory or parsing them.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/\t");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("void setFromFile(std::string directory, const ASDMParseOptions&  parse=ASDMParseOptions());");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("* Returns a boolean value indicating if a control of the uniqueness of each row of each table is done during the execution");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("* of the method setFromFile.");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("* @return a bool.");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("* see the documentation of ASDMParseOptions about how to set this parameter. ");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("bool checkRowUniqueness() const ;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("#ifndef WITHOUT_ACS");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t\t  ");
    _builder.append("* Converts this ");
    String _name_23 = this.container.getName();
    _builder.append(_name_23, "\t\t\t  ");
    _builder.append(" into an ");
    String _name_24 = this.container.getName();
    _builder.append(_name_24, "\t\t\t  ");
    _builder.append("DataSetIDL CORBA structure");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t  ");
    _builder.append("* @return a pointer to a ");
    String _name_25 = this.container.getName();
    _builder.append(_name_25, "\t\t\t  ");
    _builder.append("DataSetIDL.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t  ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("virtual asdmIDL::ASDMDataSetIDL* toIDL();  \t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t\t ");
    _builder.append("* Builds an ");
    String _name_26 = this.container.getName();
    _builder.append(_name_26, "\t\t\t ");
    _builder.append(" out of its IDL representation.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t ");
    _builder.append("* @param x the IDL representation of the ");
    String _name_27 = this.container.getName();
    _builder.append(_name_27, "\t\t\t ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t\t ");
    _builder.append("* @throws DuplicateKey ");
    _builder.newLine();
    _builder.append("\t\t\t ");
    _builder.append("* @throws ConversionException");
    _builder.newLine();
    _builder.append("\t\t\t ");
    _builder.append("* @throws UniquenessViolationException");
    _builder.newLine();
    _builder.append("\t\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("virtual void fromIDL(asdmIDL::ASDMDataSetIDL* x); ");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("#endif");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("virtual Entity getEntity() const;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("virtual void setEntity(Entity e);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Meaningless, but required for the Representable interface.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("virtual std::string getName() const;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Meaningless, but required for the Representable interface.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("virtual unsigned int size() ;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("#ifndef WITHOUT_ACS");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t\t ");
    _builder.append("* Create an ");
    String _name_28 = this.container.getName();
    _builder.append(_name_28, "\t\t\t ");
    _builder.append(" dataset from the ALMA archive, given the");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t ");
    _builder.append("* entityId of its container.");
    _builder.newLine();
    _builder.append("\t\t\t ");
    _builder.append("* @param datasetId The entityId of the container of the dataset.");
    _builder.newLine();
    _builder.append("\t\t\t ");
    _builder.append("* @throws ConversionException");
    _builder.newLine();
    _builder.append("\t\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("static ");
    String _name_29 = this.container.getName();
    _builder.append(_name_29, "\t\t\t");
    _builder.append(" *fromArchive(EntityId datasetId) ;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("#endif");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("#ifndef WITHOUT_ACS");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t\t ");
    _builder.append("* Update an ");
    String _name_30 = this.container.getName();
    _builder.append(_name_30, "\t\t\t ");
    _builder.append(" dataset that already exists in the ALMA archive.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t ");
    _builder.append("* @throws ConversionException");
    _builder.newLine();
    _builder.append("\t\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("void updateArchive() const ;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("#endif");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Return the table, as a Representable object, with the");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* specified name.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @throws InvalidArgumentException");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("Representable &getTable(std::string tableName) ;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// ===> Attribute timeOfCreation");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* Get timeOfCreation.");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* @return timeOfCreation as ArrayTime");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("ArrayTime getTimeOfCreation() const;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t ");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* Set timeOfCreation with the specified ArrayTime.");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* @param timeOfCreation The ArrayTime value to which timeOfCreation is to be set.");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.newLine();
    _builder.append("\t \t\t");
    _builder.newLine();
    _builder.append("\t \t\t\t");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("void setTimeOfCreation (ArrayTime timeOfCreation);");
    _builder.newLine();
    _builder.append("\t  \t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// ===> Attribute version");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* Get version.");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* @return version as int");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("int getVersion() const;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t ");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* Set version with the specified int.");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* @param version The int value to which version is to be set.");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.newLine();
    _builder.append("\t \t\t");
    _builder.newLine();
    _builder.append("\t \t\t\t");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("void setVersion (int version);");
    _builder.newLine();
    _builder.append("\t  \t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// ===> Attribute xmlnsPrefix");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* Get xmlnsPrefix.");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* @return xmlnsPrefix as string");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("string getXmlnsPrefix() const;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t ");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* Set xmlnsPrefix with the specified string.");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("* @param xmlnsPrefix The string value to which xmlnsPrefix is to be set.");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.newLine();
    _builder.append("\t \t\t");
    _builder.newLine();
    _builder.append("\t \t\t\t");
    _builder.newLine();
    _builder.append("\t \t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("void setXmlnsPrefix (string xmlnsPrefix);");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*  \\enum Origin");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*  \\brief This enumeration lists the different possible origins for an ASDM present in memory. ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("enum Origin {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("FILE,  ///< The dataset has been constructed from its representation on disk. ");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("ARCHIVE, ///< The dataset has been constructed from its representation in the Archive. ");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("EX_NIHILO ///< The dataset has been constructed ex nihilo.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("};");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* Returns the origin of the dataset in memory.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* @return an ");
    String _name_31 = this.container.getName();
    _builder.append(_name_31, "\t\t ");
    _builder.append("::Origin value.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("Origin getOrigin() const ;");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("* Returns the ASDM\'s directory.");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("* @return a string containing path to the directory containing the external representation of the ASDM");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("* if it has been constructed from this representation or an empty string if it has been");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("* constructed ex nihilo.");
    _builder.newLine();
    _builder.append("\t\t  ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("std::string getDirectory() const ;");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("XSLTransformer & getXSLTransformer() ;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private:");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("bool archiveAsBin; // If true archive binary else archive XML");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("bool fileAsBin ; // If true file binary else file XML\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("bool hasBeenAdded;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("Origin origin;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("bool loadTablesOnDemand_;  // For a dataset which is stored on disk, convert and load in memory only the tables which are used by the code the first time they are referred to.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("bool checkRowUniqueness_;  // For a dataset which is stored on disk, when a table is converted and loaded in memory verify (true) or not (false) the fact that each row is unique.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("std::string directory_;    // The directory where the ASDM has been read. (left empty if the ASDM is only in memory)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    {
      List<AlmaTable> _tables_2 = this.container.getTables();
      for(final AlmaTable almaTable : _tables_2) {
        _builder.append("\t\t");
        _builder.append("/**");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append(" ");
        _builder.append("* The table ");
        String _name_32 = almaTable.getName();
        _builder.append(_name_32, "\t\t ");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append(" ");
        _builder.append("*/");
        _builder.newLine();
        _builder.append("\t\t");
        String _name_33 = almaTable.getName();
        _builder.append(_name_33, "\t\t");
        _builder.append("Table * ");
        String _LowerCase = almaTable.LowerCase();
        _builder.append(_LowerCase, "\t\t");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* The list of tables as Representable.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("std::vector<Representable *> table;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* The list of Entity objects representing the tables.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("//vector<Entity *> tableEntity;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("std::map<std::string, Entity> tableEntity;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("* This Container\'s entity.");
    _builder.newLine();
    _builder.append("\t\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("Entity entity;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// ===> Attribute timeOfCreation");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("ArrayTime timeOfCreation;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// ===> Attribute version");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("int version;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// ===> Attribute xmlnsPrefix");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("string xmlnsPrefix;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("void error() ; // throw(ConversionException);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("static std::string getXMLEntity(EntityId); // throw(ConversionException);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("static void putXMLEntity(std::string); // throw(ConversionException);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("XSLTransformer xslTransformer;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("};");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("} // End namespace asdm");
    _builder.newLine();
    _builder.append("#endif /* ");
    String _name_34 = this.container.getName();
    _builder.append(_name_34, "");
    _builder.append("_CLASS */");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
}
