package org.xtext.alma.sdmdsl.generator.cpp;

import alma.hla.datamodel.meta.asdm.ASDMAttribute;
import alma.hla.datamodel.meta.asdm.AlmaTableContainer;
import com.google.common.base.Objects;
import java.util.List;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import org.xtext.alma.sdmdsl.generator.sdmfilesystem.SDMFileSystemAccess;

@SuppressWarnings("all")
public class CppParserImpl {
  private AlmaTableContainer container = AlmaTableContainer.getInstance();
  
  public void doGenerate(final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    SDMFileSystemAccess sdmFsa = ((SDMFileSystemAccess) fsa);
    sdmFsa.setFile("src/Parser.cpp");
    CharSequence _generateParserImpl = this.generateParserImpl();
    sdmFsa.generateFile(_generateParserImpl);
  }
  
  public CharSequence generateParserImpl() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ALMA - Atacama Large Millimeter Array");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* (c) European Southern Observatory, 2002");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* (c) Associated Universities Inc., 2002");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Copyright by ESO (in the framework of the ALMA collaboration),");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Copyright by AUI (in the framework of the ALMA collaboration),");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* All rights reserved.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* This library is free software; you can redistribute it and/or");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* modify it under the terms of the GNU Lesser General Public");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* License as published by the Free software Foundation; either");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* version 2.1 of the License, or (at your option) any later version.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* This library is distributed in the hope that it will be useful,");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* but WITHOUT ANY WARRANTY, without even the implied warranty of");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Lesser General Public License for more details.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* You should have received a copy of the GNU Lesser General Public");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* License along with this library; if not, write to the Free Software");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Foundation, Inc., 59 Temple Place, Suite 330, Boston,");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* MA 02111-1307  USA");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Warning!");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*  -------------------------------------------------------------------- ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* | This is generated code!  Do not modify this file.                  |");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* | If you do, all changes will be lost when the file is re-generated. |");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*  --------------------------------------------------------------------");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* File Parser.cpp");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("#include <iostream>");
    _builder.newLine();
    _builder.append("#include <sstream>");
    _builder.newLine();
    _builder.append("#include <Base64.h>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#include <Parser.h>");
    _builder.newLine();
    _builder.append("#include <boost/property_tree/detail/xml_parser_utils.hpp>");
    _builder.newLine();
    _builder.append("#include <OutOfBoundsException.h>");
    _builder.newLine();
    _builder.append("#include <NumberFormatException.h>");
    _builder.newLine();
    _builder.append("#include <BooleanWrapper.h>");
    _builder.newLine();
    _builder.append("#include <ByteWrapper.h>");
    _builder.newLine();
    _builder.append("#include <CharacterWrapper.h>");
    _builder.newLine();
    _builder.append("#include <DoubleWrapper.h>");
    _builder.newLine();
    _builder.append("#include <FloatWrapper.h>");
    _builder.newLine();
    _builder.append("#include <IntegerWrapper.h>");
    _builder.newLine();
    _builder.append("#include <LongWrapper.h>");
    _builder.newLine();
    _builder.append("#include <ShortWrapper.h>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("using asdm::OutOfBoundsException;");
    _builder.newLine();
    _builder.append("using asdm::NumberFormatException;");
    _builder.newLine();
    _builder.append("using asdm::Boolean;");
    _builder.newLine();
    _builder.append("using asdm::Byte;");
    _builder.newLine();
    _builder.append("using asdm::Character;");
    _builder.newLine();
    _builder.append("using asdm::Double;");
    _builder.newLine();
    _builder.append("using asdm::Float;");
    _builder.newLine();
    _builder.append("using asdm::Integer;");
    _builder.newLine();
    _builder.append("using asdm::Long;");
    _builder.newLine();
    _builder.append("using asdm::Short;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("namespace asdm { ");
    _builder.newLine();
    _builder.append(" ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("string Parser::substring(const string &s, int a, int b) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return s.substr(a,(b - a));");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("  \t");
    _builder.append("string Parser::trim(const string &s) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("unsigned int i = 0;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("//while (s.at(i) == \' \' && i < s.length())");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("while (i < s.length() && s.at(i) == \' \')");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("++i;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (i == s.length())");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return \"\";");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("unsigned int j = s.length() - 1;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("//while (s.at(j) == \' \' && j > i)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("while (j > i && s.at(j) == \' \')");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("--j;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return substring(s,i,j + 1);\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append(" ");
    _builder.newLine();
    _builder.append(" \t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Get the portion of the string bounded by s1 and s2, inclusive.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param s1");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param s2");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("string Parser::getElement(const string &s1, const string &s2) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("beg = str.find(s1,pos);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (beg == string::npos)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return \"\";");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("end = str.find(s2,beg + s1.length());");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (end == string::npos)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return \"\";");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("pos = end + s2.length();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return substring(str,beg,end + s2.length());");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* Get the portion of the string bounded by s1 and s2, exclusive.");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param s1");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param s2");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @return");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("string Parser::getElementContent(const string &s1, const string &s2) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("string s = getElement(s1,s2);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (s.length() == 0)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return \"\";");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("s = substring(str,beg + s1.length(),end);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return trim(s);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("string Parser::getField(const string &field) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("beg = str.find(\"<\" + field + \">\");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (beg == string::npos)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return \"\";");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("beg += field.length() + 2;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("end = str.find(\"</\" + field + \">\",beg);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (end == string::npos)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return \"\";");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("string s = substring(str,beg,end);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return trim(s);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("string Parser::getField(const string &xml, const string &field) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("string::size_type b = xml.find(\"<\" + field + \">\");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (b == string::npos)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return \"\";");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("b += field.length() + 2;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("string::size_type e = xml.find(\"</\" + field + \">\",b);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (e == string::npos)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return \"\";");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("string s = substring(xml,b,e);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return trim(s);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//////////////////////////////////////////////////////");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// The follwing is a special case.");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//////////////////////////////////////////////////////");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("string Parser::getString(const string &name, const string &tableName, const string &xmlDoc) ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("{");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/*");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (xmlField == \"\")");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw  ConversionException(\"Error: Missing field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("name + \"\\\" or invalid syntax\",tableName);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return boost::property_tree::xml_parser::decode_char_entities(xmlField);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("vector<string> Parser::get1DString(const string &name, const string &tableName, const string &xmlDoc)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("{");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("vector<string> x(2);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (xmlField == \"\") {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw  ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("name + \"\\\": Invalid XML syntax\", tableName);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("StringTokenizer t(xmlField,\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("int ndim = Integer::parseInt(t.nextToken());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (ndim != 1) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("name + \"\\\": Invalid array format\", tableName);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("int dim0 = Integer::parseInt(t.nextToken());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("vector<string> value(dim0);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (dim0 == 0)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return value;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("t.nextToken(\"\\\"\"); // the space");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("value[0] = t.nextToken();");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (int i = 1; i < dim0; ++i) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("t.nextToken(); // the space\t\t");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("value[i] = boost::property_tree::xml_parser::decode_char_entities(t.nextToken());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (t.hasMoreTokens()) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("name + \"\\\": Syntax error.\", tableName);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return value;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} catch (NumberFormatException e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("name + \"\\\": \" + e.getMessage(), tableName);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} catch (OutOfBoundsException e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("name + \"\\\": Unexpected end of string\", tableName);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append(" ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("vector <vector<string> > Parser::get2DString(const string &name, const string &tableName, const string &xmlDoc)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("{");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (xmlField == \"\") {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("name + \"\\\": Invalid XML syntax\", tableName);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("StringTokenizer t(xmlField,\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("int ndim = Integer::parseInt(t.nextToken());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (ndim != 2) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("name + \"\\\": Invalid array format\", tableName);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("int dim0 = Integer::parseInt(t.nextToken());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("int dim1 = Integer::parseInt(t.nextToken());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("vector <vector<string> > value;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (dim0 == 0 || dim1 == 0)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return value;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("t.nextToken(\"\\\"\"); // the space");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("vector<string>v_aux;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (int i = 0; i < dim0; ++i) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("v_aux.clear();");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("for (int j = 0; j < dim1; ++j) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("v_aux.push_back( boost::property_tree::xml_parser::decode_char_entities(t.nextToken()));");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("if (i != dim0 - 1 || j != dim1 - 1)");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("t.nextToken(); // the space");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("value.push_back(v_aux);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (t.hasMoreTokens()) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("name + \"\\\": Syntax error.\", tableName);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return value;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} catch (NumberFormatException e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("name + \"\\\": \" + e.getMessage(), tableName);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} catch (OutOfBoundsException e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("name + \"\\\": Unexpected end of string\", tableName);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append(" ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("vector <vector <vector<string> > > Parser::get3DString(const string &name, const string &tableName, const string &xmlDoc)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("{");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("if (xmlField == \"\") {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("name + \"\\\": Invalid XML syntax\", tableName);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("StringTokenizer t(xmlField,\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("int ndim = Integer::parseInt(t.nextToken());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (ndim != 3) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("name + \"\\\": Invalid array format\", tableName);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("int dim0 = Integer::parseInt(t.nextToken());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("int dim1 = Integer::parseInt(t.nextToken());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("int dim2 = Integer::parseInt(t.nextToken());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("vector <vector <vector<string> > > value;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (dim0 == 0 || dim1 == 0 || dim2 == 0)");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("return value;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("t.nextToken(\"\\\"\"); // the space");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("vector<string> v_aux;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("vector<vector <string> > vv_aux;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (int i = 0; i < dim0; ++i) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("vv_aux.clear();");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("for (int j = 0; j < dim1; ++j) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("v_aux.clear();");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("for (int k = 0; k < dim2; ++k) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("v_aux.push_back( boost::property_tree::xml_parser::decode_char_entities(t.nextToken()));");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("if (i != dim0 - 1 || j != dim1 - 1 || k != dim2 - 1)");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t\t");
    _builder.append("t.nextToken(); // the space");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("vv_aux.push_back(v_aux);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("value.push_back(vv_aux);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if (t.hasMoreTokens()) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t\t");
    _builder.append("name + \"\\\": Syntax error.\", tableName);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("return value;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} catch (NumberFormatException e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("name + \"\\\": \" + e.getMessage(), tableName);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} catch (OutOfBoundsException e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("name + \"\\\": Unexpected end of string\", tableName);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// Generated methods for conversion to and from XML");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// data representations for all types, both primitive");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// and extended.  Also included are 1, 2, and 3 ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// dimensional arrays of these types.");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    {
      List<ASDMAttribute> _BasicType = this.container.BasicType();
      for(final ASDMAttribute attr : _BasicType) {
        _builder.append("\t");
        CharSequence _DefineType = this.DefineType(attr);
        _builder.append(_DefineType, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append(" \t");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("// Generated methods for conversion to and from XML");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// data representations with  a Base64 encoded content.");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// The methods are generated only for 1, 2 and 3 dimensional arrays");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// of data whose BasicType have a non null BaseWrapperName.");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// In practice this represents data whose type is one of the basic numeric types");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// or is built upon a basic numeric type. ");
    _builder.newLine();
    _builder.newLine();
    {
      List<ASDMAttribute> _BasicType_1 = this.container.BasicType();
      for(final ASDMAttribute attr_1 : _BasicType_1) {
        _builder.append("\t");
        CharSequence _DefineTypeBase64 = this.DefineTypeBase64(attr_1);
        _builder.append(_DefineTypeBase64, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append(" ");
    _builder.append("} // End namespace asdm");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence DefineType(final ASDMAttribute attr) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\t");
    _builder.append("// Field type: ");
    String _CppType = attr.CppType();
    _builder.append(_CppType, "\t");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void Parser::toXML(");
    String _CppType_1 = attr.CppType();
    _builder.append(_CppType_1, "\t");
    _builder.append(" data, const string &name, string &buf) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("buf.append(\"<\" + name + \"> \");");
    _builder.newLine();
    {
      boolean _isStringType = attr.isStringType();
      if (_isStringType) {
        _builder.append("\t\t");
        _builder.append("if (data.size()>0)");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("\t");
        _builder.append("buf.append(boost::property_tree::xml_parser::encode_char_entities(data));");
        _builder.newLine();
      } else {
        boolean _isArrayTimeIntervalType = attr.isArrayTimeIntervalType();
        if (_isArrayTimeIntervalType) {
          _builder.append("\t\t");
          _builder.append("//buf.append(data.getStart().toString()+\" \"+data.getDuration().toString());\t");
          _builder.newLine();
          _builder.append("\t\t");
          _builder.append("buf.append(data.getMidPoint().toString()+\" \"+data.getDuration().toString());");
          _builder.newLine();
        } else {
          boolean _isExtendedType = attr.isExtendedType();
          if (_isExtendedType) {
            _builder.append("\t\t");
            _builder.append("buf.append(data.toString());");
            _builder.newLine();
          } else {
            _builder.append("\t\t");
            _builder.append("buf.append(");
            String _WrapperType = attr.WrapperType();
            _builder.append(_WrapperType, "\t\t");
            _builder.append("::toString(data));");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("\t\t");
    _builder.append("buf.append(\" </\" + name + \"> \");");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    {
      if ((Objects.equal(attr.CppType(), "int") || Objects.equal(attr.CppType(), "Tag"))) {
        _builder.append("\t");
        _builder.append(" ");
        _builder.append("void Parser::toXML(set< ");
        String _CppType_2 = attr.CppType();
        _builder.append(_CppType_2, "\t ");
        _builder.append(" > data, const string &name, string &buf) {");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("buf.append(\"<\" + name + \"> \");");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("set < ");
        String _CppType_3 = attr.CppType();
        _builder.append(_CppType_3, "\t\t");
        _builder.append(" >::iterator iter;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("for (iter=data.begin(); iter!=data.end(); iter++) {");
        _builder.newLine();
        {
          boolean _isExtendedType_1 = attr.isExtendedType();
          if (_isExtendedType_1) {
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("buf.append((*iter).toString()+\" \");");
            _builder.newLine();
          } else {
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("buf.append(");
            String _WrapperType_1 = attr.WrapperType();
            _builder.append(_WrapperType_1, "\t\t\t");
            _builder.append("::toString(*iter));");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("buf.append(\" \");\t\t\t");
            _builder.newLine();
          }
        }
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("}\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void Parser::toXML(vector<");
    String _CppType_4 = attr.CppType();
    _builder.append(_CppType_4, "\t");
    _builder.append("> data, const string &name, string &buf) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("buf.append(\"<\" + name + \"> \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\"1 \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(Integer::toString(data.size()));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (unsigned int i = 0; i < data.size(); ++i) {");
    _builder.newLine();
    {
      boolean _isStringType_1 = attr.isStringType();
      if (_isStringType_1) {
        _builder.append("\t\t");
        _builder.append("buf.append(\"\\\"\");");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("if (data[i].size()>0)\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("\t");
        _builder.append("buf.append(boost::property_tree::xml_parser::encode_char_entities(data[i]));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("buf.append(\"\\\"\");");
        _builder.newLine();
      } else {
        boolean _isArrayTimeIntervalType_1 = attr.isArrayTimeIntervalType();
        if (_isArrayTimeIntervalType_1) {
          _builder.append("\t\t");
          _builder.append("//buf.append(data[i].getStart().toString()+\" \"+data[i].getDuration().toString()+\" \");\t");
          _builder.newLine();
          _builder.append("\t\t");
          _builder.append("buf.append(data[i].getMidPoint().toString()+\" \"+data[i].getDuration().toString()+\" \");\t");
          _builder.newLine();
        } else {
          boolean _isExtendedType_2 = attr.isExtendedType();
          if (_isExtendedType_2) {
            _builder.append("\t\t");
            _builder.append("buf.append(data[i].toString());");
            _builder.newLine();
          } else {
            _builder.append("\t\t");
            _builder.append("buf.append(");
            String _WrapperType_2 = attr.WrapperType();
            _builder.append(_WrapperType_2, "\t\t");
            _builder.append("::toString(data[i]));");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("\t\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" </\" + name + \"> \");");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void Parser::toXML(vector< vector<");
    String _CppType_5 = attr.CppType();
    _builder.append(_CppType_5, "\t");
    _builder.append("> > data, const string &name, string &buf) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("buf.append(\"<\" + name + \"> \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\"2 \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(Integer::toString(data.size()));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(Integer::toString(data[0].size()));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (unsigned int i = 0; i < data.size(); ++i) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (unsigned int j = 0; j < data[i].size(); ++j) {");
    _builder.newLine();
    {
      boolean _isStringType_2 = attr.isStringType();
      if (_isStringType_2) {
        _builder.append("\t\t\t\t");
        _builder.append("buf.append(\"\\\"\");");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("if(data[i][j].size()>0)\t");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("\t");
        _builder.append("buf.append(boost::property_tree::xml_parser::encode_char_entities(data[i][j]));");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("buf.append(\"\\\"\");");
        _builder.newLine();
      } else {
        boolean _isArrayTimeIntervalType_2 = attr.isArrayTimeIntervalType();
        if (_isArrayTimeIntervalType_2) {
          _builder.append("\t\t\t\t");
          _builder.append("//buf.append(data[i][j].getStart().toString()+\" \"+data[i][j].getDuration().toString()+\" \");\t");
          _builder.newLine();
          _builder.append("\t\t\t\t");
          _builder.append("buf.append(data[i][j].getMidPoint().toString()+\" \"+data[i][j].getDuration().toString()+\" \");\t\t\t\t");
          _builder.newLine();
        } else {
          boolean _isExtendedType_3 = attr.isExtendedType();
          if (_isExtendedType_3) {
            _builder.append("\t\t\t\t");
            _builder.append("buf.append(data[i][j].toString());");
            _builder.newLine();
          } else {
            _builder.append("\t\t\t\t");
            _builder.append("buf.append(");
            String _WrapperType_3 = attr.WrapperType();
            _builder.append(_WrapperType_3, "\t\t\t\t");
            _builder.append("::toString(data[i][j]));");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("\t\t\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" </\" + name + \"> \");");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void Parser::toXML(vector< vector< vector<");
    String _CppType_6 = attr.CppType();
    _builder.append(_CppType_6, "\t");
    _builder.append("> > > data, const string &name, string &buf) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("buf.append(\"<\" + name + \"> \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\"3 \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(Integer::toString(data.size()));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(Integer::toString(data[0].size()));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(Integer::toString(data[0][0].size()));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (unsigned int i = 0; i < data.size(); ++i) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (unsigned int j = 0; j < data[i].size(); ++j) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("for (unsigned int k = 0; k < data[i][j].size(); ++k) {");
    _builder.newLine();
    {
      boolean _isStringType_3 = attr.isStringType();
      if (_isStringType_3) {
        _builder.append("\t\t\t\t\t");
        _builder.append("buf.append(\"\\\"\");");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("if (data[i][j][k].size() > 0)\t");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("\t");
        _builder.append("buf.append(boost::property_tree::xml_parser::encode_char_entities(data[i][j][k]));");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("buf.append(\"\\\"\");");
        _builder.newLine();
      } else {
        boolean _isArrayTimeIntervalType_3 = attr.isArrayTimeIntervalType();
        if (_isArrayTimeIntervalType_3) {
          _builder.append("\t\t\t\t\t");
          _builder.append("//buf.append(data[i][j][k].getStart().toString()+\" \"+data[i][j][k].getDuration().toString()+\" \");\t");
          _builder.newLine();
          _builder.append("\t\t\t\t\t");
          _builder.append("buf.append(data[i][j][k].getMidPoint().toString()+\" \"+data[i][j][k].getDuration().toString()+\" \");\t");
          _builder.newLine();
        } else {
          boolean _isExtendedType_4 = attr.isExtendedType();
          if (_isExtendedType_4) {
            _builder.append("\t\t\t\t\t");
            _builder.append("buf.append(data[i][j][k].toString());");
            _builder.newLine();
          } else {
            _builder.append("\t\t\t\t\t");
            _builder.append("buf.append(");
            String _WrapperType_4 = attr.WrapperType();
            _builder.append(_WrapperType_4, "\t\t\t\t\t");
            _builder.append("::toString(data[i][j][k]));");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("\t\t\t\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" </\" + name + \"> \");");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("void Parser::toXML(vector<vector< vector< vector<");
    String _CppType_7 = attr.CppType();
    _builder.append(_CppType_7, "\t");
    _builder.append("> > > >data, const string &name, string &buf) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("buf.append(\"<\" + name + \"> \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\"4 \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(Integer::toString(data.size()));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(Integer::toString(data[0].size()));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(Integer::toString(data[0][0].size()));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(Integer::toString(data[0][0][0].size()));");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (unsigned int i = 0; i < data.size(); ++i) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for (unsigned int j = 0; j < data[i].size(); ++j) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("for (unsigned int k = 0; k < data[i][j].size(); ++k) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("for (unsigned int l = 0; l < data[i][j][k].size(); l++) {");
    _builder.newLine();
    {
      boolean _isStringType_4 = attr.isStringType();
      if (_isStringType_4) {
        _builder.append("\t\t\t\t\t\t");
        _builder.append("buf.append(\"\\\"\");");
        _builder.newLine();
        _builder.append("\t\t\t\t\t\t");
        _builder.append("if (data[i][j][k][l].size() > 0)\t");
        _builder.newLine();
        _builder.append("\t\t\t\t\t\t");
        _builder.append("\t");
        _builder.append("buf.append(boost::property_tree::xml_parser::encode_char_entities(data[i][j][k][l]));");
        _builder.newLine();
        _builder.append("\t\t\t\t\t\t");
        _builder.append("buf.append(\"\\\"\");");
        _builder.newLine();
      } else {
        boolean _isArrayTimeIntervalType_4 = attr.isArrayTimeIntervalType();
        if (_isArrayTimeIntervalType_4) {
          _builder.append("\t\t\t\t\t\t");
          _builder.append("//buf.append(data[i][j][k][l].getStart().toString()+\" \"+data[i][j][k][l].getDuration().toString()+\" \");");
          _builder.newLine();
          _builder.append("\t\t\t\t\t\t");
          _builder.append("buf.append(data[i][j][k][l].getMidPoint().toString()+\" \"+data[i][j][k][l].getDuration().toString()+\" \");\t\t");
          _builder.newLine();
        } else {
          boolean _isExtendedType_5 = attr.isExtendedType();
          if (_isExtendedType_5) {
            _builder.append("\t\t\t\t\t\t");
            _builder.append("buf.append(data[i][j][k][l].toString());");
            _builder.newLine();
          } else {
            _builder.append("\t\t\t\t\t\t");
            _builder.append("buf.append(");
            String _WrapperType_5 = attr.WrapperType();
            _builder.append(_WrapperType_5, "\t\t\t\t\t\t");
            _builder.append("::toString(data[i][j][k][l]));");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("\t\t\t\t\t\t");
    _builder.append("buf.append(\" \");");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("buf.append(\" </\" + name + \"> \");");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    {
      boolean _isStringType_5 = attr.isStringType();
      boolean _not = (!_isStringType_5);
      if (_not) {
        _builder.append("\t");
        _builder.newLine();
        {
          if ((attr.CppType().equals("int") || attr.CppType().equals("Tag"))) {
            _builder.append("\t");
            _builder.append("set< ");
            String _CppType_8 = attr.CppType();
            _builder.append(_CppType_8, "\t");
            _builder.append(" >  Parser::get");
            String _TypeSet = attr.TypeSet();
            _builder.append(_TypeSet, "\t");
            _builder.append("(const string &name, const string &tableName, const string &xmlDoc) {");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("if (xmlField.length() == 0)");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("throw ConversionException(\"Error: Missing field \\\"\" + ");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t");
            _builder.append("name + \"\\\" or invalid syntax\",tableName);");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("StringTokenizer t(xmlField,\" \");");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("set < ");
            String _CppType_9 = attr.CppType();
            _builder.append(_CppType_9, "\t\t");
            _builder.append(" > result;");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("while (t.hasMoreTokens()) {");
            _builder.newLine();
            {
              String _CppType_10 = attr.CppType();
              boolean _equals = _CppType_10.equals("Tag");
              if (_equals) {
                _builder.append("\t");
                _builder.append("\t\t");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t\t");
                _builder.append("try {");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t\t");
                _builder.append("\t");
                _builder.append("result.insert(Tag::parseTag(t.nextToken()));");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t\t");
                _builder.append("}");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t\t");
                _builder.append("catch (TagFormatException e) {");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t\t");
                _builder.append("\t");
                _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t\t");
                _builder.append("\t");
                _builder.append("name + \"\\\": \" + e.getMessage(), tableName);\t\t\t\t");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t\t");
                _builder.append("}\t");
                _builder.newLine();
              } else {
                boolean _isExtendedType_6 = attr.isExtendedType();
                if (_isExtendedType_6) {
                  _builder.append("\t");
                  _builder.append("\t\t");
                  _builder.append("result.insert(");
                  String _CppType_11 = attr.CppType();
                  _builder.append(_CppType_11, "\t\t\t");
                  _builder.append(" (t.nextToken()));");
                  _builder.newLineIfNotEmpty();
                } else {
                  _builder.append("\t");
                  _builder.append("\t\t");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t\t");
                  _builder.append("try {");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t\t");
                  _builder.append("\t");
                  String _CppType_12 = attr.CppType();
                  _builder.append(_CppType_12, "\t\t\t\t");
                  _builder.append(" data = ");
                  String _WrapperType_6 = attr.WrapperType();
                  _builder.append(_WrapperType_6, "\t\t\t\t");
                  _builder.append("::");
                  String _ParserType = attr.ParserType();
                  _builder.append(_ParserType, "\t\t\t\t");
                  _builder.append("(xmlField);");
                  _builder.newLineIfNotEmpty();
                  _builder.append("\t");
                  _builder.append("\t\t");
                  _builder.append("\t");
                  _builder.append("result.insert(data);");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t\t");
                  _builder.append("} catch (NumberFormatException e) {");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t\t");
                  _builder.append("\t");
                  _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t\t");
                  _builder.append("\t");
                  _builder.append("name + \"\\\": \" + e.getMessage(), tableName);");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t\t");
                  _builder.append("}");
                  _builder.newLine();
                }
              }
            }
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("}");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("return result;\t\t\t\t\t\t\t");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("}");
            _builder.newLine();
          }
        }
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        String _CppType_13 = attr.CppType();
        _builder.append(_CppType_13, "\t");
        _builder.append(" Parser::get");
        String _WrapperType_7 = attr.WrapperType();
        _builder.append(_WrapperType_7, "\t");
        _builder.append("(const string &name, const string &tableName, const string &xmlDoc) ");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("{");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("if (xmlField.length() == 0)");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Missing field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\" or invalid syntax\",tableName);");
        _builder.newLine();
        {
          boolean _isCharType = attr.isCharType();
          if (_isCharType) {
            _builder.append("\t");
            _builder.append("\t");
            _builder.append("return xmlField.at(0);");
            _builder.newLine();
          } else {
            boolean _isArrayTimeIntervalType_5 = attr.isArrayTimeIntervalType();
            if (_isArrayTimeIntervalType_5) {
              _builder.append("\t");
              _builder.append("\t");
              _builder.append("StringTokenizer t(xmlField,\" \");");
              _builder.newLine();
              _builder.append("\t");
              _builder.append("\t");
              _builder.append("//int64_t start = Long::parseLong(t.nextToken());");
              _builder.newLine();
              _builder.append("\t");
              _builder.append("\t");
              _builder.append("int64_t l1 = Long::parseLong(t.nextToken());");
              _builder.newLine();
              _builder.append("\t");
              _builder.append("\t");
              _builder.append("int64_t l2 = Long::parseLong(t.nextToken());");
              _builder.newLine();
              _builder.append("\t");
              _builder.append("\t");
              _builder.append("if ( ArrayTimeInterval::readStartTimeDurationInXML() ) ");
              _builder.newLine();
              _builder.append("\t");
              _builder.append("\t");
              _builder.append("\t");
              _builder.append("return ");
              String _CppType_14 = attr.CppType();
              _builder.append(_CppType_14, "\t\t\t");
              _builder.append(" (l1, l2);");
              _builder.newLineIfNotEmpty();
              _builder.append("\t");
              _builder.append("\t");
              _builder.append("else ");
              _builder.newLine();
              _builder.append("\t");
              _builder.append("\t");
              _builder.append("\t");
              _builder.append("return ");
              String _CppType_15 = attr.CppType();
              _builder.append(_CppType_15, "\t\t\t");
              _builder.append(" (l1 - l2 / 2, l2);");
              _builder.newLineIfNotEmpty();
            } else {
              String _CppType_16 = attr.CppType();
              boolean _equals_1 = _CppType_16.equals("Tag");
              if (_equals_1) {
                _builder.append("\t");
                _builder.append("\t");
                _builder.append("try {");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t");
                _builder.append("\t");
                _builder.append("return Tag::parseTag(xmlField);");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t");
                _builder.append("}");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t");
                _builder.append("catch (TagFormatException e) {");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t");
                _builder.append("\t");
                _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t");
                _builder.append("\t");
                _builder.append("name + \"\\\": \" + e.getMessage(), tableName);");
                _builder.newLine();
                _builder.append("\t");
                _builder.append("\t");
                _builder.append("}");
                _builder.newLine();
              } else {
                boolean _isExtendedType_7 = attr.isExtendedType();
                if (_isExtendedType_7) {
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("try {\t");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("return ");
                  String _CppType_17 = attr.CppType();
                  _builder.append(_CppType_17, "\t\t\t");
                  _builder.append(" (xmlField);");
                  _builder.newLineIfNotEmpty();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("}");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("catch (InvalidArgumentException e) {");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("throw ConversionException(\"Error: message was \'\"+ ");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("\t                           ");
                  _builder.append("e.getMessage()+");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("\t                           ");
                  _builder.append("\"\'\",");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("\t                           ");
                  _builder.append("tableName);");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("}");
                  _builder.newLine();
                } else {
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("try {");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("\t");
                  String _CppType_18 = attr.CppType();
                  _builder.append(_CppType_18, "\t\t\t");
                  _builder.append(" data = ");
                  String _WrapperType_8 = attr.WrapperType();
                  _builder.append(_WrapperType_8, "\t\t\t");
                  _builder.append("::");
                  String _ParserType_1 = attr.ParserType();
                  _builder.append(_ParserType_1, "\t\t\t");
                  _builder.append("(xmlField);");
                  _builder.newLineIfNotEmpty();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("return data;");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("} catch (NumberFormatException e) {");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("\t\t");
                  _builder.append("name + \"\\\": \" + e.getMessage(), tableName);");
                  _builder.newLine();
                  _builder.append("\t");
                  _builder.append("\t");
                  _builder.append("}");
                  _builder.newLine();
                }
              }
            }
          }
        }
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("vector<");
        String _CppType_19 = attr.CppType();
        _builder.append(_CppType_19, "\t");
        _builder.append("> Parser::get1D");
        String _WrapperType_9 = attr.WrapperType();
        _builder.append(_WrapperType_9, "\t");
        _builder.append("(const string &name, const string &tableName, const string &xmlDoc)");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("{");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("if (xmlField.length() == 0) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Invalid XML syntax\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("StringTokenizer t(xmlField,\" \");");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("try {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int ndim = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (ndim != 1) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Invalid array format\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int dim0 = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("vector<");
        String _CppType_20 = attr.CppType();
        _builder.append(_CppType_20, "\t\t\t");
        _builder.append("> value (dim0);");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (dim0 == 0)");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("return value;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("for (int i = 0; i < dim0; ++i) {");
        _builder.newLine();
        {
          boolean _isArrayTimeIntervalType_6 = attr.isArrayTimeIntervalType();
          if (_isArrayTimeIntervalType_6) {
            _builder.append("\t");
            _builder.append("\t\t\t");
            _builder.append("int64_t l1 = Long::parseLong(t.nextToken());");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t");
            _builder.append("int64_t l2 = Long::parseLong(t.nextToken());");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t");
            _builder.append("if ( ArrayTimeInterval::readStartTimeDurationInXML() ) ");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t");
            _builder.append("\t");
            _builder.append("value[i] = ");
            String _CppType_21 = attr.CppType();
            _builder.append(_CppType_21, "\t\t\t\t\t");
            _builder.append(" (l1, l2);");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t\t\t");
            _builder.append("else ");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t");
            _builder.append("\t");
            _builder.append("value[i] = ");
            String _CppType_22 = attr.CppType();
            _builder.append(_CppType_22, "\t\t\t\t\t");
            _builder.append(" (l1 - l2 / 2, l2);");
            _builder.newLineIfNotEmpty();
          } else {
            String _CppType_23 = attr.CppType();
            boolean _equals_2 = _CppType_23.equals("Tag");
            if (_equals_2) {
              _builder.append("\t");
              _builder.append("\t\t\t");
              _builder.append("value[i] = Tag::parseTag(t.nextToken());");
              _builder.newLine();
            } else {
              boolean _isExtendedType_8 = attr.isExtendedType();
              if (_isExtendedType_8) {
                _builder.append("\t");
                _builder.append("\t\t\t");
                _builder.append("value[i] = ");
                String _WrapperType_10 = attr.WrapperType();
                _builder.append(_WrapperType_10, "\t\t\t\t");
                _builder.append("::get");
                String _WrapperType_11 = attr.WrapperType();
                _builder.append(_WrapperType_11, "\t\t\t\t");
                _builder.append("(t);");
                _builder.newLineIfNotEmpty();
              } else {
                boolean _isCharType_1 = attr.isCharType();
                if (_isCharType_1) {
                  _builder.append("\t");
                  _builder.append("\t\t\t");
                  _builder.append("value[i] = t.nextToken().at(0);");
                  _builder.newLine();
                } else {
                  _builder.append("\t");
                  _builder.append("\t\t\t");
                  _builder.append("value[i] = ");
                  String _WrapperType_12 = attr.WrapperType();
                  _builder.append(_WrapperType_12, "\t\t\t\t");
                  _builder.append("::");
                  String _ParserType_2 = attr.ParserType();
                  _builder.append(_ParserType_2, "\t\t\t\t");
                  _builder.append("(t.nextToken());");
                  _builder.newLineIfNotEmpty();
                }
              }
            }
          }
        }
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (t.hasMoreTokens()) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Syntax error.\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("return value;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (NumberFormatException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": \" + e.getMessage(), tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (OutOfBoundsException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw  ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": Unexpected end of string\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (TagFormatException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": \" + e.getMessage(), tableName);\t\t\t\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("}\t\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("vector< vector<");
        String _CppType_24 = attr.CppType();
        _builder.append(_CppType_24, "\t");
        _builder.append("> > Parser::get2D");
        String _WrapperType_13 = attr.WrapperType();
        _builder.append(_WrapperType_13, "\t");
        _builder.append("(const string &name, const string &tableName, const string &xmlDoc)");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("{");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("if (xmlField.length() == 0) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Invalid XML syntax\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("StringTokenizer t(xmlField,\" \");");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("try {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int ndim = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (ndim != 2) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Invalid array format\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int dim0 = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int dim1 = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("vector< vector<");
        String _CppType_25 = attr.CppType();
        _builder.append(_CppType_25, "\t\t\t");
        _builder.append("> > value;");
        _builder.newLineIfNotEmpty();
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (dim0 == 0 || dim1 == 0)");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("return value;");
        _builder.newLine();
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("vector<");
        String _CppType_26 = attr.CppType();
        _builder.append(_CppType_26, "\t\t\t");
        _builder.append("> v_aux;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("for (int i = 0; i < dim0; ++i) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("v_aux.clear();");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("for (int j = 0; j < dim1; ++j) {");
        _builder.newLine();
        {
          boolean _isArrayTimeIntervalType_7 = attr.isArrayTimeIntervalType();
          if (_isArrayTimeIntervalType_7) {
            _builder.append("\t");
            _builder.append("\t\t\t\t");
            _builder.append("int64_t l1 = Long::parseLong(t.nextToken());");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t");
            _builder.append("int64_t l2 = Long::parseLong(t.nextToken());");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t");
            _builder.append("if ( ArrayTimeInterval::readStartTimeDurationInXML() ) ");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t");
            _builder.append("\t");
            _builder.append("v_aux.push_back(");
            String _CppType_27 = attr.CppType();
            _builder.append(_CppType_27, "\t\t\t\t\t\t");
            _builder.append(" (l1, l2));");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t\t\t\t");
            _builder.append("else ");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t");
            _builder.append("\t");
            _builder.append("v_aux.push_back(");
            String _CppType_28 = attr.CppType();
            _builder.append(_CppType_28, "\t\t\t\t\t\t");
            _builder.append(" (l1 - l2 / 2, l2));");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t\t\t\t");
            _builder.append("\t\t\t\t\t");
            _builder.newLine();
          } else {
            String _CppType_29 = attr.CppType();
            boolean _equals_3 = _CppType_29.equals("Tag");
            if (_equals_3) {
              _builder.append("\t");
              _builder.append("\t\t\t\t");
              _builder.append("v_aux.push_back(Tag::parseTag(t.nextToken()));");
              _builder.newLine();
            } else {
              boolean _isExtendedType_9 = attr.isExtendedType();
              if (_isExtendedType_9) {
                _builder.append("\t");
                _builder.append("\t\t\t\t");
                _builder.append("v_aux.push_back(");
                String _WrapperType_14 = attr.WrapperType();
                _builder.append(_WrapperType_14, "\t\t\t\t\t");
                _builder.append("::get");
                String _WrapperType_15 = attr.WrapperType();
                _builder.append(_WrapperType_15, "\t\t\t\t\t");
                _builder.append("(t));");
                _builder.newLineIfNotEmpty();
              } else {
                boolean _isCharType_2 = attr.isCharType();
                if (_isCharType_2) {
                  _builder.append("\t");
                  _builder.append("\t\t\t\t");
                  _builder.append("v_aux.push_back(t.nextToken().at(0));");
                  _builder.newLine();
                } else {
                  _builder.append("\t");
                  _builder.append("\t\t\t\t");
                  _builder.append("v_aux.push_back(");
                  String _WrapperType_16 = attr.WrapperType();
                  _builder.append(_WrapperType_16, "\t\t\t\t\t");
                  _builder.append("::");
                  String _ParserType_3 = attr.ParserType();
                  _builder.append(_ParserType_3, "\t\t\t\t\t");
                  _builder.append("(t.nextToken()));");
                  _builder.newLineIfNotEmpty();
                }
              }
            }
          }
        }
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("value.push_back(v_aux);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (t.hasMoreTokens()) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Syntax error.\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("return value;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (NumberFormatException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": \" + e.getMessage(), tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (OutOfBoundsException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw  ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": Unexpected end of string\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (TagFormatException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": \" + e.getMessage(), tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("vector< vector< vector<");
        String _CppType_30 = attr.CppType();
        _builder.append(_CppType_30, "\t");
        _builder.append("> > > Parser::get3D");
        String _WrapperType_17 = attr.WrapperType();
        _builder.append(_WrapperType_17, "\t");
        _builder.append("(const string &name, const string &tableName, const string &xmlDoc)");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("{");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("if (xmlField.length() == 0) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Invalid XML syntax\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("StringTokenizer t(xmlField,\" \");");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("try {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int ndim = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (ndim != 3) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Invalid array format\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int dim0 = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int dim1 = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int dim2 = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("vector< vector< vector<");
        String _CppType_31 = attr.CppType();
        _builder.append(_CppType_31, "\t\t\t");
        _builder.append("> > > value ;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (dim0 == 0 || dim1 == 0 || dim2 == 0)");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("return value;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("vector<vector<");
        String _CppType_32 = attr.CppType();
        _builder.append(_CppType_32, "\t\t\t");
        _builder.append("> > vv_aux;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("vector<");
        String _CppType_33 = attr.CppType();
        _builder.append(_CppType_33, "\t\t\t");
        _builder.append("> v_aux;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("for (int i = 0; i < dim0; ++i) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("vv_aux.clear();");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("for (int j = 0; j < dim1; ++j) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("v_aux.clear();");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("for (int k = 0; k < dim2; ++k) {");
        _builder.newLine();
        {
          boolean _isArrayTimeIntervalType_8 = attr.isArrayTimeIntervalType();
          if (_isArrayTimeIntervalType_8) {
            _builder.append("\t");
            _builder.append("\t\t\t\t\t");
            _builder.append("int64_t l1 = Long::parseLong(t.nextToken());");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t\t");
            _builder.append("int64_t l2 = Long::parseLong(t.nextToken());");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t\t");
            _builder.append("if ( ArrayTimeInterval::readStartTimeDurationInXML() ) ");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t\t");
            _builder.append("\t");
            _builder.append("v_aux.push_back(");
            String _CppType_34 = attr.CppType();
            _builder.append(_CppType_34, "\t\t\t\t\t\t\t");
            _builder.append(" (l1, l2));");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t\t\t\t\t");
            _builder.append("else ");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t\t");
            _builder.append("\t");
            _builder.append("v_aux.push_back(");
            String _CppType_35 = attr.CppType();
            _builder.append(_CppType_35, "\t\t\t\t\t\t\t");
            _builder.append(" (l1 - l2 / 2, l2));\t\t\t\t\t\t");
            _builder.newLineIfNotEmpty();
          } else {
            String _CppType_36 = attr.CppType();
            boolean _equals_4 = _CppType_36.equals("Tag");
            if (_equals_4) {
              _builder.append("\t");
              _builder.append("\t\t\t\t\t");
              _builder.append("v_aux.push_back(Tag::parseTag(t.nextToken()));\t\t\t\t\t\t\t");
              _builder.newLine();
            } else {
              boolean _isExtendedType_10 = attr.isExtendedType();
              if (_isExtendedType_10) {
                _builder.append("\t");
                _builder.append("\t\t\t\t\t");
                _builder.append("v_aux.push_back(");
                String _WrapperType_18 = attr.WrapperType();
                _builder.append(_WrapperType_18, "\t\t\t\t\t\t");
                _builder.append("::get");
                String _WrapperType_19 = attr.WrapperType();
                _builder.append(_WrapperType_19, "\t\t\t\t\t\t");
                _builder.append("(t));");
                _builder.newLineIfNotEmpty();
              } else {
                boolean _isCharType_3 = attr.isCharType();
                if (_isCharType_3) {
                  _builder.append("\t");
                  _builder.append("\t\t\t\t\t");
                  _builder.append("v_aux.push_back( t.nextToken().at(0));");
                  _builder.newLine();
                } else {
                  _builder.append("\t");
                  _builder.append("\t\t\t\t\t");
                  _builder.append("v_aux.push_back(");
                  String _WrapperType_20 = attr.WrapperType();
                  _builder.append(_WrapperType_20, "\t\t\t\t\t\t");
                  _builder.append("::");
                  String _ParserType_4 = attr.ParserType();
                  _builder.append(_ParserType_4, "\t\t\t\t\t\t");
                  _builder.append("(t.nextToken()));");
                  _builder.newLineIfNotEmpty();
                }
              }
            }
          }
        }
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("vv_aux.push_back(v_aux);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("value.push_back(vv_aux);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (t.hasMoreTokens()) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Syntax error.\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("return value;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (NumberFormatException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": \" + e.getMessage(), tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (OutOfBoundsException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw  ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": Unexpected end of string\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (TagFormatException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": \" + e.getMessage(), tableName);\t\t\t\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("}\t\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("vector< vector< vector< vector<");
        String _CppType_37 = attr.CppType();
        _builder.append(_CppType_37, "\t");
        _builder.append("> > > >Parser::get4D");
        String _WrapperType_21 = attr.WrapperType();
        _builder.append(_WrapperType_21, "\t");
        _builder.append("(const string &name, const string &tableName, const string &xmlDoc)");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("{");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("if (xmlField.length() == 0) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Invalid XML syntax\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("StringTokenizer t(xmlField,\" \");");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("try {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int ndim = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (ndim != 4) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Invalid array format\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int dim0 = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int dim1 = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int dim2 = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("int dim3 = Integer::parseInt(t.nextToken());");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("vector<vector< vector< vector<");
        String _CppType_38 = attr.CppType();
        _builder.append(_CppType_38, "\t\t\t");
        _builder.append("> > > >value;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (dim0 == 0 || dim1 == 0 || dim2 == 0 ||  dim3 == 0)");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("return value;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("vector<vector<vector<");
        String _CppType_39 = attr.CppType();
        _builder.append(_CppType_39, "\t\t\t");
        _builder.append("> > >vvv_aux;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("vector<vector< ");
        String _CppType_40 = attr.CppType();
        _builder.append(_CppType_40, "\t\t\t");
        _builder.append("> > vv_aux;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("vector<");
        String _CppType_41 = attr.CppType();
        _builder.append(_CppType_41, "\t\t\t");
        _builder.append("> v_aux;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("for (int i = 0; i < dim0; ++i) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("vvv_aux.clear();");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("for (int j = 0; j < dim1; ++j) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("vv_aux.clear();");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("for (int k = 0; k < dim2; ++k) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t\t");
        _builder.append("v_aux.clear();");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t\t");
        _builder.append("for (int l = 0; l < dim3; l++) {");
        _builder.newLine();
        {
          boolean _isArrayTimeIntervalType_9 = attr.isArrayTimeIntervalType();
          if (_isArrayTimeIntervalType_9) {
            _builder.append("\t");
            _builder.append("\t\t\t\t\t\t");
            _builder.append("int64_t l1 = Long::parseLong(t.nextToken());");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t\t\t");
            _builder.append("int64_t l2 = Long::parseLong(t.nextToken());");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t\t\t");
            _builder.append("if ( ArrayTimeInterval::readStartTimeDurationInXML() ) ");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t\t\t");
            _builder.append("\t");
            _builder.append("v_aux.push_back(");
            String _CppType_42 = attr.CppType();
            _builder.append(_CppType_42, "\t\t\t\t\t\t\t\t");
            _builder.append(" (l1, l2));");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t\t\t\t\t\t");
            _builder.append("else ");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t\t\t\t\t");
            _builder.append("\t");
            _builder.append("v_aux.push_back(");
            String _CppType_43 = attr.CppType();
            _builder.append(_CppType_43, "\t\t\t\t\t\t\t\t");
            _builder.append(" (l1 - l2 / 2, l2));\t");
            _builder.newLineIfNotEmpty();
          } else {
            String _CppType_44 = attr.CppType();
            boolean _equals_5 = _CppType_44.equals("Tag");
            if (_equals_5) {
              _builder.append("\t");
              _builder.append("\t\t\t\t\t\t");
              _builder.append("v_aux.push_back(Tag::parseTag(t.nextToken()));\t\t\t\t\t\t\t");
              _builder.newLine();
            } else {
              boolean _isExtendedType_11 = attr.isExtendedType();
              if (_isExtendedType_11) {
                _builder.append("\t");
                _builder.append("\t\t\t\t\t\t");
                _builder.append("v_aux.push_back(");
                String _WrapperType_22 = attr.WrapperType();
                _builder.append(_WrapperType_22, "\t\t\t\t\t\t\t");
                _builder.append("::get");
                String _WrapperType_23 = attr.WrapperType();
                _builder.append(_WrapperType_23, "\t\t\t\t\t\t\t");
                _builder.append("(t));");
                _builder.newLineIfNotEmpty();
              } else {
                boolean _isCharType_4 = attr.isCharType();
                if (_isCharType_4) {
                  _builder.append("\t");
                  _builder.append("\t\t\t\t\t\t");
                  _builder.append("v_aux.push_back( t.nextToken().at(0));");
                  _builder.newLine();
                } else {
                  _builder.append("\t");
                  _builder.append("\t\t\t\t\t\t");
                  _builder.append("v_aux.push_back(");
                  String _WrapperType_24 = attr.WrapperType();
                  _builder.append(_WrapperType_24, "\t\t\t\t\t\t\t");
                  _builder.append("::");
                  String _ParserType_5 = attr.ParserType();
                  _builder.append(_ParserType_5, "\t\t\t\t\t\t\t");
                  _builder.append("(t.nextToken()));");
                  _builder.newLineIfNotEmpty();
                }
              }
            }
          }
        }
        _builder.append("\t");
        _builder.append("\t\t\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t\t");
        _builder.append("vv_aux.push_back(v_aux);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("vvv_aux.push_back(vv_aux);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("value.push_back(vvv_aux);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("if (t.hasMoreTokens()) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t\t");
        _builder.append("name + \"\\\": Syntax error.\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("return value;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (NumberFormatException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": \" + e.getMessage(), tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (OutOfBoundsException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw  ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": Unexpected end of string\", tableName);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("} catch (TagFormatException e) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t\t");
        _builder.append("name + \"\\\": \" + e.getMessage(), tableName);\t\t\t\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("}\t\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
      }
    }
    return _builder;
  }
  
  public CharSequence DefineTypeBase64(final ASDMAttribute attr) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    {
      String _DataOutputType = attr.DataOutputType();
      boolean _notEquals = (!Objects.equal(_DataOutputType, null));
      if (_notEquals) {
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("void Parser::toXMLBase64(vector<");
        String _CppType = attr.CppType();
        _builder.append(_CppType, "\t");
        _builder.append("> data, const string &name, string &buf){");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("stringstream oss(stringstream::out | stringstream::binary);");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("string encoded;");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("buf.append(\"<\" + name + \"> \");");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("int ndim = 1;");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("int dim1 = data.size();");
        _builder.newLine();
        _builder.append(" ");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("oss.write((char *)&ndim, sizeof(int));");
        _builder.newLine();
        _builder.append(" \t\t");
        _builder.append("oss.write((char *)&dim1, sizeof(dim1));");
        _builder.newLine();
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("for (unsigned int i = 0; i < data.size(); i++)  {");
        _builder.newLine();
        {
          boolean _isExtendedType = attr.isExtendedType();
          if (_isExtendedType) {
            _builder.append("    \t\t");
            String _DataOutputType_1 = attr.DataOutputType();
            String _firstLower = StringExtensions.toFirstLower(_DataOutputType_1);
            _builder.append(_firstLower, "    \t\t");
            _builder.append(" v = data.at(i).get();");
            _builder.newLineIfNotEmpty();
          } else {
            String _SimpleCppType = attr.SimpleCppType();
            String _firstLower_1 = StringExtensions.toFirstLower(_SimpleCppType);
            _builder.append(_firstLower_1, "");
            _builder.append(" v = data.at(i);");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("      \t\t");
        _builder.append("oss.write((char *) &v, sizeof(v));");
        _builder.newLine();
        _builder.append("    \t");
        _builder.append("}");
        _builder.newLine();
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("Base64 b64;");
        _builder.newLine();
        _builder.append(" \t    ");
        _builder.append("b64.encode(oss.str(), encoded, false);");
        _builder.newLine();
        _builder.append(" \t    ");
        _builder.append("buf.append(encoded);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("buf.append(\" </\" + name + \"> \");\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("void Parser::toXMLBase64(vector< vector<");
        String _CppType_1 = attr.CppType();
        _builder.append(_CppType_1, "\t");
        _builder.append("> > data, const string &name, string &buf){");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("stringstream oss(stringstream::out | stringstream::binary);");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("string encoded;");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("buf.append(\"<\" + name + \"> \");");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("int ndim = 2;");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("int dim1 = data.size();");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("int dim2 = data.at(0).size();");
        _builder.newLine();
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("oss.write((char *)&ndim, sizeof(int));");
        _builder.newLine();
        _builder.append(" \t\t");
        _builder.append("oss.write((char *)&dim1, sizeof(dim1));");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("oss.write((char *)&dim2, sizeof(dim2));");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("for (unsigned int i = 0; i < data.size(); i++) ");
        _builder.newLine();
        _builder.append("    \t\t");
        _builder.append("for (unsigned int j = 0; j < data.at(0).size(); j++) {");
        _builder.newLine();
        {
          boolean _isExtendedType_1 = attr.isExtendedType();
          if (_isExtendedType_1) {
            _builder.append("\t    \t\t");
            String _DataOutputType_2 = attr.DataOutputType();
            String _firstLower_2 = StringExtensions.toFirstLower(_DataOutputType_2);
            _builder.append(_firstLower_2, "\t    \t\t");
            _builder.append(" v = data.at(i).at(j).get();");
            _builder.newLineIfNotEmpty();
          } else {
            String _SimpleCppType_1 = attr.SimpleCppType();
            String _firstLower_3 = StringExtensions.toFirstLower(_SimpleCppType_1);
            _builder.append(_firstLower_3, "");
            _builder.append(" v = data.at(i).at(j);");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("      \t\t\t");
        _builder.append("oss.write((char *) &v, sizeof(v));");
        _builder.newLine();
        _builder.append("    \t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("Base64 b64;");
        _builder.newLine();
        _builder.append(" \t    ");
        _builder.append("b64.encode(oss.str(), encoded, false);");
        _builder.newLine();
        _builder.append(" \t    ");
        _builder.append("buf.append(encoded);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("buf.append(\" </\" + name + \"> \");");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.newLine();
        _builder.newLine();
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("void Parser::toXMLBase64(vector< vector< vector<");
        String _CppType_2 = attr.CppType();
        _builder.append(_CppType_2, "\t");
        _builder.append("> > > data, const string &name, string &buf){");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("stringstream oss(stringstream::out | stringstream::binary);");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("string encoded;");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("buf.append(\"<\" + name + \"> \");");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("int ndim = 3;");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("int dim1 = data.size();");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("int dim2 = data.at(0).size();");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("int dim3 = data.at(0).at(0).size();");
        _builder.newLine();
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("oss.write((char *)&ndim, sizeof(int));");
        _builder.newLine();
        _builder.append(" \t\t");
        _builder.append("oss.write((char *)&dim1, sizeof(dim1));");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("oss.write((char *)&dim2, sizeof(dim2));");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("oss.write((char *)&dim3, sizeof(dim3));");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("for (unsigned int i = 0; i < data.size(); i++) ");
        _builder.newLine();
        _builder.append("    \t\t");
        _builder.append("for (unsigned int j = 0; j < data.at(0).size(); j++) ");
        _builder.newLine();
        _builder.append("    \t\t\t");
        _builder.append("for (unsigned int k = 0; k < data.at(0).at(0).size(); k++){");
        _builder.newLine();
        {
          boolean _isExtendedType_2 = attr.isExtendedType();
          if (_isExtendedType_2) {
            String _DataOutputType_3 = attr.DataOutputType();
            String _firstLower_4 = StringExtensions.toFirstLower(_DataOutputType_3);
            _builder.append(_firstLower_4, "");
            _builder.append(" v = data.at(i).at(j).at(k).get();");
            _builder.newLineIfNotEmpty();
          } else {
            String _SimpleCppType_2 = attr.SimpleCppType();
            String _firstLower_5 = StringExtensions.toFirstLower(_SimpleCppType_2);
            _builder.append(_firstLower_5, "");
            _builder.append(" v = data.at(i).at(j).at(k);");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("      \t\t\t\t");
        _builder.append("oss.write((char *) &v, sizeof(v));");
        _builder.newLine();
        _builder.append("    \t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("Base64 b64;");
        _builder.newLine();
        _builder.append(" \t    ");
        _builder.append("b64.encode(oss.str(), encoded, false);");
        _builder.newLine();
        _builder.append(" \t    ");
        _builder.append("buf.append(encoded);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("buf.append(\" </\" + name + \"> \");");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("void Parser::toXMLBase64(vector<vector< vector< vector<");
        String _CppType_3 = attr.CppType();
        _builder.append(_CppType_3, "\t");
        _builder.append("> > > >data, const string &name, string &buf){");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("stringstream oss(stringstream::out | stringstream::binary);");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("string encoded;");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("buf.append(\"<\" + name + \"> \");");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("int ndim = 3;");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("int dim1 = data.size();");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("int dim2 = data.at(0).size();");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("int dim3 = data.at(0).at(0).size();");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("int dim4 = data.at(0).at(0).at(0).size();");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("oss.write((char *)&ndim, sizeof(int));");
        _builder.newLine();
        _builder.append(" \t\t");
        _builder.append("oss.write((char *)&dim1, sizeof(dim1));");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("oss.write((char *)&dim2, sizeof(dim2));");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("oss.write((char *)&dim3, sizeof(dim3));");
        _builder.newLine();
        _builder.append("   \t\t");
        _builder.append("oss.write((char *)&dim4, sizeof(dim4));");
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("for (unsigned int i = 0; i < data.size(); i++) ");
        _builder.newLine();
        _builder.append("    \t\t");
        _builder.append("for (unsigned int j = 0; j < data.at(0).size(); j++) ");
        _builder.newLine();
        _builder.append("    \t\t\t");
        _builder.append("for (unsigned int k = 0; k < data.at(0).at(0).size(); k++)");
        _builder.newLine();
        _builder.append("    \t\t\t\t");
        _builder.append("for (unsigned int l = 0; l < data.at(0).at(0).at(0).size(); l++){");
        _builder.newLine();
        {
          boolean _isExtendedType_3 = attr.isExtendedType();
          if (_isExtendedType_3) {
            _builder.append("\t\t\t    \t\t");
            String _DataOutputType_4 = attr.DataOutputType();
            String _firstLower_6 = StringExtensions.toFirstLower(_DataOutputType_4);
            _builder.append(_firstLower_6, "\t\t\t    \t\t");
            _builder.append(" v = data.at(i).at(j).at(k).at(l).get();");
            _builder.newLineIfNotEmpty();
          } else {
            String _SimpleCppType_3 = attr.SimpleCppType();
            String _firstLower_7 = StringExtensions.toFirstLower(_SimpleCppType_3);
            _builder.append(_firstLower_7, "");
            _builder.append(" v = data.at(i).at(j).at(k).at(l);");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("      \t\t\t\t");
        _builder.append("oss.write((char *) &v, sizeof(v));");
        _builder.newLine();
        _builder.append("    \t\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.newLine();
        _builder.append("  \t\t");
        _builder.append("Base64 b64;");
        _builder.newLine();
        _builder.append(" \t    ");
        _builder.append("b64.encode(oss.str(), encoded, false);");
        _builder.newLine();
        _builder.append(" \t    ");
        _builder.append("buf.append(encoded);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("buf.append(\" </\" + name + \"> \");");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("#ifndef ");
        String _DataOutputType_5 = attr.DataOutputType();
        _builder.append(_DataOutputType_5, "\t");
        _builder.append("_CPP");
        _builder.newLineIfNotEmpty();
        {
          String _DataOutputType_6 = attr.DataOutputType();
          boolean _equals = _DataOutputType_6.equals("Byte");
          if (_equals) {
            _builder.append("\t\t");
            _builder.append("#define ");
            String _DataOutputType_7 = attr.DataOutputType();
            _builder.append(_DataOutputType_7, "\t\t");
            _builder.append("_CPP char");
            _builder.newLineIfNotEmpty();
          } else {
            String _DataOutputType_8 = attr.DataOutputType();
            boolean _equals_1 = _DataOutputType_8.equals("Boolean");
            if (_equals_1) {
              _builder.append("\t\t");
              _builder.append("#define ");
              String _DataOutputType_9 = attr.DataOutputType();
              _builder.append(_DataOutputType_9, "\t\t");
              _builder.append("_CPP bool");
              _builder.newLineIfNotEmpty();
            } else {
              String _DataOutputType_10 = attr.DataOutputType();
              boolean _equals_2 = _DataOutputType_10.equals("Long");
              if (_equals_2) {
                _builder.append("\t\t");
                _builder.append("#define ");
                String _DataOutputType_11 = attr.DataOutputType();
                _builder.append(_DataOutputType_11, "\t\t");
                _builder.append("_CPP int64_t");
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append("\t\t");
                _builder.append("#define ");
                String _DataOutputType_12 = attr.DataOutputType();
                _builder.append(_DataOutputType_12, "\t\t");
                _builder.append("_CPP ");
                String _DataOutputType_13 = attr.DataOutputType();
                String _firstLower_8 = StringExtensions.toFirstLower(_DataOutputType_13);
                _builder.append(_firstLower_8, "\t\t");
                _builder.append("\t");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
        _builder.append("\t");
        _builder.append("#endif");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.newLine();
        _builder.append("\t");
        _builder.append("#define TRYREAD(_stream_, _value_) _stream_.read((char*) &(_value_), sizeof(_value_));\t\\");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("if (_stream_.bad()) throw ConversionException(\"I/O error during read of \" + name, tableName);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("    ");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("vector<");
        String _CppType_4 = attr.CppType();
        _builder.append(_CppType_4, "\t");
        _builder.append(">& Parser::get1D");
        String _WrapperType = attr.WrapperType();
        _builder.append(_WrapperType, "\t");
        _builder.append("FromBase64(const string &name, const string &tableName, const string &xmlDoc, vector<");
        String _CppType_5 = attr.CppType();
        _builder.append(_CppType_5, "\t");
        _builder.append(">& attribute)");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("{");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("if (xmlField.length() == 0) {");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("name + \"\\\": Invalid XML syntax\", tableName);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("string decodedString;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("Base64 b64;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("b64.decode(xmlField, decodedString);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("stringstream iss(stringstream::in | stringstream::binary);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("iss.str(decodedString);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("attribute.clear();");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int ndim = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&ndim, sizeof(ndim));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,ndim);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int dim1 = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&dim1, sizeof(dim1));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,dim1);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("if (ndim != 1) {");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("throw ConversionException(\"Error while decoding Base64 representation of \\\"\" + name + \"\\\" : found \" + Integer::toString(ndim) + \" for the number of dimensions, expecting 1.\", tableName);");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("attribute.reserve(dim1);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        String _DataOutputType_14 = attr.DataOutputType();
        _builder.append(_DataOutputType_14, "\t\t");
        _builder.append("_CPP v;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("for (unsigned int i = 0; i < dim1; i++) {");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("//iss.read((char*) &v, sizeof(v));");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("TRYREAD(iss,v);");
        _builder.newLine();
        {
          boolean _isExtendedType_4 = attr.isExtendedType();
          if (_isExtendedType_4) {
            _builder.append("\t\t\t");
            _builder.append("attribute.push_back(");
            String _CppType_6 = attr.CppType();
            _builder.append(_CppType_6, "\t\t\t");
            _builder.append("(v));");
            _builder.newLineIfNotEmpty();
          } else {
            _builder.append("\t\t\t");
            _builder.append("attribute.push_back(v);");
            _builder.newLine();
          }
        }
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("return attribute;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("vector <vector<");
        String _CppType_7 = attr.CppType();
        _builder.append(_CppType_7, "\t");
        _builder.append("> >& Parser::get2D");
        String _WrapperType_1 = attr.WrapperType();
        _builder.append(_WrapperType_1, "\t");
        _builder.append("FromBase64(const string &name, const string &tableName, const string &xmlDoc, vector <vector<");
        String _CppType_8 = attr.CppType();
        _builder.append(_CppType_8, "\t");
        _builder.append("> >& attribute)");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("{");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("if (xmlField.length() == 0) {");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("name + \"\\\": Invalid XML syntax\", tableName);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("string decodedString;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("Base64 b64;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("b64.decode(xmlField, decodedString);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("stringstream iss(stringstream::in | stringstream::binary);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("iss.str(decodedString);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("attribute.clear();");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int ndim = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&ndim, sizeof(ndim));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,ndim);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("if (ndim != 2) {");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error while decoding Base64 representation of \\\"\" + name + \"\\\" : found \" + Integer::toString(ndim) + \" for the number of dimensions, expecting 2.\", tableName);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int dim1 = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&dim1, sizeof(dim1));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,dim1);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int dim2 = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&dim2, sizeof(dim2));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,dim2);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("attribute.reserve(dim1);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        String _DataOutputType_15 = attr.DataOutputType();
        _builder.append(_DataOutputType_15, "\t\t");
        _builder.append("_CPP v;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("vector<");
        String _CppType_9 = attr.CppType();
        _builder.append(_CppType_9, "\t\t");
        _builder.append("> aux2;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("aux2.reserve(dim2);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("for (unsigned int i = 0; i < dim1; i++) {");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("aux2.clear();");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("for (unsigned int j = 0; j < dim2; j++) {");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("//iss.read((char*) &v, sizeof(v));");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("TRYREAD(iss,v);");
        _builder.newLine();
        {
          boolean _isExtendedType_5 = attr.isExtendedType();
          if (_isExtendedType_5) {
            _builder.append("\t\t\t\t");
            _builder.append("aux2.push_back(");
            String _CppType_10 = attr.CppType();
            _builder.append(_CppType_10, "\t\t\t\t");
            _builder.append("(v));");
            _builder.newLineIfNotEmpty();
          } else {
            _builder.append("\t\t\t\t");
            _builder.append("aux2.push_back(v);");
            _builder.newLine();
          }
        }
        _builder.append("\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("attribute.push_back(aux2);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("return attribute;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("vector <vector <vector<");
        String _CppType_11 = attr.CppType();
        _builder.append(_CppType_11, "\t");
        _builder.append("> > >& Parser::get3D");
        String _WrapperType_2 = attr.WrapperType();
        _builder.append(_WrapperType_2, "\t");
        _builder.append("FromBase64(const string &name, const string &tableName, const string &xmlDoc, vector <vector <vector<");
        String _CppType_12 = attr.CppType();
        _builder.append(_CppType_12, "\t");
        _builder.append("> > >& attribute)");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("{");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("if (xmlField.length() == 0) {");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("name + \"\\\": Invalid XML syntax\", tableName);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("string decodedString;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("Base64 b64;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("b64.decode(xmlField, decodedString);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("stringstream iss(stringstream::in | stringstream::binary);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("iss.str(decodedString);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("attribute.clear();");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int ndim = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&ndim, sizeof(ndim));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss, ndim);\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("if (ndim != 3) {");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("throw ConversionException(\"Error while decoding Base64 representation of \\\"\" + name + \"\\\" : found \" + Integer::toString(ndim) + \" for the number of dimensions, expecting 3.\", tableName);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int dim1 = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&dim1, sizeof(dim1));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,dim1);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int dim2 = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&dim2, sizeof(dim2));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,dim2);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int dim3 = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&dim2, sizeof(dim3));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,dim3);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("attribute.reserve(dim1);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        String _DataOutputType_16 = attr.DataOutputType();
        _builder.append(_DataOutputType_16, "\t\t");
        _builder.append("_CPP v;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("vector <vector<");
        String _CppType_13 = attr.CppType();
        _builder.append(_CppType_13, "\t\t");
        _builder.append("> > aux2;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("vector<");
        String _CppType_14 = attr.CppType();
        _builder.append(_CppType_14, "\t\t");
        _builder.append("> aux3;\t\t");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("aux2.reserve(dim2);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("aux3.reserve(dim3);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("for (unsigned int i = 0; i < dim1; i++) {");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("aux2.clear();");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("for (unsigned int j = 0; j < dim2; j++) {");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("aux3.clear();");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("for (unsigned int k = 0; k < dim3; k++) {");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("//iss.read((char*) &v, sizeof(v));");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("TRYREAD(iss,v);");
        _builder.newLine();
        {
          boolean _isExtendedType_6 = attr.isExtendedType();
          if (_isExtendedType_6) {
            _builder.append("\t\t\t\t\t");
            _builder.append("aux3.push_back(");
            String _CppType_15 = attr.CppType();
            _builder.append(_CppType_15, "\t\t\t\t\t");
            _builder.append("(v));");
            _builder.newLineIfNotEmpty();
          } else {
            _builder.append("\t\t\t\t\t");
            _builder.append("aux3.push_back(v);");
            _builder.newLine();
          }
        }
        _builder.append("\t\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("aux2.push_back(aux3);");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("attribute.push_back(aux2);\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("return attribute;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append(";");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("vector <vector <vector <vector<");
        String _CppType_16 = attr.CppType();
        _builder.append(_CppType_16, "\t");
        _builder.append("> > > >& Parser::get4D");
        String _WrapperType_3 = attr.WrapperType();
        _builder.append(_WrapperType_3, "\t");
        _builder.append("FromBase64(const string &name, const string &tableName, const string &xmlDoc, vector< vector <vector <vector<");
        String _CppType_17 = attr.CppType();
        _builder.append(_CppType_17, "\t");
        _builder.append("> > > >& attribute)");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("{");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("string xmlField = Parser::getField(xmlDoc,name);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("if (xmlField.length() == 0) {");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("throw ConversionException(\"Error: Field \\\"\" + ");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("name + \"\\\": Invalid XML syntax\", tableName);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("string decodedString;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("Base64 b64;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("b64.decode(xmlField, decodedString);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("stringstream iss(stringstream::in | stringstream::binary);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("iss.str(decodedString);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("attribute.clear();");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int ndim = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&ndim, sizeof(ndim));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss, ndim);\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("if (ndim != 4) {");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("throw ConversionException(\"Error while decoding Base64 representation of \\\"\" + name + \"\\\" : found \" + Integer::toString(ndim) + \" for the number of dimensions, expecting 4.\", tableName);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int dim1 = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&dim1, sizeof(dim1));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,dim1);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int dim2 = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&dim2, sizeof(dim2));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,dim2);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int dim3 = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&dim2, sizeof(dim3));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,dim3);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("unsigned int dim4 = 0;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("//iss.read((char *)&dim2, sizeof(dim3));");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("TRYREAD(iss,dim3);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("attribute.reserve(dim1);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        String _DataOutputType_17 = attr.DataOutputType();
        _builder.append(_DataOutputType_17, "\t\t");
        _builder.append("_CPP v;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("vector <vector <vector<");
        String _CppType_18 = attr.CppType();
        _builder.append(_CppType_18, "\t\t");
        _builder.append("> > > aux2;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("vector <vector<");
        String _CppType_19 = attr.CppType();
        _builder.append(_CppType_19, "\t\t");
        _builder.append("> > aux3;");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("vector<");
        String _CppType_20 = attr.CppType();
        _builder.append(_CppType_20, "\t\t");
        _builder.append("> aux4;\t\t");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t");
        _builder.append("aux2.reserve(dim2);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("aux3.reserve(dim3);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("aux4.reserve(dim4);");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("for (unsigned int i = 0; i < dim1; i++) {");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("aux2.clear();");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("for (unsigned int j = 0; j < dim2; j++) {");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("aux3.clear();");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("for (unsigned int k = 0; k < dim3; k++) {");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("aux4.clear();");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("for (unsigned int l = 0; l < dim4; l++) {");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("//iss.read((char*) &v, sizeof(v));");
        _builder.newLine();
        _builder.append("\t\t\t\t\t\t");
        _builder.append("TRYREAD(iss,v);");
        _builder.newLine();
        {
          boolean _isExtendedType_7 = attr.isExtendedType();
          if (_isExtendedType_7) {
            _builder.append("\t\t\t\t\t\t");
            _builder.append("aux4.push_back(");
            String _CppType_21 = attr.CppType();
            _builder.append(_CppType_21, "\t\t\t\t\t\t");
            _builder.append("(v));");
            _builder.newLineIfNotEmpty();
          } else {
            _builder.append("\t\t\t\t\t\t");
            _builder.append("aux4.push_back(v);");
            _builder.newLine();
          }
        }
        _builder.append("\t\t\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t\t\t\t");
        _builder.append("aux3.push_back(aux4);");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("aux2.push_back(aux3);");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t\t");
        _builder.append("attribute.push_back(aux2);\t");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("return attribute;");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append(";");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}\t");
        _builder.newLine();
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
      }
    }
    return _builder;
  }
}
