/**
 * generated by Xtext
 */
package org.xtext.alma.sdmdsl.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.HashMap;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.xtext.alma.sdmdsl.sdmdsl.Dimensions;
import org.xtext.alma.sdmdsl.sdmdsl.Field;
import org.xtext.alma.sdmdsl.sdmdsl.SdmdslPackage;
import org.xtext.alma.sdmdsl.sdmdsl.Table;
import org.xtext.alma.sdmdsl.validation.AbstractSdmdslValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SdmdslValidator extends AbstractSdmdslValidator {
  /**
   * error list
   */
  public final static String DUPLICATE_FIELD_NAME = "duplicateFieldNameInTable";
  
  public final static String DUPLICATE_TABLE_NAME = "duplicateTableName";
  
  public final static String DIMENSION_INTEGER_TYPE_ERR = "nonIntegerTypeDimension";
  
  public final static String DIMENSION_INTEGER_FIELD_ERR = "nonIntegerFieldDimension";
  
  public final static String DIMENSION_INTEGER_TYPE_FIELD_ERR = "nonIntegerTypeFieldDimension";
  
  public final static String DIMENSION_FIELD_DIMENSION_ERR = "nonScalarDimension";
  
  public final static String FIELD_REFERENCE_TYPE_ERR = "notProperReferenceType";
  
  public final static String FIELD_REFERENCE_DIMENSION_ERR = "notProperReferenceDimension";
  
  public final static String FIELD_REFERENCE_TABLE_ERR = "cantFindReferedTable";
  
  /**
   * Validation of unique fields inside the table
   */
  @Check
  public void checkFieldNameIsUniqueInsideTable(final Table table) {
    HashMap<String, Field> map = new HashMap<String, Field>();
    EList<Field> _keyData = table.getKeyData();
    for (final Field f : _keyData) {
      String _name = f.getName();
      boolean _containsKey = map.containsKey(_name);
      if (_containsKey) {
        this.error("Field names must be unique", f, 
          SdmdslPackage.Literals.FIELD__NAME, 
          SdmdslValidator.DUPLICATE_FIELD_NAME);
        String _name_1 = f.getName();
        Field _get = map.get(_name_1);
        this.error("Field names must be unique", _get, 
          SdmdslPackage.Literals.FIELD__NAME, 
          SdmdslValidator.DUPLICATE_FIELD_NAME);
      } else {
        String _name_2 = f.getName();
        map.put(_name_2, f);
      }
    }
    EList<Field> _reqData = table.getReqData();
    for (final Field f_1 : _reqData) {
      String _name_3 = f_1.getName();
      boolean _containsKey_1 = map.containsKey(_name_3);
      if (_containsKey_1) {
        this.error("Field names must be unique", f_1, 
          SdmdslPackage.Literals.FIELD__NAME, 
          SdmdslValidator.DUPLICATE_FIELD_NAME);
        String _name_4 = f_1.getName();
        Field _get_1 = map.get(_name_4);
        this.error("Field names must be unique", _get_1, 
          SdmdslPackage.Literals.FIELD__NAME, 
          SdmdslValidator.DUPLICATE_FIELD_NAME);
      } else {
        String _name_5 = f_1.getName();
        map.put(_name_5, f_1);
      }
    }
    EList<Field> _optData = table.getOptData();
    for (final Field f_2 : _optData) {
      String _name_6 = f_2.getName();
      boolean _containsKey_2 = map.containsKey(_name_6);
      if (_containsKey_2) {
        this.error("Field names must be unique", f_2, 
          SdmdslPackage.Literals.FIELD__NAME, 
          SdmdslValidator.DUPLICATE_FIELD_NAME);
        String _name_7 = f_2.getName();
        Field _get_2 = map.get(_name_7);
        this.error("Field names must be unique", _get_2, 
          SdmdslPackage.Literals.FIELD__NAME, 
          SdmdslValidator.DUPLICATE_FIELD_NAME);
      } else {
        String _name_8 = f_2.getName();
        map.put(_name_8, f_2);
      }
    }
  }
  
  /**
   * Validation or refersToASlice, refersToOne, refersToMany
   */
  @Check
  public void referenceValidation(final Field field) {
    String _refersTo = field.getRefersTo();
    boolean _notEquals = (!Objects.equal(_refersTo, null));
    if (_notEquals) {
      boolean _isRefsToOne = field.isRefsToOne();
      if (_isRefsToOne) {
        String _primitiveType = field.getPrimitiveType();
        boolean _equals = Objects.equal(_primitiveType, null);
        if (_equals) {
          this.error("Field type must be Tag, because of refersToOne property", field, 
            SdmdslPackage.Literals.FIELD__PRIMITIVE_TYPE, 
            SdmdslValidator.FIELD_REFERENCE_TYPE_ERR);
        } else {
          String _primitiveType_1 = field.getPrimitiveType();
          boolean _notEquals_1 = (!Objects.equal(_primitiveType_1, "Tag"));
          if (_notEquals_1) {
            this.error("Field type must be Tag, because of refersToOne property", field, 
              SdmdslPackage.Literals.FIELD__PRIMITIVE_TYPE, 
              SdmdslValidator.FIELD_REFERENCE_TYPE_ERR);
          }
          EList<Dimensions> _dataDim = field.getDataDim();
          int _size = _dataDim.size();
          boolean _notEquals_2 = (_size != 0);
          if (_notEquals_2) {
            this.error("Field must be scalar, because of refersToOne property", field, 
              SdmdslPackage.Literals.FIELD__DATA_DIM, 
              SdmdslValidator.FIELD_REFERENCE_DIMENSION_ERR);
          }
        }
      }
      boolean _isRefsToMany = field.isRefsToMany();
      if (_isRefsToMany) {
        String _primitiveType_2 = field.getPrimitiveType();
        boolean _equals_1 = Objects.equal(_primitiveType_2, null);
        if (_equals_1) {
          this.error("Field type must be Tag, because of refersToMany property", field, 
            SdmdslPackage.Literals.FIELD__PRIMITIVE_TYPE, 
            SdmdslValidator.FIELD_REFERENCE_TYPE_ERR);
        } else {
          String _primitiveType_3 = field.getPrimitiveType();
          boolean _notEquals_3 = (!Objects.equal(_primitiveType_3, "Tag"));
          if (_notEquals_3) {
            this.error("Field type must be Tag, because of refersToMany property", field, 
              SdmdslPackage.Literals.FIELD__PRIMITIVE_TYPE, 
              SdmdslValidator.FIELD_REFERENCE_TYPE_ERR);
          }
          EList<Dimensions> _dataDim_1 = field.getDataDim();
          int _size_1 = _dataDim_1.size();
          boolean _equals_2 = (_size_1 == 0);
          if (_equals_2) {
            this.error("Field must be non scalar, because of refersToMany property", field, 
              SdmdslPackage.Literals.FIELD__DATA_DIM, 
              SdmdslValidator.FIELD_REFERENCE_DIMENSION_ERR);
          }
        }
      }
    }
  }
  
  /**
   * Validation of field dimensions
   */
  @Check
  public void fieldDimensionValidation(final Field field) {
    EList<Dimensions> _dataDim = field.getDataDim();
    Iterable<Dimensions> _filter = Iterables.<Dimensions>filter(_dataDim, Dimensions.class);
    for (final Dimensions obj : _filter) {
    }
  }
}
