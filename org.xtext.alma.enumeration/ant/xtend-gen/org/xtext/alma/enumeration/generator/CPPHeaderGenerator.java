package org.xtext.alma.enumeration.generator;

import com.google.common.base.Objects;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.xtext.alma.enumeration.enumeration.EnumType;
import org.xtext.alma.enumeration.enumeration.EnumValue;
import org.xtext.alma.enumeration.enumeration.EnumValueWithoutComma;
import org.xtext.alma.enumeration.generator.EnumerationAbstractGenerator;
import org.xtext.alma.enumeration.generator.enumfilesystem.EnumerationFileSystemAccess;

@SuppressWarnings("all")
public class CPPHeaderGenerator extends EnumerationAbstractGenerator {
  public void doGenerate(final EList<Resource> input, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    for (final Resource resource : input) {
      this.doGenerate(resource, fsa, context);
    }
  }
  
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    EnumerationFileSystemAccess enumFsa = ((EnumerationFileSystemAccess) fsa);
    EObject _resourceToEObject = this.resourceToEObject(resource);
    EnumType enumType = ((EnumType) _resourceToEObject);
    String _name = enumType.getName();
    String _plus = ("include/C" + _name);
    String _plus_1 = (_plus + ".h");
    enumFsa.setFile(_plus_1);
    CharSequence _generateCPPHeader = this.generateCPPHeader(enumType);
    enumFsa.generateFile(_generateCPPHeader);
  }
  
  public String documentation(final String doc) {
    StringBuilder sb = new StringBuilder(doc);
    sb.deleteCharAt(0);
    sb.deleteCharAt(0);
    int _length = sb.length();
    int _minus = (_length - 1);
    sb.deleteCharAt(_minus);
    int _length_1 = sb.length();
    int _minus_1 = (_length_1 - 1);
    sb.deleteCharAt(_minus_1);
    return sb.toString();
  }
  
  public EObject resourceToEObject(final Resource resource) {
    TreeIterator<EObject> _allContents = null;
    if (resource!=null) {
      _allContents=resource.getAllContents();
    }
    EObject _head = null;
    if (_allContents!=null) {
      _head=IteratorExtensions.<EObject>head(_allContents);
    }
    return _head;
  }
  
  public CharSequence generateCPPHeader(final EnumType enumType) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("#ifndef C");
    String _name = enumType.getName();
    _builder.append(_name, "");
    _builder.append("_H");
    _builder.newLineIfNotEmpty();
    _builder.append("#define C");
    String _name_1 = enumType.getName();
    _builder.append(_name_1, "");
    _builder.append("_H");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("/*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ALMA - Atacama Large Millimeter Array");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* (c) European Southern Observatory, 2002");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* (c) Associated Universities Inc., 2002");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Copyright by ESO (in the framework of the ALMA collaboration),");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Copyright by AUI (in the framework of the ALMA collaboration),");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* All rights reserved.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* This library is free software; you can redistribute it and/or");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* modify it under the terms of the GNU Lesser General Public");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* License as published by the Free software Foundation; either");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* version 2.1 of the License, or (at your option) any later version.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* This library is distributed in the hope that it will be useful,");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* but WITHOUT ANY WARRANTY, without even the implied warranty of");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Lesser General Public License for more details.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* You should have received a copy of the GNU Lesser General Public");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* License along with this library; if not, write to the Free Software");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Foundation, Inc., 59 Temple Place, Suite 330, Boston,");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* MA 02111-1307  USA");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* ");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* /////////////////////////////////////////////////////////////////");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* // WARNING!  DO NOT MODIFY THIS FILE!                          //");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* //  ---------------------------------------------------------  //");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* // | This is generated code!  Do not modify this file.       | //");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* // | Any changes will be lost when the file is re-generated. | //");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* //  ---------------------------------------------------------  //");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* /////////////////////////////////////////////////////////////////");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* File C");
    String _name_2 = enumType.getName();
    _builder.append(_name_2, " ");
    _builder.append(".h");
    _builder.newLineIfNotEmpty();
    _builder.append(" ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append(" ");
    _builder.newLine();
    _builder.append("#ifndef __cplusplus");
    _builder.newLine();
    _builder.append("#error This is a C++ include file and cannot be used from plain C");
    _builder.newLine();
    _builder.append("#endif");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#include <iostream>");
    _builder.newLine();
    _builder.append("#include <string>");
    _builder.newLine();
    _builder.append("#include <vector>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("/**");
    _builder.newLine();
    _builder.append("* A namespace to encapsulate the ");
    String _name_3 = enumType.getName();
    _builder.append(_name_3, "");
    _builder.append(" enumeration.");
    _builder.newLineIfNotEmpty();
    _builder.append("*/");
    _builder.newLine();
    _builder.append("#ifndef WITHOUT_ACS");
    _builder.newLine();
    _builder.append("#include <almaEnumerations_IFC.h>");
    _builder.newLine();
    _builder.append("#else");
    _builder.newLine();
    _builder.newLine();
    _builder.append("// This part mimics the behaviour of");
    _builder.newLine();
    _builder.append("namespace ");
    String _name_4 = enumType.getName();
    _builder.append(_name_4, "");
    _builder.append("Mod");
    _builder.newLineIfNotEmpty();
    _builder.append("{");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("//! ");
    String _name_5 = enumType.getName();
    _builder.append(_name_5, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("//! ");
    String _docEnum = null;
    if (enumType!=null) {
      _docEnum=enumType.getDocEnum();
    }
    String _documentation = this.documentation(_docEnum);
    _builder.append(_documentation, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("const char *const revision = \"");
    String _revision = enumType.getRevision();
    _builder.append(_revision, "\t");
    _builder.append("\";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("const int version = ");
    int _version = enumType.getVersion();
    _builder.append(_version, "\t");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("enum ");
    String _name_6 = enumType.getName();
    _builder.append(_name_6, "\t");
    _builder.append("{");
    _builder.newLineIfNotEmpty();
    {
      EList<EObject> _values = enumType.getValues();
      boolean _hasElements = false;
      for(final EObject literal : _values) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "\t\t");
        }
        {
          if ((literal instanceof EnumValueWithoutComma)) {
            _builder.append("\t\t");
            String _name_7 = ((EnumValueWithoutComma)literal).getName();
            _builder.append(_name_7, "\t\t");
            _builder.append(" ");
            {
              String _doc = ((EnumValueWithoutComma)literal).getDoc();
              boolean _notEquals = (!Objects.equal(_doc, null));
              if (_notEquals) {
                _builder.append(" ");
                String _doc_1 = ((EnumValueWithoutComma)literal).getDoc();
                String _documentation_1 = this.documentation(_doc_1);
                _builder.append(_documentation_1, "\t\t");
              }
            }
            _builder.newLineIfNotEmpty();
          }
        }
        {
          if ((literal instanceof EnumValue)) {
            _builder.append("\t\t");
            String _name_8 = ((EnumValue)literal).getName();
            _builder.append(_name_8, "\t\t");
            _builder.append(" ");
            {
              String _doc_2 = ((EnumValue)literal).getDoc();
              boolean _notEquals_1 = (!Objects.equal(_doc_2, null));
              if (_notEquals_1) {
                _builder.append(" ");
                String _doc_3 = ((EnumValue)literal).getDoc();
                String _documentation_2 = this.documentation(_doc_3);
                _builder.append(_documentation_2, "\t\t");
              }
            }
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("\t");
    _builder.append("};");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("typedef ");
    String _name_9 = enumType.getName();
    _builder.append(_name_9, "\t");
    _builder.append(" &");
    String _name_10 = enumType.getName();
    _builder.append(_name_10, "\t");
    _builder.append("_out;");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("#endif");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("namespace ");
    String _name_11 = enumType.getName();
    _builder.append(_name_11, "");
    _builder.append("Mod {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("std::ostream & operator << ( std::ostream & out, const ");
    String _name_12 = enumType.getName();
    _builder.append(_name_12, "\t");
    _builder.append("& value);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("std::istream & operator >> ( std::istream & in , ");
    String _name_13 = enumType.getName();
    _builder.append(_name_13, "\t");
    _builder.append("& value );");
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("/** ");
    _builder.newLine();
    _builder.append("* A helper class for the enumeration ");
    String _name_14 = enumType.getName();
    _builder.append(_name_14, "");
    _builder.append(".");
    _builder.newLineIfNotEmpty();
    _builder.append("* ");
    _builder.newLine();
    _builder.append("*/");
    _builder.newLine();
    _builder.append("class C");
    String _name_15 = enumType.getName();
    _builder.append(_name_15, "");
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("public:");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* Enumerators as strings.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("*/");
    _builder.newLine();
    {
      EList<EObject> _values_1 = enumType.getValues();
      for(final EObject literal_1 : _values_1) {
        {
          if ((literal_1 instanceof EnumValueWithoutComma)) {
            _builder.append("\t\t");
            _builder.append("static const std::string& s");
            String _name_16 = ((EnumValueWithoutComma)literal_1).getName();
            _builder.append(_name_16, "\t\t");
            _builder.append("; /*!< A const string equal to \"");
            String _name_17 = ((EnumValueWithoutComma)literal_1).getName();
            _builder.append(_name_17, "\t\t");
            _builder.append("\" .*/");
            _builder.newLineIfNotEmpty();
          }
        }
        {
          if ((literal_1 instanceof EnumValue)) {
            _builder.append("\t\t");
            _builder.append("static const std::string& s");
            String _name_18 = ((EnumValue)literal_1).getName();
            _builder.append(_name_18, "\t\t");
            _builder.append("; /*!< A const string equal to \"");
            String _name_19 = ((EnumValue)literal_1).getName();
            _builder.append(_name_19, "\t\t");
            _builder.append("\" .*/");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t\t");
        _builder.newLine();
      }
    }
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* Return the major version number as an int.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* @return an int.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("static int version();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* Return the revision as a string.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* @return a string");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("static std::string revision();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* Return the number of enumerators declared in ");
    String _name_20 = enumType.getName();
    _builder.append(_name_20, "\t\t");
    _builder.append("Mod::");
    String _name_21 = enumType.getName();
    _builder.append(_name_21, "\t\t");
    _builder.append(".");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("* @return an unsigned int.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("static unsigned int size();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* Returns an enumerator as a string.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* @param e an enumerator of ");
    String _name_22 = enumType.getName();
    _builder.append(_name_22, "\t\t");
    _builder.append("Mod::");
    String _name_23 = enumType.getName();
    _builder.append(_name_23, "\t\t");
    _builder.append(".");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("* @return a string.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("static std::string name(const ");
    String _name_24 = enumType.getName();
    _builder.append(_name_24, "\t\t");
    _builder.append("Mod::");
    String _name_25 = enumType.getName();
    _builder.append(_name_25, "\t\t");
    _builder.append("& e);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* Equivalent to the name method.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("static std::string toString(const ");
    String _name_26 = enumType.getName();
    _builder.append(_name_26, "\t\t");
    _builder.append("Mod::");
    String _name_27 = enumType.getName();
    _builder.append(_name_27, "\t\t");
    _builder.append("& f) { return name(f); }");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/** ");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* Returns vector of  all the enumerators as strings. ");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* The strings are stored in the vector in the same order than the enumerators are declared in the enumeration.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* @return a vector of string.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("static const std::vector<std::string> names();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// Create a ");
    String _name_28 = enumType.getName();
    _builder.append(_name_28, "\t\t");
    _builder.append(" enumeration object by specifying its name.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("static ");
    String _name_29 = enumType.getName();
    _builder.append(_name_29, "\t\t");
    _builder.append("Mod::");
    String _name_30 = enumType.getName();
    _builder.append(_name_30, "\t\t");
    _builder.append(" new");
    String _name_31 = enumType.getName();
    _builder.append(_name_31, "\t\t");
    _builder.append("(const std::string& name);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/*! Return a ");
    String _name_32 = enumType.getName();
    _builder.append(_name_32, "\t\t");
    _builder.append("\'s enumerator  given a string.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("* @param name the string representation of the enumerator.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("* @return a ");
    String _name_33 = enumType.getName();
    _builder.append(_name_33, "\t\t");
    _builder.append("Mod::");
    String _name_34 = enumType.getName();
    _builder.append(_name_34, "\t\t");
    _builder.append("\'s enumerator.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("* @throws a string containing an error message if no enumerator could be found for this name.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("static ");
    String _name_35 = enumType.getName();
    _builder.append(_name_35, "\t\t");
    _builder.append("Mod::");
    String _name_36 = enumType.getName();
    _builder.append(_name_36, "\t\t");
    _builder.append(" literal(const std::string& name);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("/*! Return a ");
    String _name_37 = enumType.getName();
    _builder.append(_name_37, "\t\t");
    _builder.append("\'s enumerator given an unsigned int.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("* @param i the index of the enumerator in ");
    String _name_38 = enumType.getName();
    _builder.append(_name_38, "\t\t");
    _builder.append("Mod::");
    String _name_39 = enumType.getName();
    _builder.append(_name_39, "\t\t");
    _builder.append(".");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("* @return a ");
    String _name_40 = enumType.getName();
    _builder.append(_name_40, "\t\t");
    _builder.append("Mod::");
    String _name_41 = enumType.getName();
    _builder.append(_name_41, "\t\t");
    _builder.append("\'s enumerator.");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("* @throws a string containing an error message if no enumerator could be found for this integer.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("static ");
    String _name_42 = enumType.getName();
    _builder.append(_name_42, "\t\t");
    _builder.append("Mod::");
    String _name_43 = enumType.getName();
    _builder.append(_name_43, "\t\t");
    _builder.append(" from_int(unsigned int i);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("private:");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("/* Not Implemented.  This is a pure static class. */");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("C");
    String _name_44 = enumType.getName();
    _builder.append(_name_44, "\t\t\t");
    _builder.append("();");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("C");
    String _name_45 = enumType.getName();
    _builder.append(_name_45, "\t\t\t");
    _builder.append("(const C");
    String _name_46 = enumType.getName();
    _builder.append(_name_46, "\t\t\t");
    _builder.append("&);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("C");
    String _name_47 = enumType.getName();
    _builder.append(_name_47, "\t\t\t");
    _builder.append("& operator=(const C");
    String _name_48 = enumType.getName();
    _builder.append(_name_48, "\t\t\t");
    _builder.append("&);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("static std::string badString(const std::string& name);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("static std::string badInt(unsigned int i);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("};");
    _builder.newLine();
    _builder.append("#endif /*!C");
    String _name_49 = enumType.getName();
    _builder.append(_name_49, "");
    _builder.append("_H*/");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
}
