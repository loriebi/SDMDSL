/*
 * ALMA - Atacama Large Millimeter Array
 * (c) European Southern Observatory, 2002
 * (c) Associated Universities Inc., 2002
 * Copyright by ESO (in the framework of the ALMA collaboration),
 * Copyright by AUI (in the framework of the ALMA collaboration),
 * All rights reserved.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY, without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307  USA
 * 
 * /////////////////////////////////////////////////////////////////
 * // WARNING!  DO NOT MODIFY THIS FILE!                          //
 * //  ---------------------------------------------------------  //
 * // | This is generated code!  Do not modify this file.       | //
 * // | Any changes will be lost when the file is re-generated. | //
 * //  ---------------------------------------------------------  //
 * /////////////////////////////////////////////////////////////////
 *
 * File almaEnumerations_IF.idl
 */
 
#ifndef ALMA_DATA_MODEL_ENUMERATION_IDL
#define ALMA_DATA_MODEL_ENUMERATION_IDL

#pragma prefix "alma"

/*! 
  \mainpage Presentation.
  
  \section intro Introduction.
  The different pieces of software related to the ALMA project naturally process or describe data whose types may cover all the range  from the basic types 
  (integer, float, etc.) up to compound types (arrays, classes...) by using the mechanisms offered by languages like C++, Java, IDL or Python.
 
  But there are situations which require the definitions of finite sets of constant values in order to represent properly  ideas like "the set of antenna makers" or
  "the set of possible antenna types" or  "the set of possible types for the data obtained during an observation". The languages mentioned above allow to create
  \e enumerated \e types which are \e user \e defined data types consisting of sets of constants called \e enumerations. The creation of an enumerated type actually defines
  an \e enumeration by its name (e.g. \c  AntennaType) and the set of its enumerators (e.g. \c GROUND_BASED  , \c SPACE_BASED, \c TRACKING_STN).
 
 \section enum-desc Enumerations definitions.
 Given that these enumerations are meant to be shared by all the software's contributors and that the software is for a large part a collection of distributed objects using CORBA
 as their middleware, IDL seemed to be the natural language to define these enumerations. The documentation which follows this introductory part lists \e all the enumerations 
 defined for the ALMA project in IDL. For each enumeration it provides its name and information about its nature as well as a commented list of its enumerators. 
 
\subsection namspace Encapsulating modules.
\subsubsection lit-conf Avoid literal conflicts.
 The possibility to use a same constant as an enumerator in more than one enumeration has been considered as desirable. Consequently each
 enumeration is \e protected by its own namespace. In IDL this is obtained by defining an encapsulating module for each defined enumeration. The name of 
 the module is the name of the enumeration suffixed by \c Mod (hence the list of packages in the documentation generated by doxygen).
 
 \subsubsection versioning Versioning requirements.
 Another benefit of encapsulating each enumeration in its own module is related to versioning. The versioning policy defined by the Schema Versioning Function Based Team
 assumes that each defined type is also formally described in an XML Schema and stipulates that each of those schemas must be qualified by a \e version \e number 
 and a \e revision \e identifier. In order to be fully useful the versioning information must be shared by the different representations of a same defined type, hence the necessity
 to intoduce such an information in the IDL representation of the enumerations.  This is done by declaring two constants \c version (int) and \c revision (string) in each module 
 containing the declaration of an enumeration. 
 
 In summary each enumeration  <I>EnumT</I> and its versioning information are packed in a module <I>EnumT</I><tt>Mod</tt> as in the following example :
 \verbatim
 module CorrelationModeMod {
 	 const unsigned long version = 1; 
 	 const string revision = "1.3";
 	 
 	 enum CorrelationMode {
 	 	CROSS_ONLY ,
 	 	AUTO_ONLY,
 	 	CROSS_AND_AUTO
 	};
};
\endverbatim


 
 \subsection howto How to display the  documentation attached to an enumeration.
 Unfold if necessary the "Package list" in the left window and click on a package name (e.g. %AntennaTypeMod) then you will get the documentation of
 the selected IDL module (\c %AntennaTypeMod) and of its enclosed enumeration (\c %AntennaType). 
 
 \section enum-impl Enumerations implementations.
 The implementations of the enumerations,  from their IDL descriptions, in different programming languages are obtained by using  the  tools 
 provided by the project. These tools apply the standard CORBA -> XXX mapping to generate the enumerations implementation in the language XXX 
 (those mappings are defined at http://www.omg.org/technology/documents/idl2x_spec_catalog.htm).
 
 \section enum-helper Helper classes.
 Helpers classes are generated, above the implementations directly produced by the different compilers IDL -> XXX , to provide the programmers with
 a level of functionalities as uniform as possible through the different languages -- C++, Java and Python. The APIs documentations of these helpers classes
 can be read here :
 <ul>
 <li><a href="../c++" target="_parent">The C++ helper classes.</a></li>
  <li><a href="../java" target="_parent">The Java helper classes.</a></li>
 </ul> 

*/



	/**
	*  A module to encapsulate the enumeration ACAPolarization.
	*/
	module ACAPolarizationMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration ACAPolarization : */
		/*!  ACA-specific ways to store pre-processed data products 
		 */
		
		enum ACAPolarization{
			ACA_STANDARD  !< Data product is the standard way (it is a standard observed Stokes parameter) ,
			ACA_XX_YY_SUM  !< ACA has calculated I by averaging XX and YY ,
			ACA_XX_50  !< ACA has averaged XX and XX delayed by half a FFT period ,
			ACA_YY_50  !< ACA has averaged YY and YY delayed by half a FFT period 
		};
		
		typedef sequence<ACAPolarization> SofACAPolarization;
		typedef sequence<sequence<ACAPolarization> > SofSofACAPolarization;
		typedef sequence<sequence<sequence<ACAPolarization> > > SofSofSofACAPolarization;
	
	};


	/**
	*  A module to encapsulate the enumeration AccumMode.
	*/
	module AccumModeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration AccumMode : */
		/*!  Accumulation modes for the Correlator 
		 */
		
		enum AccumMode{
			FAST  !< fast dump time. ALMA use case : 1 ms dump time, available only for autocorrelation. ,
			NORMAL  !< normal dump time. ALMA use case : 16ms dump time, available for both autocorrelation and cross-orrelation. ,
			UNDEFINED  !< Not defined or not applicable. 
		};
		
		typedef sequence<AccumMode> SofAccumMode;
		typedef sequence<sequence<AccumMode> > SofSofAccumMode;
		typedef sequence<sequence<sequence<AccumMode> > > SofSofSofAccumMode;
	
	};


	/**
	*  A module to encapsulate the enumeration AntennaMake.
	*/
	module AntennaMakeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration AntennaMake : */
		/*! The physical types of antenna 
		 */
		
		enum AntennaMake{
			AEM_12  !< 12m AEM antenna ,
			MITSUBISHI_7  !< 7-m Mitsubishi antenna (ACA) ,
			MITSUBISHI_12_A  !< 12-m Mitsubishi antenna (ACA) (refurbished prototype) ,
			MITSUBISHI_12_B  !< 12-m Mitsubishi antenna (ACA) (production) ,
			VERTEX_12_ATF  !< 12-m Vertex antenna prototype ,
			AEM_12_ATF  !< 12-m AEM  antenna prototype ,
			VERTEX_12  !< 12-m Vertex antenna ,
			IRAM_15  !< 15-m IRAM antenna ,
			UNDEFINED  !< Not defined or not applicable. 
		};
		
		typedef sequence<AntennaMake> SofAntennaMake;
		typedef sequence<sequence<AntennaMake> > SofSofAntennaMake;
		typedef sequence<sequence<sequence<AntennaMake> > > SofSofSofAntennaMake;
	
	};


	/**
	*  A module to encapsulate the enumeration AntennaMotionPattern.
	*/
	module AntennaMotionPatternMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration AntennaMotionPattern : */
		/*! Motion pattern of antenna , e.g. in a calibration scan. 
		 */
		
		enum AntennaMotionPattern{
			NONE  !< No pattern. ,
			CROSS_SCAN  !< Crossed scan (continuous pattern) ,
			SPIRAL  !< Spiral pattern ,
			CIRCLE  !< Circular pattern ,
			THREE_POINTS  !< Three points pattern. ,
			FOUR_POINTS  !< Four points pattern. ,
			FIVE_POINTS  !< Five points pattern. ,
			TEST  !< Reserved for development. ,
			UNSPECIFIED  !< Unspecified pattern. ,
			STAR  !<  ,
			LISSAJOUS  !<  
		};
		
		typedef sequence<AntennaMotionPattern> SofAntennaMotionPattern;
		typedef sequence<sequence<AntennaMotionPattern> > SofSofAntennaMotionPattern;
		typedef sequence<sequence<sequence<AntennaMotionPattern> > > SofSofSofAntennaMotionPattern;
	
	};


	/**
	*  A module to encapsulate the enumeration AntennaType.
	*/
	module AntennaTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration AntennaType : */
		/*!  Functional types of antenna 
		 */
		
		enum AntennaType{
			GROUND_BASED  !< Ground-based antenna ,
			SPACE_BASED  !< Antenna in a spacecraft ,
			TRACKING_STN  !< Space-tracking station antenna 
		};
		
		typedef sequence<AntennaType> SofAntennaType;
		typedef sequence<sequence<AntennaType> > SofSofAntennaType;
		typedef sequence<sequence<sequence<AntennaType> > > SofSofSofAntennaType;
	
	};


	/**
	*  A module to encapsulate the enumeration AssociatedCalNature.
	*/
	module AssociatedCalNatureMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration AssociatedCalNature : */
		/*! These are the associated calibration natures 
		 */
		
		enum AssociatedCalNature{
			ASSOCIATED_EXECBLOCK  !< The associated execblock id concatenated to produce the data set 
		};
		
		typedef sequence<AssociatedCalNature> SofAssociatedCalNature;
		typedef sequence<sequence<AssociatedCalNature> > SofSofAssociatedCalNature;
		typedef sequence<sequence<sequence<AssociatedCalNature> > > SofSofSofAssociatedCalNature;
	
	};


	/**
	*  A module to encapsulate the enumeration AssociatedFieldNature.
	*/
	module AssociatedFieldNatureMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration AssociatedFieldNature : */
		/*!  [ASDM.Field] Nature of the associated field 
		 */
		
		enum AssociatedFieldNature{
			ON  !< The associated field is used as ON source data ,
			OFF  !< The associated field is used as OFF source data ,
			PHASE_REFERENCE  !< The associated field is used as Phase reference data 
		};
		
		typedef sequence<AssociatedFieldNature> SofAssociatedFieldNature;
		typedef sequence<sequence<AssociatedFieldNature> > SofSofAssociatedFieldNature;
		typedef sequence<sequence<sequence<AssociatedFieldNature> > > SofSofSofAssociatedFieldNature;
	
	};


	/**
	*  A module to encapsulate the enumeration AtmPhaseCorrection.
	*/
	module AtmPhaseCorrectionMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration AtmPhaseCorrection : */
		/*!  Status of Phase correction 
		 */
		
		enum AtmPhaseCorrection{
			AP_UNCORRECTED  !< Data has no WVR phase correction ,
			AP_CORRECTED  !< Data phases have been corrected using WVR data 
		};
		
		typedef sequence<AtmPhaseCorrection> SofAtmPhaseCorrection;
		typedef sequence<sequence<AtmPhaseCorrection> > SofSofAtmPhaseCorrection;
		typedef sequence<sequence<sequence<AtmPhaseCorrection> > > SofSofSofAtmPhaseCorrection;
	
	};


	/**
	*  A module to encapsulate the enumeration AxisName.
	*/
	module AxisNameMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration AxisName : */
		/*!  Axis names. 
		 */
		
		enum AxisName{
			TIM  !< Time axis. ,
			BAL  !< Baseline axis. ,
			ANT  !< Antenna axis. ,
			BAB  !< Baseband axis. ,
			SPW  !< Spectral window  axis. ,
			SIB  !< Sideband axis. ,
			SUB  !< Subband axis. ,
			BIN  !< Bin axis. ,
			APC  !< Atmosphere phase correction axis. ,
			SPP  !< Spectral point axis. ,
			POL  !< Polarization axis (Stokes parameters). ,
			STO  !< Stokes parameter axis. ,
			HOL  !< Holography axis. 
		};
		
		typedef sequence<AxisName> SofAxisName;
		typedef sequence<sequence<AxisName> > SofSofAxisName;
		typedef sequence<sequence<sequence<AxisName> > > SofSofSofAxisName;
	
	};


	/**
	*  A module to encapsulate the enumeration BasebandName.
	*/
	module BasebandNameMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration BasebandName : */
		/*!  Baseband names 
		 */
		
		enum BasebandName{
			NOBB  !< Baseband not applicable. ,
			BB_1  !< Baseband one ,
			BB_2  !< Baseband two ,
			BB_3  !< Baseband three ,
			BB_4  !< Baseband four ,
			BB_5  !< Baseband five (not ALMA) ,
			BB_6  !< Baseband six (not ALMA) ,
			BB_7  !< Baseband seven (not ALMA) ,
			BB_8  !< Baseband eight (not ALMA) ,
			BB_ALL  !< All ALMA basebands (i.e. all available basebands) ,
			A1C1_3BIT  !<  ,
			A2C2_3BIT  !<  ,
			AC_8BIT  !<  ,
			B1D1_3BIT  !<  ,
			B2D2_3BIT  !<  ,
			BD_8BIT  !<  
		};
		
		typedef sequence<BasebandName> SofBasebandName;
		typedef sequence<sequence<BasebandName> > SofSofBasebandName;
		typedef sequence<sequence<sequence<BasebandName> > > SofSofSofBasebandName;
	
	};


	/**
	*  A module to encapsulate the enumeration BaselineReferenceCode.
	*/
	module BaselineReferenceCodeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration BaselineReferenceCode : */
		/*! defines reference frames to qualify the measure of a baseline. 
		 */
		
		enum BaselineReferenceCode{
			J2000  !< mean equator, equinox J2000.0 ,
			B1950  !< mean equator, equinox B1950.0 ,
			GALACTIC  !< galactic coordinates. ,
			SUPERGAL  !< supergalactic coordinates. ,
			ECLIPTIC  !< ecliptic for J2000.0 ,
			JMEAN  !< mean equator. ,
			JTRUE  !< true equator. ,
			APP  !< apparent geocentric. ,
			BMEAN  !< mean equator. ,
			BTRUE  !< true equator. ,
			JNAT  !< geocentric natural frame. ,
			MECLIPTIC  !< ecliptic for mean equator. ,
			TECLIPTIC  !< ecliptic for true equator. ,
			TOPO  !< apparent geocentric ,
			MERCURY  !< from JPL DE table. ,
			VENUS  !<  ,
			MARS  !<  ,
			JUPITER  !<  ,
			SATURN  !<  ,
			NEPTUN  !<  ,
			SUN  !<  ,
			MOON  !<  ,
			HADEC  !<  ,
			AZEL  !<  ,
			AZELGEO  !<  ,
			AZELSW  !< topocentric Az/El (N => E). ,
			AZELNE  !< idem AZEL. ,
			ITRF  !< ITRF earth frame. 
		};
		
		typedef sequence<BaselineReferenceCode> SofBaselineReferenceCode;
		typedef sequence<sequence<BaselineReferenceCode> > SofSofBaselineReferenceCode;
		typedef sequence<sequence<sequence<BaselineReferenceCode> > > SofSofSofBaselineReferenceCode;
	
	};


	/**
	*  A module to encapsulate the enumeration BinaryDataFlags.
	*/
	module BinaryDataFlagsMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration BinaryDataFlags : */
		/*! This enumeration declares an ordered list of  flagging conditions used to build the flag part in the BDF content.  Each enumerator is associated to one bit in a bitset. A bit set to one (resp. zero) means that the corresponding flagging condition is set (resp. unset). The current convention limits  the length of the enumeration to 32; the position (0-based) of the enumerator in the enumeration defines the bit position. Any bit whose position is greater or equal to the length of the enumeration and less than 32 should be ignored by the software since it does not correspond to any flagging condition.  
		 */
		
		enum BinaryDataFlags{
			INTEGRATION_FULLY_BLANKED  !< All dumps within an integration duration are blanked. When this flag is raised the effect is to have the bin part actualDurations containing zeros? In other words it means 'all dumps affected'.  Bit position \f$==0\f$ ,
			WVR_APC  !< Coefficients not received.Apply to all BAL involving the antenna. Bit position \f$==1\f$ ,
			CORRELATOR_MISSING_STATUS  !< Correlator status was not retrieved for the period. So  yielded data are not reliable. Apply to all  BBs handled by the correlator. Bit position \f$==2\f$ ,
			MISSING_ANTENNA_EVENT  !< Antenna delay event was not retrieved for the period. So  yielded data are not reliable. BALs including the antenna. Bit position \f$==3\f$ ,
			DELTA_SIGMA_OVERFLOW  !< In data transmission between the MTI cards, there are one or more channels whose absolute value differences between adjacent channel values are bigger than the maximum number. Bit position \f$==4\f$ ,
			DELAY_CORRECTION_NOT_APPLIED  !< no residual delay correction was applied. It implies that either base-band offset delays from TMCDB were not available or that delay events from the delay server were not received on time to compute and apply a phase rotation to base-lines in the array. \f$==5\f$ ,
			SYNCRONIZATION_ERROR  !< cdp node(s) not properly synchronized to the array timing signal (48ms.) All data produced by that node(s) are suspicious.Lags and spectral processing goes as normal, it is just the flag presence in the bdf what indicates that something is suspicious. Bit position \f$==6\f$ ,
			FFT_OVERFLOW  !< Overflowed POL and derived outputs from it. Dumps between the timestamp marked as FFT overflowed and the time back to 96msec before. Bit position \f$==7\f$ ,
			TFB_SCALING_FACTOR_NOT_RETRIEVED  !< CCC cannot retrieve scaling factors during calibration for specific antennas the calibration would still end successfully but the cdp will record the faulty scaling
			 factors and add a flag to all involved base-lines. Bit position \f$==8\f$ ,
			ZERO_LAG_NOT_RECEIVED  !< CDP node handling only cross antenna intersections did  not receive lag zero information from node(s) handling auto intersections for involved antennas in that cross intersection. Bit position \f$==9\f$ ,
			SIGMA_OVERFLOW  !< Auto-correlation sigma levels makes impossible any 2 bits quantization correction on lags data. One sigma value out of range affects that antenna itself and all base-lines containing that antenna. Is it possible to merge this flags with DELTA_SIGMA_OVERFLOW? The difference seems to be the granularity. If it is POL ACACORR would have to repeat the flag for every POL  because per baseband there are several POL. Bit position \f$==10\f$ ,
			UNUSABLE_CAI_OUTPUT  !< The output spectra are made from invalid input signals, e.g., broken optical frames, missing synchronization or no input signal power. Bit position \f$==11\f$ ,
			QC_FAILED  !< Quantization correction not applied due to unsuitable lag zero value. BL-CORR note: every possible signal level should be actually accepted (too small or too big), the presence of this bit signals more a software problem than an antenna signal problem. Bit position \f$==12\f$ ,
			NOISY_TDM_CHANNELS  !< First TDM channels are normally noisy and they have a  large amplitude. If that excess of amplitude in those channels would be the sole reason for keeping the integration storage at 32 bits integers then the software clips those channels and flags the data. Thus preventing large storage for otherwise 16 bits friendly dynamic range. Bit position \f$==13\f$ ,
			SPECTRAL_NORMALIZATION_FAILED  !< Auto-correlation and zero-lags figures are required to normalize cross-correlation spectra as prescribed in Scott's 'Specifications and Clarifications of ALMA Correlator Details'. If those figures are not available on time during on-line processing then crosscorrelations are not normalized and the integration flagged. Bit position \f$==14\f$ ,
			DROPPED_PACKETS  !< T.B.D. Bit position \f$==15\f$ ,
			DETECTOR_SATURATED  !< T.B.D. Bit position \f$==16\f$ ,
			NO_DATA_FROM_DIGITAL_POWER_METER  !< The current data from digital power meter are available for the calculation of the 3-bit linearity correction. An old correction factor is applied. Bit position \f$==17\f$ ,
			RESERVED_18  !< Not assigned. ,
			RESERVED_19  !< Not assigned. ,
			RESERVED_20  !< Not assigned. ,
			RESERVED_21  !< Not assigned. ,
			RESERVED_22  !< Not assigned. ,
			RESERVED_23  !< Not assigned. ,
			RESERVED_24  !< Not assigned. ,
			RESERVED_25  !< Not assigned. ,
			RESERVED_26  !< Not assigned. ,
			RESERVED_27  !< Not assigned. ,
			RESERVED_28  !< Not assigned. ,
			RESERVED_29  !< Not assigned. ,
			RESERVED_30  !< Not assigned. ,
			ALL_PURPOSE_ERROR  !< This bit designates data flagged in the correlator but does not provide information as to the reason for the flag. Readers are expected not to process the data when this bit is set. Bit position \f$ ==31 \f$. 
		};
		
		typedef sequence<BinaryDataFlags> SofBinaryDataFlags;
		typedef sequence<sequence<BinaryDataFlags> > SofSofBinaryDataFlags;
		typedef sequence<sequence<sequence<BinaryDataFlags> > > SofSofSofBinaryDataFlags;
	
	};


	/**
	*  A module to encapsulate the enumeration CalCurveType.
	*/
	module CalCurveTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CalCurveType : */
		/*!  [CalDM.CalCurve] type pf calibration curve 
		 */
		
		enum CalCurveType{
			AMPLITUDE  !< Calibration curve is Amplitude ,
			PHASE  !< Calibration curve is phase ,
			UNDEFINED  !< Not applicable. 
		};
		
		typedef sequence<CalCurveType> SofCalCurveType;
		typedef sequence<sequence<CalCurveType> > SofSofCalCurveType;
		typedef sequence<sequence<sequence<CalCurveType> > > SofSofSofCalCurveType;
	
	};


	/**
	*  A module to encapsulate the enumeration CalDataOrigin.
	*/
	module CalDataOriginMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CalDataOrigin : */
		/*!  
		 */
		
		enum CalDataOrigin{
			TOTAL_POWER  !< Total Power data (from detectors) ,
			WVR  !< Water vapour radiometrers ,
			CHANNEL_AVERAGE_AUTO  !< Autocorrelations from channel average data ,
			CHANNEL_AVERAGE_CROSS  !< Crosscorrelations from channel average data ,
			FULL_RESOLUTION_AUTO  !< Autocorrelations from full-resolution data ,
			FULL_RESOLUTION_CROSS  !< Cross correlations from full-resolution data ,
			OPTICAL_POINTING  !< Optical pointing data ,
			HOLOGRAPHY  !< data from holography receivers ,
			NONE  !< Not applicable 
		};
		
		typedef sequence<CalDataOrigin> SofCalDataOrigin;
		typedef sequence<sequence<CalDataOrigin> > SofSofCalDataOrigin;
		typedef sequence<sequence<sequence<CalDataOrigin> > > SofSofSofCalDataOrigin;
	
	};


	/**
	*  A module to encapsulate the enumeration CalibrationDevice.
	*/
	module CalibrationDeviceMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CalibrationDevice : */
		/*! Devices that may be inserted in the optical path in front of the receiver. 
		 */
		
		enum CalibrationDevice{
			AMBIENT_LOAD  !< An absorbing load at the ambient temperature. ,
			COLD_LOAD  !< A cooled absorbing load. ,
			HOT_LOAD  !< A heated absorbing load. ,
			NOISE_TUBE_LOAD  !< A noise tube. ,
			QUARTER_WAVE_PLATE  !< A transparent plate that introduces a 90-degree phase difference between othogonal polarizations. ,
			SOLAR_FILTER  !< An optical attenuator (to protect receiver from solar heat). ,
			NONE  !< No device, the receiver looks at the sky (through the telescope). 
		};
		
		typedef sequence<CalibrationDevice> SofCalibrationDevice;
		typedef sequence<sequence<CalibrationDevice> > SofSofCalibrationDevice;
		typedef sequence<sequence<sequence<CalibrationDevice> > > SofSofSofCalibrationDevice;
	
	};


	/**
	*  A module to encapsulate the enumeration CalibrationFunction.
	*/
	module CalibrationFunctionMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CalibrationFunction : */
		/*! Function of a scan in a calibration set. Useful only in real time. 
		 */
		
		enum CalibrationFunction{
			FIRST  !< the scan is the first in a calibration set. ,
			LAST  !< the scan is the last in a calibration set. ,
			UNSPECIFIED  !< the function is not specified. 
		};
		
		typedef sequence<CalibrationFunction> SofCalibrationFunction;
		typedef sequence<sequence<CalibrationFunction> > SofSofCalibrationFunction;
		typedef sequence<sequence<sequence<CalibrationFunction> > > SofSofSofCalibrationFunction;
	
	};


	/**
	*  A module to encapsulate the enumeration CalibrationMode.
	*/
	module CalibrationModeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CalibrationMode : */
		/*!  Modes of calibration 
		 */
		
		enum CalibrationMode{
			HOLOGRAPHY  !< Holography receiver ,
			INTERFEROMETRY  !< interferometry ,
			OPTICAL  !< Optical telescope ,
			RADIOMETRY  !< total power ,
			WVR  !< water vapour radiometry receiver 
		};
		
		typedef sequence<CalibrationMode> SofCalibrationMode;
		typedef sequence<sequence<CalibrationMode> > SofSofCalibrationMode;
		typedef sequence<sequence<sequence<CalibrationMode> > > SofSofSofCalibrationMode;
	
	};


	/**
	*  A module to encapsulate the enumeration CalibrationSet.
	*/
	module CalibrationSetMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CalibrationSet : */
		/*! Defines sets of calibration scans to be reduced together for a result. 
		 */
		
		enum CalibrationSet{
			NONE  !< Scan is not part of a calibration set. ,
			AMPLI_CURVE  !< Amplitude calibration scan (calibration curve to be derived). ,
			ANTENNA_POSITIONS  !< Antenna positions measurement. ,
			PHASE_CURVE  !< Phase calibration scan (calibration curve to be derived). ,
			POINTING_MODEL  !< Pointing calibration scan (pointing model to be derived). ,
			ACCUMULATE  !< Accumulate a scan in a calibration set. ,
			TEST  !< Reserved for development. ,
			UNSPECIFIED  !< Unspecified calibration intent. 
		};
		
		typedef sequence<CalibrationSet> SofCalibrationSet;
		typedef sequence<sequence<CalibrationSet> > SofSofCalibrationSet;
		typedef sequence<sequence<sequence<CalibrationSet> > > SofSofSofCalibrationSet;
	
	};


	/**
	*  A module to encapsulate the enumeration CalType.
	*/
	module CalTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CalType : */
		/*!  [CalDM.CalData] Used to point to a given CalResult table 
		 */
		
		enum CalType{
			CAL_AMPLI  !<  ,
			CAL_ATMOSPHERE  !<  ,
			CAL_BANDPASS  !<  ,
			CAL_CURVE  !<  ,
			CAL_DELAY  !<  ,
			CAL_FLUX  !<  ,
			CAL_FOCUS  !<  ,
			CAL_FOCUS_MODEL  !<  ,
			CAL_GAIN  !<  ,
			CAL_HOLOGRAPHY  !<  ,
			CAL_PHASE  !<  ,
			CAL_POINTING  !<  ,
			CAL_POINTING_MODEL  !<  ,
			CAL_POSITION  !<  ,
			CAL_PRIMARY_BEAM  !<  ,
			CAL_SEEING  !<  ,
			CAL_WVR  !<  ,
			CAL_APPPHASE  !< Calibration for phasing of ALMA. Applicable at ALMA. 
		};
		
		typedef sequence<CalType> SofCalType;
		typedef sequence<sequence<CalType> > SofSofCalType;
		typedef sequence<sequence<sequence<CalType> > > SofSofSofCalType;
	
	};


	/**
	*  A module to encapsulate the enumeration CorrelationBit.
	*/
	module CorrelationBitMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CorrelationBit : */
		/*!  [APDM] Number of bits used for correlation 
		 */
		
		enum CorrelationBit{
			BITS_2x2  !< two bit correlation ,
			BITS_3x3  !<  three bit correlation ,
			BITS_4x4  !< four bit correlation 
		};
		
		typedef sequence<CorrelationBit> SofCorrelationBit;
		typedef sequence<sequence<CorrelationBit> > SofSofCorrelationBit;
		typedef sequence<sequence<sequence<CorrelationBit> > > SofSofSofCorrelationBit;
	
	};


	/**
	*  A module to encapsulate the enumeration CorrelationMode.
	*/
	module CorrelationModeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CorrelationMode : */
		/*!  [ASDM.Binary] Actual data products in binary data 
		 */
		
		enum CorrelationMode{
			CROSS_ONLY  !< Cross-correlations only [not for ALMA] ,
			AUTO_ONLY  !< Auto-correlations only ,
			CROSS_AND_AUTO  !< Auto-correlations and Cross-correlations 
		};
		
		typedef sequence<CorrelationMode> SofCorrelationMode;
		typedef sequence<sequence<CorrelationMode> > SofSofCorrelationMode;
		typedef sequence<sequence<sequence<CorrelationMode> > > SofSofSofCorrelationMode;
	
	};


	/**
	*  A module to encapsulate the enumeration CorrelatorCalibration.
	*/
	module CorrelatorCalibrationMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CorrelatorCalibration : */
		/*!  Internal correlator calibrations performed duting this subscan 
		 */
		
		enum CorrelatorCalibration{
			NONE  !< No internal correlator calibration ,
			CORRELATOR_CALIBRATION  !< Internal correlator calibration. ,
			REAL_OBSERVATION  !< A 'real' observation. 
		};
		
		typedef sequence<CorrelatorCalibration> SofCorrelatorCalibration;
		typedef sequence<sequence<CorrelatorCalibration> > SofSofCorrelatorCalibration;
		typedef sequence<sequence<sequence<CorrelatorCalibration> > > SofSofSofCorrelatorCalibration;
	
	};


	/**
	*  A module to encapsulate the enumeration CorrelatorName.
	*/
	module CorrelatorNameMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CorrelatorName : */
		/*!  
		 */
		
		enum CorrelatorName{
			ALMA_ACA  !< ACA correlator ,
			ALMA_BASELINE  !<  ,
			ALMA_BASELINE_ATF  !<  ,
			ALMA_BASELINE_PROTO_OSF  !<  ,
			HERSCHEL  !<  ,
			IRAM_PDB  !<  ,
			IRAM_30M_VESPA  !< Up to 18000 channels. ,
			IRAM_WILMA  !< 2 MHz, 18x930 MHz, HERA (wide) ,
			NRAO_VLA  !< VLA correlator. ,
			NRAO_WIDAR  !< EVLA correlator. 
		};
		
		typedef sequence<CorrelatorName> SofCorrelatorName;
		typedef sequence<sequence<CorrelatorName> > SofSofCorrelatorName;
		typedef sequence<sequence<sequence<CorrelatorName> > > SofSofSofCorrelatorName;
	
	};


	/**
	*  A module to encapsulate the enumeration CorrelatorType.
	*/
	module CorrelatorTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration CorrelatorType : */
		/*! defines the type of a correlator. 
		 */
		
		enum CorrelatorType{
			FX  !< identifies a digital correlator of type FX. ,
			XF  !< identifies a digital correlator of type XF. ,
			FXF  !< identifies a correlator of type FXF. 
		};
		
		typedef sequence<CorrelatorType> SofCorrelatorType;
		typedef sequence<sequence<CorrelatorType> > SofSofCorrelatorType;
		typedef sequence<sequence<sequence<CorrelatorType> > > SofSofSofCorrelatorType;
	
	};


	/**
	*  A module to encapsulate the enumeration DataContent.
	*/
	module DataContentMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration DataContent : */
		/*!  [ASDM.Binaries] Contents of binary data attachment 
		 */
		
		enum DataContent{
			CROSS_DATA  !< Cross-correlation data ,
			AUTO_DATA  !< Auto-correlation data ,
			ZERO_LAGS  !< Zero-lag data ,
			ACTUAL_TIMES  !< :Actual times (mid points of integrations) ,
			ACTUAL_DURATIONS  !< Actual duration of integrations ,
			WEIGHTS  !< Weights ,
			FLAGS  !< Baseband based flags 
		};
		
		typedef sequence<DataContent> SofDataContent;
		typedef sequence<sequence<DataContent> > SofSofDataContent;
		typedef sequence<sequence<sequence<DataContent> > > SofSofSofDataContent;
	
	};


	/**
	*  A module to encapsulate the enumeration DataScale.
	*/
	module DataScaleMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration DataScale : */
		/*! Units of the cross and auto data in the BDF. 
		 */
		
		enum DataScale{
			K  !< Visibilities in Antenna temperature scale (in Kelvin). ,
			JY  !< Visibilities in Flux Density scale (Jansky). ,
			CORRELATION  !< Correlated Power: WIDAR raw output, normalised by DataValid count. ,
			CORRELATION_COEFFICIENT  !< Correlation Coe\14;cient (Correlated Power scaled by autocorrelations). 
		};
		
		typedef sequence<DataScale> SofDataScale;
		typedef sequence<sequence<DataScale> > SofSofDataScale;
		typedef sequence<sequence<sequence<DataScale> > > SofSofSofDataScale;
	
	};


	/**
	*  A module to encapsulate the enumeration DetectorBandType.
	*/
	module DetectorBandTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration DetectorBandType : */
		/*!  [ASDM.SquareLawDetector] Types of detectors 
		 */
		
		enum DetectorBandType{
			BASEBAND  !< Detector in Baseband Processor ,
			DOWN_CONVERTER  !< Detector in Down - Converter ,
			HOLOGRAPHY_RECEIVER  !< Detector in Holography Receiver ,
			SUBBAND  !< Detector in subband (tunable digital filter). 
		};
		
		typedef sequence<DetectorBandType> SofDetectorBandType;
		typedef sequence<sequence<DetectorBandType> > SofSofDetectorBandType;
		typedef sequence<sequence<sequence<DetectorBandType> > > SofSofSofDetectorBandType;
	
	};


	/**
	*  A module to encapsulate the enumeration DifferenceType.
	*/
	module DifferenceTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration DifferenceType : */
		/*! An enumeration to qualify the values in the columns polarOffsetsType and timeType in the table DelayModelVariableParameters. 
		 */
		
		enum DifferenceType{
			PREDICTED  !<  ,
			PRELIMINARY  !<  ,
			RAPID  !<  ,
			FINAL  !<  
		};
		
		typedef sequence<DifferenceType> SofDifferenceType;
		typedef sequence<sequence<DifferenceType> > SofSofDifferenceType;
		typedef sequence<sequence<sequence<DifferenceType> > > SofSofSofDifferenceType;
	
	};


	/**
	*  A module to encapsulate the enumeration DirectionReferenceCode.
	*/
	module DirectionReferenceCodeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration DirectionReferenceCode : */
		/*! defines reference frames to qualify the measure of a direction. 
		 */
		
		enum DirectionReferenceCode{
			J2000  !< mean equator and equinox at J2000.0 ,
			JMEAN  !< mean equator and equinox at frame epoch. ,
			JTRUE  !< true equator and equinox at frame epoch. ,
			APP  !< apparent geocentric position. ,
			B1950  !< mean epoch and ecliptic at B1950.0. ,
			B1950_VLA  !<  ,
			BMEAN  !< mean equator and equinox at frame epoch. ,
			BTRUE  !< true equator and equinox at frame epoch. ,
			GALACTIC  !< galactic coordinates. ,
			HADEC  !< topocentric HA and declination. ,
			AZELSW  !< topocentric Azimuth and Elevation (N through E). ,
			AZELSWGEO  !<  ,
			AZELNE  !< idem AZEL ,
			AZELNEGEO  !<  ,
			JNAT  !< geocentric natural frame. ,
			ECLIPTIC  !< ecliptic for J2000.0 equator, equinox. ,
			MECLIPTIC  !< ecliptic for mean equator of date. ,
			TECLIPTIC  !< ecliptic for true equatorof date. ,
			SUPERGAL  !< supergalactic coordinates. ,
			ITRF  !< coordinates wrt ITRF earth frame. ,
			TOPO  !< apparent topocentric position. ,
			ICRS  !<  ,
			MERCURY  !< from JPL DE table. ,
			VENUS  !<  ,
			MARS  !<  ,
			JUPITER  !<  ,
			SATURN  !<  ,
			URANUS  !<  ,
			NEPTUNE  !<  ,
			PLUTO  !<  ,
			SUN  !<  ,
			MOON  !<  
		};
		
		typedef sequence<DirectionReferenceCode> SofDirectionReferenceCode;
		typedef sequence<sequence<DirectionReferenceCode> > SofSofDirectionReferenceCode;
		typedef sequence<sequence<sequence<DirectionReferenceCode> > > SofSofSofDirectionReferenceCode;
	
	};


	/**
	*  A module to encapsulate the enumeration DopplerReferenceCode.
	*/
	module DopplerReferenceCodeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration DopplerReferenceCode : */
		/*! defines reference frames to qualify the measure of a radial velocity expressed as doppler shift. 
		 */
		
		enum DopplerReferenceCode{
			RADIO  !< radio definition : \f$ 1 - F \f$,
			Z  !< redshift : \f$ - 1 + 1 / F \f$ ,
			RATIO  !< frequency ratio : \f$ F \f$,
			BETA  !< relativistic : \f$(1 - F^2) / (1 + F^2) \f$ ,
			GAMMA  !< \f$(1 + F^2)/(2*F)\f$ ,
			OPTICAL  !< \f$Z\f$Z ,
			RELATIVISTIC  !< idem BETA 
		};
		
		typedef sequence<DopplerReferenceCode> SofDopplerReferenceCode;
		typedef sequence<sequence<DopplerReferenceCode> > SofSofDopplerReferenceCode;
		typedef sequence<sequence<sequence<DopplerReferenceCode> > > SofSofSofDopplerReferenceCode;
	
	};


	/**
	*  A module to encapsulate the enumeration DopplerTrackingMode.
	*/
	module DopplerTrackingModeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration DopplerTrackingMode : */
		/*! Enumerations of different modes used in doppler tracking. 
		 */
		
		enum DopplerTrackingMode{
			NONE  !< No Doppler tracking. ,
			CONTINUOUS  !< Continuous (every integration) Doppler tracking. ,
			SCAN_BASED  !< Doppler tracking only at scan boundaries.  This means we update  the observing frequency to the correct value, but only at scan boundaries. ,
			SB_BASED  !< Doppler tracking only at the beginning of the Scheduling Block.  We set the frequency at the beginning of the observation but leave it fixed thereafter.  For the EVLA this is referred to as  'Doppler setting'. 
		};
		
		typedef sequence<DopplerTrackingMode> SofDopplerTrackingMode;
		typedef sequence<sequence<DopplerTrackingMode> > SofSofDopplerTrackingMode;
		typedef sequence<sequence<sequence<DopplerTrackingMode> > > SofSofSofDopplerTrackingMode;
	
	};


	/**
	*  A module to encapsulate the enumeration FieldCode.
	*/
	module FieldCodeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration FieldCode : */
		/*!  [ASDM.Field] code for Field 
		 */
		
		enum FieldCode{
			NONE  !<  
		};
		
		typedef sequence<FieldCode> SofFieldCode;
		typedef sequence<sequence<FieldCode> > SofSofFieldCode;
		typedef sequence<sequence<sequence<FieldCode> > > SofSofSofFieldCode;
	
	};


	/**
	*  A module to encapsulate the enumeration FilterMode.
	*/
	module FilterModeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration FilterMode : */
		/*!  [APDM.Correlator] Modes of correlator input filtering 
		 */
		
		enum FilterMode{
			FILTER_NA  !<  Not Applicable (2 antenna prototype). The Tunable Filter Banks are not implemented ,
			FILTER_TDM  !< Time Division Mode. In this mode the Tunable Filter banks are bypassed ,
			FILTER_TFB  !< The Tunable Filter Bank is implemented and used ,
			UNDEFINED  !< Not defined or not applicable. 
		};
		
		typedef sequence<FilterMode> SofFilterMode;
		typedef sequence<sequence<FilterMode> > SofSofFilterMode;
		typedef sequence<sequence<sequence<FilterMode> > > SofSofSofFilterMode;
	
	};


	/**
	*  A module to encapsulate the enumeration FluxCalibrationMethod.
	*/
	module FluxCalibrationMethodMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration FluxCalibrationMethod : */
		/*!  [CalDM.CalFlux] Methods for flux calibration 
		 */
		
		enum FluxCalibrationMethod{
			ABSOLUTE  !< Absolute flux calibration (based on standard antenna) ,
			RELATIVE  !< Relative flux calibration (based on a primary calibrator) ,
			EFFICIENCY  !< Flux calibrator based on tabulated antenna efficiciency 
		};
		
		typedef sequence<FluxCalibrationMethod> SofFluxCalibrationMethod;
		typedef sequence<sequence<FluxCalibrationMethod> > SofSofFluxCalibrationMethod;
		typedef sequence<sequence<sequence<FluxCalibrationMethod> > > SofSofSofFluxCalibrationMethod;
	
	};


	/**
	*  A module to encapsulate the enumeration FocusMethod.
	*/
	module FocusMethodMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration FocusMethod : */
		/*!  [CalDM.CalFocus] Method of focus measurement 
		 */
		
		enum FocusMethod{
			THREE_POINT  !< Three-point measurement ,
			FIVE_POINT  !< Five-point measurement ,
			HOLOGRAPHY  !<  
		};
		
		typedef sequence<FocusMethod> SofFocusMethod;
		typedef sequence<sequence<FocusMethod> > SofSofFocusMethod;
		typedef sequence<sequence<sequence<FocusMethod> > > SofSofSofFocusMethod;
	
	};


	/**
	*  A module to encapsulate the enumeration FrequencyReferenceCode.
	*/
	module FrequencyReferenceCodeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration FrequencyReferenceCode : */
		/*! defines reference frames to qualify the measure of a frequency. 
		 */
		
		enum FrequencyReferenceCode{
			LABREST  !< spectral line rest frequency. ,
			LSRD  !< dynamic local standard of rest. ,
			LSRK  !< kinematic local standard rest. ,
			BARY  !< barycentric frequency. ,
			REST  !< spectral line frequency ,
			GEO  !< geocentric frequency. ,
			GALACTO  !< galactocentric frequency. ,
			TOPO  !< topocentric frequency. 
		};
		
		typedef sequence<FrequencyReferenceCode> SofFrequencyReferenceCode;
		typedef sequence<sequence<FrequencyReferenceCode> > SofSofFrequencyReferenceCode;
		typedef sequence<sequence<sequence<FrequencyReferenceCode> > > SofSofSofFrequencyReferenceCode;
	
	};


	/**
	*  A module to encapsulate the enumeration HolographyChannelType.
	*/
	module HolographyChannelTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration HolographyChannelType : */
		/*!  [ASDM.Holography] Type sof holography receiver output channels 
		 */
		
		enum HolographyChannelType{
			Q2  !< Quadrature channel auto-product ,
			QR  !< Quadrature channel times Reference channel cross-product ,
			QS  !< Quadrature channel times Signal channel cross-product ,
			R2  !< Reference channel auto-product ,
			RS  !< Reference channel times Signal channel cross-product ,
			S2  !< Signal channel auto-product 
		};
		
		typedef sequence<HolographyChannelType> SofHolographyChannelType;
		typedef sequence<sequence<HolographyChannelType> > SofSofHolographyChannelType;
		typedef sequence<sequence<sequence<HolographyChannelType> > > SofSofSofHolographyChannelType;
	
	};


	/**
	*  A module to encapsulate the enumeration InvalidatingCondition.
	*/
	module InvalidatingConditionMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration InvalidatingCondition : */
		/*!  [CalDM.CalReduction] Contitions invalidating result 
		 */
		
		enum InvalidatingCondition{
			ANTENNA_DISCONNECT  !< Antenna was disconnected ,
			ANTENNA_MOVE  !< Antenna was moved ,
			ANTENNA_POWER_DOWN  !< Antenna was powered down ,
			RECEIVER_EXCHANGE  !< Receiver was exchanged ,
			RECEIVER_POWER_DOWN  !< Receiver was powered down 
		};
		
		typedef sequence<InvalidatingCondition> SofInvalidatingCondition;
		typedef sequence<sequence<InvalidatingCondition> > SofSofInvalidatingCondition;
		typedef sequence<sequence<sequence<InvalidatingCondition> > > SofSofSofInvalidatingCondition;
	
	};


	/**
	*  A module to encapsulate the enumeration NetSideband.
	*/
	module NetSidebandMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration NetSideband : */
		/*!  [ASDM.SpectralWindow] Equivalent side band of spectrum frequency axis 
		 */
		
		enum NetSideband{
			NOSB  !< No side band (no frequency conversion) ,
			LSB  !< Lower side band ,
			USB  !< Upper side band ,
			DSB  !< Double side band 
		};
		
		typedef sequence<NetSideband> SofNetSideband;
		typedef sequence<sequence<NetSideband> > SofSofNetSideband;
		typedef sequence<sequence<sequence<NetSideband> > > SofSofSofNetSideband;
	
	};


	/**
	*  A module to encapsulate the enumeration PointingMethod.
	*/
	module PointingMethodMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration PointingMethod : */
		/*!  [CalDM.CalPointing] Method of pointing measurement 
		 */
		
		enum PointingMethod{
			THREE_POINT  !< Three-point scan ,
			FOUR_POINT  !< Four-point scan ,
			FIVE_POINT  !< Five-point scan ,
			CROSS  !< Cross scan ,
			CIRCLE  !< Circular scan ,
			HOLOGRAPHY  !<  
		};
		
		typedef sequence<PointingMethod> SofPointingMethod;
		typedef sequence<sequence<PointingMethod> > SofSofPointingMethod;
		typedef sequence<sequence<sequence<PointingMethod> > > SofSofSofPointingMethod;
	
	};


	/**
	*  A module to encapsulate the enumeration PointingModelMode.
	*/
	module PointingModelModeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration PointingModelMode : */
		/*!  [CalDM.PointingModel] Mode of Pointing Model  
		 */
		
		enum PointingModelMode{
			RADIO  !< Radio pointing model ,
			OPTICAL  !< Optical Pointing Model 
		};
		
		typedef sequence<PointingModelMode> SofPointingModelMode;
		typedef sequence<sequence<PointingModelMode> > SofSofPointingModelMode;
		typedef sequence<sequence<sequence<PointingModelMode> > > SofSofSofPointingModelMode;
	
	};


	/**
	*  A module to encapsulate the enumeration PolarizationType.
	*/
	module PolarizationTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration PolarizationType : */
		/*! The polarizations a single receptor can detect
		 */
		
		enum PolarizationType{
			R  !< Right-handed Circular ,
			L  !< Left-handed Circular ,
			X  !< X linear ,
			Y  !< Y linear ,
			BOTH  !< The receptor responds to both polarizations. 
		};
		
		typedef sequence<PolarizationType> SofPolarizationType;
		typedef sequence<sequence<PolarizationType> > SofSofPolarizationType;
		typedef sequence<sequence<sequence<PolarizationType> > > SofSofSofPolarizationType;
	
	};


	/**
	*  A module to encapsulate the enumeration PositionMethod.
	*/
	module PositionMethodMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration PositionMethod : */
		/*!  [CalDM.CalPositions] Method used for measuring antenna positions 
		 */
		
		enum PositionMethod{
			DELAY_FITTING  !< Delays are measured for each source; the delays are used for fitting antenna position errors. ,
			PHASE_FITTING  !< Phases are measured for each source; these phases are used to fit antenna position errors. 
		};
		
		typedef sequence<PositionMethod> SofPositionMethod;
		typedef sequence<sequence<PositionMethod> > SofSofPositionMethod;
		typedef sequence<sequence<sequence<PositionMethod> > > SofSofSofPositionMethod;
	
	};


	/**
	*  A module to encapsulate the enumeration PositionReferenceCode.
	*/
	module PositionReferenceCodeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration PositionReferenceCode : */
		/*! defines reference frames to qualify the measure of a position.
		 */
		
		enum PositionReferenceCode{
			ITRF  !< International Terrestrial Reference Frame. ,
			WGS84  !< World Geodetic System. ,
			SITE  !< Site reference coordinate system (ALMA-80.05.00.00-009-B-SPE). ,
			STATION  !< Antenna station reference coordinate system (ALMA-80.05.00.00-009-SPE). ,
			YOKE  !< Antenna yoke reference coordinate system (ALMA-980.05.00.00-009-B-SPE) ,
			REFLECTOR  !< Antenna reflector reference coordinate system (ALMA-80.05.00.00-009-B-SPE). 
		};
		
		typedef sequence<PositionReferenceCode> SofPositionReferenceCode;
		typedef sequence<sequence<PositionReferenceCode> > SofSofPositionReferenceCode;
		typedef sequence<sequence<sequence<PositionReferenceCode> > > SofSofSofPositionReferenceCode;
	
	};


	/**
	*  A module to encapsulate the enumeration PrimaryBeamDescription.
	*/
	module PrimaryBeamDescriptionMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration PrimaryBeamDescription : */
		/*! Nature of the quantity tabulated to describe the primary beam. 
		 */
		
		enum PrimaryBeamDescription{
			COMPLEX_FIELD_PATTERN  !< Electric Field Pattern image at infinite distance from antenna. ,
			APERTURE_FIELD_DISTRIBUTION  !< Electric Field aperture distribution. 
		};
		
		typedef sequence<PrimaryBeamDescription> SofPrimaryBeamDescription;
		typedef sequence<sequence<PrimaryBeamDescription> > SofSofPrimaryBeamDescription;
		typedef sequence<sequence<sequence<PrimaryBeamDescription> > > SofSofSofPrimaryBeamDescription;
	
	};


	/**
	*  A module to encapsulate the enumeration PrimitiveDataType.
	*/
	module PrimitiveDataTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration PrimitiveDataType : */
		/*!  [ASDM.Binaries] Primitive data types for binary MIME attachments 
		 */
		
		enum PrimitiveDataType{
			INT16_TYPE  !< 2 bytes signed integer (short). ,
			INT32_TYPE  !< 4 bytes signed integer (int). ,
			INT64_TYPE  !< 8 bytes signed integer (long long). ,
			FLOAT32_TYPE  !< 4 bytes float (float). ,
			FLOAT64_TYPE  !< 8 bytes float (double). 
		};
		
		typedef sequence<PrimitiveDataType> SofPrimitiveDataType;
		typedef sequence<sequence<PrimitiveDataType> > SofSofPrimitiveDataType;
		typedef sequence<sequence<sequence<PrimitiveDataType> > > SofSofSofPrimitiveDataType;
	
	};


	/**
	*  A module to encapsulate the enumeration ProcessorSubType.
	*/
	module ProcessorSubTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration ProcessorSubType : */
		/*!  [ASDM.Processor] The tables used to contain device configuration data 
		 */
		
		enum ProcessorSubType{
			ALMA_CORRELATOR_MODE  !< ALMA correlator. ,
			SQUARE_LAW_DETECTOR  !< Square law detector. ,
			HOLOGRAPHY  !< Holography. ,
			ALMA_RADIOMETER  !< ALMA radiometer. 
		};
		
		typedef sequence<ProcessorSubType> SofProcessorSubType;
		typedef sequence<sequence<ProcessorSubType> > SofSofProcessorSubType;
		typedef sequence<sequence<sequence<ProcessorSubType> > > SofSofSofProcessorSubType;
	
	};


	/**
	*  A module to encapsulate the enumeration ProcessorType.
	*/
	module ProcessorTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration ProcessorType : */
		/*!  [ASDM.Processor] Types of processors 
		 */
		
		enum ProcessorType{
			CORRELATOR  !< A digital correlator ,
			RADIOMETER  !< A radiometer ,
			SPECTROMETER  !< An (analogue) multi-channel spectrometer 
		};
		
		typedef sequence<ProcessorType> SofProcessorType;
		typedef sequence<sequence<ProcessorType> > SofSofProcessorType;
		typedef sequence<sequence<sequence<ProcessorType> > > SofSofSofProcessorType;
	
	};


	/**
	*  A module to encapsulate the enumeration RadialVelocityReferenceCode.
	*/
	module RadialVelocityReferenceCodeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration RadialVelocityReferenceCode : */
		/*!  
		 */
		
		enum RadialVelocityReferenceCode{
			LSRD  !< dynamic local standard of rest. ,
			LSRK  !< kinematic local standard of rest. ,
			GALACTO  !< galactocentric frequency. ,
			BARY  !< barycentric frequency. ,
			GEO  !< geocentric frequency. ,
			TOPO  !< topocentric frequency. 
		};
		
		typedef sequence<RadialVelocityReferenceCode> SofRadialVelocityReferenceCode;
		typedef sequence<sequence<RadialVelocityReferenceCode> > SofSofRadialVelocityReferenceCode;
		typedef sequence<sequence<sequence<RadialVelocityReferenceCode> > > SofSofSofRadialVelocityReferenceCode;
	
	};


	/**
	*  A module to encapsulate the enumeration ReceiverBand.
	*/
	module ReceiverBandMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration ReceiverBand : */
		/*!  [ASDM.Receiver] Receiver band names 
		 */
		
		enum ReceiverBand{
			ALMA_RB_01  !< ALMA Receiver band 01 ,
			ALMA_RB_02  !< ALMA Receiver band 02 ,
			ALMA_RB_03  !< ALMA Receiver band 03 ,
			ALMA_RB_04  !< ALMA Receiver band 04 ,
			ALMA_RB_05  !< ALMA Receiver band 05 ,
			ALMA_RB_06  !< ALMA Receiver band 06 ,
			ALMA_RB_07  !< ALMA Receiver band 07 ,
			ALMA_RB_08  !< ALMA Receiver band 08 ,
			ALMA_RB_09  !< ALMA Receiver band 09 ,
			ALMA_RB_10  !< ALMA Receiver band 10 ,
			ALMA_RB_ALL  !< all ALMA receiver bands. ,
			ALMA_HOLOGRAPHY_RECEIVER  !< Alma transmitter Holography receiver. ,
			BURE_01  !< Plateau de Bure receiver band #1. ,
			BURE_02  !< Plateau de Bure receiver band #2. ,
			BURE_03  !< Plateau de Bure receiver band #3. ,
			BURE_04  !< Plateau de Bure receiver band #4 ,
			EVLA_4  !<  ,
			EVLA_P  !<  ,
			EVLA_L  !<  ,
			EVLA_C  !<  ,
			EVLA_S  !<  ,
			EVLA_X  !<  ,
			EVLA_Ku  !<  ,
			EVLA_K  !<  ,
			EVLA_Ka  !<  ,
			EVLA_Q  !<  ,
			UNSPECIFIED  !< receiver band of unspecified origin. 
		};
		
		typedef sequence<ReceiverBand> SofReceiverBand;
		typedef sequence<sequence<ReceiverBand> > SofSofReceiverBand;
		typedef sequence<sequence<sequence<ReceiverBand> > > SofSofSofReceiverBand;
	
	};


	/**
	*  A module to encapsulate the enumeration ReceiverSideband.
	*/
	module ReceiverSidebandMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration ReceiverSideband : */
		/*!  [ASDM.SpectralWindow] The type of receiver output a spectral window is fed with 
		 */
		
		enum ReceiverSideband{
			NOSB  !< direct output signal (no frequency conversion). ,
			DSB  !< double side band ouput. ,
			SSB  !< single side band receiver. ,
			TSB  !< receiver with dual output. 
		};
		
		typedef sequence<ReceiverSideband> SofReceiverSideband;
		typedef sequence<sequence<ReceiverSideband> > SofSofReceiverSideband;
		typedef sequence<sequence<sequence<ReceiverSideband> > > SofSofSofReceiverSideband;
	
	};


	/**
	*  A module to encapsulate the enumeration SBType.
	*/
	module SBTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration SBType : */
		/*!  [ASDM.SBSummary] Types of Scheduling Block 
		 */
		
		enum SBType{
			OBSERVATORY  !< Observatory mode scheduling block ,
			OBSERVER  !< Observer mode scheduling block ,
			EXPERT  !< Expert mode scheduling block 
		};
		
		typedef sequence<SBType> SofSBType;
		typedef sequence<sequence<SBType> > SofSofSBType;
		typedef sequence<sequence<sequence<SBType> > > SofSofSofSBType;
	
	};


	/**
	*  A module to encapsulate the enumeration ScanIntent.
	*/
	module ScanIntentMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration ScanIntent : */
		/*!  [ASDM.Scan] Scan intents 
		 */
		
		enum ScanIntent{
			CALIBRATE_AMPLI  !< Amplitude calibration scan ,
			CALIBRATE_ATMOSPHERE  !< Atmosphere calibration scan ,
			CALIBRATE_BANDPASS  !< Bandpass calibration scan ,
			CALIBRATE_DELAY  !< Delay calibration scan ,
			CALIBRATE_FLUX  !< flux measurement scan. ,
			CALIBRATE_FOCUS  !< Focus calibration scan. Z coordinate to be derived ,
			CALIBRATE_FOCUS_X  !< Focus calibration scan; X focus coordinate to be derived ,
			CALIBRATE_FOCUS_Y  !< Focus calibration scan; Y focus coordinate to be derived ,
			CALIBRATE_PHASE  !< Phase calibration scan ,
			CALIBRATE_POINTING  !< Pointing calibration scan ,
			CALIBRATE_POLARIZATION  !< Polarization calibration scan ,
			CALIBRATE_SIDEBAND_RATIO  !< measure relative gains of sidebands. ,
			CALIBRATE_WVR  !< Data from the water vapor radiometers (and correlation data) are used to derive their calibration parameters. ,
			DO_SKYDIP  !< Skydip calibration scan ,
			MAP_ANTENNA_SURFACE  !< Holography calibration scan ,
			MAP_PRIMARY_BEAM  !< Data on a celestial calibration source are used to derive a map of the primary beam. ,
			OBSERVE_TARGET  !< Target source scan ,
			CALIBRATE_POL_LEAKAGE  !<  ,
			CALIBRATE_POL_ANGLE  !<  ,
			TEST  !< used for development. ,
			UNSPECIFIED  !< Unspecified scan intent ,
			CALIBRATE_ANTENNA_POSITION  !< Requested by EVLA. ,
			CALIBRATE_ANTENNA_PHASE  !< Requested by EVLA. ,
			MEASURE_RFI  !< Requested by EVLA. ,
			CALIBRATE_ANTENNA_POINTING_MODEL  !< Requested by EVLA. ,
			SYSTEM_CONFIGURATION  !< Requested by EVLA. ,
			CALIBRATE_APPPHASE_ACTIVE  !< Calculate and apply phasing solutions. Applicable at ALMA. ,
			CALIBRATE_APPPHASE_PASSIVE  !< Apply previously obtained phasing solutions. Applicable at ALMA. ,
			OBSERVE_CHECK_SOURCE  !<  ,
			CALIBRATE_DIFFGAIN  !< Enable a gain differential target type 
		};
		
		typedef sequence<ScanIntent> SofScanIntent;
		typedef sequence<sequence<ScanIntent> > SofSofScanIntent;
		typedef sequence<sequence<sequence<ScanIntent> > > SofSofSofScanIntent;
	
	};


	/**
	*  A module to encapsulate the enumeration SchedulerMode.
	*/
	module SchedulerModeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration SchedulerMode : */
		/*!  [ASDM.SBSummary] Scheduler operation mode 
		 */
		
		enum SchedulerMode{
			DYNAMIC  !< Dynamic scheduling ,
			INTERACTIVE  !< Interactive scheduling ,
			MANUAL  !< Manual scheduling ,
			QUEUED  !< Queued scheduling 
		};
		
		typedef sequence<SchedulerMode> SofSchedulerMode;
		typedef sequence<sequence<SchedulerMode> > SofSofSchedulerMode;
		typedef sequence<sequence<sequence<SchedulerMode> > > SofSofSofSchedulerMode;
	
	};


	/**
	*  A module to encapsulate the enumeration SidebandProcessingMode.
	*/
	module SidebandProcessingModeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration SidebandProcessingMode : */
		/*!  [ASDM.SpectralWindow] Real-time processing to derive sideband data 
		 */
		
		enum SidebandProcessingMode{
			NONE  !< No processing ,
			PHASE_SWITCH_SEPARATION  !< Side band separation using 90-degree phase switching ,
			FREQUENCY_OFFSET_SEPARATION  !< Side band separation using offsets of first ans second oscillators ,
			PHASE_SWITCH_REJECTION  !< Side band rejection 90-degree phase switching ,
			FREQUENCY_OFFSET_REJECTION  !< Side band rejection using offsets of first and second oscillators 
		};
		
		typedef sequence<SidebandProcessingMode> SofSidebandProcessingMode;
		typedef sequence<sequence<SidebandProcessingMode> > SofSofSidebandProcessingMode;
		typedef sequence<sequence<sequence<SidebandProcessingMode> > > SofSofSofSidebandProcessingMode;
	
	};


	/**
	*  A module to encapsulate the enumeration SourceModel.
	*/
	module SourceModelMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration SourceModel : */
		/*!  [CalDM.CalFlux] Source Model 
		 */
		
		enum SourceModel{
			GAUSSIAN  !< Gaussian source ,
			POINT  !< Point Source ,
			DISK  !< Uniform Disk 
		};
		
		typedef sequence<SourceModel> SofSourceModel;
		typedef sequence<sequence<SourceModel> > SofSofSourceModel;
		typedef sequence<sequence<sequence<SourceModel> > > SofSofSofSourceModel;
	
	};


	/**
	*  A module to encapsulate the enumeration SpectralResolutionType.
	*/
	module SpectralResolutionTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration SpectralResolutionType : */
		/*!  [ASDM.SpectralWindow] The types of spectral resolutions for spectral windows. 
		 */
		
		enum SpectralResolutionType{
			CHANNEL_AVERAGE  !<  ,
			BASEBAND_WIDE  !<  ,
			FULL_RESOLUTION  !<  
		};
		
		typedef sequence<SpectralResolutionType> SofSpectralResolutionType;
		typedef sequence<sequence<SpectralResolutionType> > SofSofSpectralResolutionType;
		typedef sequence<sequence<sequence<SpectralResolutionType> > > SofSofSofSpectralResolutionType;
	
	};


	/**
	*  A module to encapsulate the enumeration StationType.
	*/
	module StationTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration StationType : */
		/*!  [ASDM.Station] Type of antenna station 
		 */
		
		enum StationType{
			ANTENNA_PAD  !< Astronomical Antenna station ,
			MAINTENANCE_PAD  !< Maintenance antenna station ,
			WEATHER_STATION  !< Weather station 
		};
		
		typedef sequence<StationType> SofStationType;
		typedef sequence<sequence<StationType> > SofSofStationType;
		typedef sequence<sequence<sequence<StationType> > > SofSofSofStationType;
	
	};


	/**
	*  A module to encapsulate the enumeration StokesParameter.
	*/
	module StokesParameterMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration StokesParameter : */
		/*!  Stokes parameters (CASA definition) 
		 */
		
		enum StokesParameter{
			I  !<  ,
			Q  !<  ,
			U  !<  ,
			V  !<  ,
			RR  !<  ,
			RL  !<  ,
			LR  !<  ,
			LL  !<  ,
			XX  !< Linear correlation product ,
			XY  !<  ,
			YX  !<  ,
			YY  !<  ,
			RX  !< Mixed correlation product ,
			RY  !< Mixed correlation product ,
			LX  !< Mixed LX product ,
			LY  !< Mixed LY correlation product ,
			XR  !< Mixed XR correlation product ,
			XL  !< Mixed XL correlation product ,
			YR  !< Mixed YR correlation product ,
			YL  !< Mixel YL correlation product ,
			PP  !<  ,
			PQ  !<  ,
			QP  !<  ,
			QQ  !<  ,
			RCIRCULAR  !<  ,
			LCIRCULAR  !<  ,
			LINEAR  !< single dish polarization type ,
			PTOTAL  !< Polarized intensity ((Q^2+U^2+V^2)^(1/2)) ,
			PLINEAR  !< Linearly Polarized intensity ((Q^2+U^2)^(1/2)) ,
			PFTOTAL  !< Polarization Fraction (Ptotal/I) ,
			PFLINEAR  !< Linear Polarization Fraction (Plinear/I) ,
			PANGLE  !< Linear Polarization Angle (0.5 arctan(U/Q)) (in radians) 
		};
		
		typedef sequence<StokesParameter> SofStokesParameter;
		typedef sequence<sequence<StokesParameter> > SofSofStokesParameter;
		typedef sequence<sequence<sequence<StokesParameter> > > SofSofSofStokesParameter;
	
	};


	/**
	*  A module to encapsulate the enumeration SubscanIntent.
	*/
	module SubscanIntentMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration SubscanIntent : */
		/*! [ASDM.Subscan] Precise the intent for a subscan 
		 */
		
		enum SubscanIntent{
			ON_SOURCE  !< on-source measurement ,
			OFF_SOURCE  !< off-source measurement ,
			MIXED  !< Pointing measurement, some antennas are on -ource, some off-source ,
			REFERENCE  !< reference measurement (used for boresight in holography). ,
			SCANNING  !< antennas are scanning. ,
			HOT  !< hot load measurement. ,
			AMBIENT  !< ambient load measurement. ,
			SIGNAL  !< Signal sideband measurement. ,
			IMAGE  !< Image sideband measurement. ,
			TEST  !< reserved for development. ,
			UNSPECIFIED  !< Unspecified 
		};
		
		typedef sequence<SubscanIntent> SofSubscanIntent;
		typedef sequence<sequence<SubscanIntent> > SofSofSubscanIntent;
		typedef sequence<sequence<sequence<SubscanIntent> > > SofSofSofSubscanIntent;
	
	};


	/**
	*  A module to encapsulate the enumeration SwitchingMode.
	*/
	module SwitchingModeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration SwitchingMode : */
		/*!  Switching modes: there are two categories of switching modes, those at high rate (chopper wheel, nutator and frequency switch) which involve the BIN axis and those at low  rate (frequency, position, load and phase switching) unrelated to the bin axis. Note that in case of  frequency switching mode it is the context which tells in which of these two categories it is used. 
		 */
		
		enum SwitchingMode{
			NO_SWITCHING  !< No switching ,
			LOAD_SWITCHING  !< Receiver beam is switched between sky and load ,
			POSITION_SWITCHING  !< Antenna (main reflector) pointing direction  is switched  ,
			PHASE_SWITCHING  !< 90 degrees phase switching  (switching mode used for sideband separation or rejection with DSB receivers) ,
			FREQUENCY_SWITCHING  !< LO frequency is switched (definition context sensitive: fast if cycle shrorter than the integration duration, slow if e.g. step one step per subscan) ,
			NUTATOR_SWITCHING  !< Switching between different directions by nutating the sub-reflector ,
			CHOPPER_WHEEL  !< Switching using a chopper wheel 
		};
		
		typedef sequence<SwitchingMode> SofSwitchingMode;
		typedef sequence<sequence<SwitchingMode> > SofSofSwitchingMode;
		typedef sequence<sequence<sequence<SwitchingMode> > > SofSofSofSwitchingMode;
	
	};


	/**
	*  A module to encapsulate the enumeration SynthProf.
	*/
	module SynthProfMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration SynthProf : */
		/*!  
		 */
		
		enum SynthProf{
			NOSYNTH  !<  ,
			ACACORR  !<  ,
			ACA_CDP  !<  
		};
		
		typedef sequence<SynthProf> SofSynthProf;
		typedef sequence<sequence<SynthProf> > SofSofSynthProf;
		typedef sequence<sequence<sequence<SynthProf> > > SofSofSofSynthProf;
	
	};


	/**
	*  A module to encapsulate the enumeration SyscalMethod.
	*/
	module SyscalMethodMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration SyscalMethod : */
		/*! [CalDM.CalAtmosphere] Atmosphere calibration methods  
		 */
		
		enum SyscalMethod{
			TEMPERATURE_SCALE  !< Use single direction data to compute ta* scale ,
			SKYDIP  !< Use a skydip (observing the sky at various elevations) to get atmospheric opacity ,
			SIDEBAND_RATIO  !< Measure the sideband gain ratio. 
		};
		
		typedef sequence<SyscalMethod> SofSyscalMethod;
		typedef sequence<sequence<SyscalMethod> > SofSofSyscalMethod;
		typedef sequence<sequence<sequence<SyscalMethod> > > SofSofSofSyscalMethod;
	
	};


	/**
	*  A module to encapsulate the enumeration TimeSampling.
	*/
	module TimeSamplingMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration TimeSampling : */
		/*! Time granularity for data 
		 */
		
		enum TimeSampling{
			SUBINTEGRATION  !< Part of an integration ,
			INTEGRATION  !< Part of a subscan. An integration may be composed of several sub-integrations. 
		};
		
		typedef sequence<TimeSampling> SofTimeSampling;
		typedef sequence<sequence<TimeSampling> > SofSofTimeSampling;
		typedef sequence<sequence<sequence<TimeSampling> > > SofSofSofTimeSampling;
	
	};


	/**
	*  A module to encapsulate the enumeration TimeScale.
	*/
	module TimeScaleMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration TimeScale : */
		/*! Time standards. 
		 */
		
		enum TimeScale{
			UTC  !< Coordinated Universal Time. ,
			TAI  !< International Atomic Time. 
		};
		
		typedef sequence<TimeScale> SofTimeScale;
		typedef sequence<sequence<TimeScale> > SofSofTimeScale;
		typedef sequence<sequence<sequence<TimeScale> > > SofSofSofTimeScale;
	
	};


	/**
	*  A module to encapsulate the enumeration WeightType.
	*/
	module WeightTypeMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration WeightType : */
		/*!  
		 */
		
		enum WeightType{
			K  !< Based on System temperature. ,
			JY  !< Based on Flux (include antenna efficiency). ,
			COUNT_WEIGHT  !< Square-root of the number of samples (i.e. sqrt(bandwidth * time)) 
		};
		
		typedef sequence<WeightType> SofWeightType;
		typedef sequence<sequence<WeightType> > SofSofWeightType;
		typedef sequence<sequence<sequence<WeightType> > > SofSofSofWeightType;
	
	};


	/**
	*  A module to encapsulate the enumeration WindowFunction.
	*/
	module WindowFunctionMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration WindowFunction : */
		/*! [APDM; ASDM.ALmaCorrelatorMode] Windowing functions for spectral data apodization  
		 */
		
		enum WindowFunction{
			UNIFORM  !< No windowing ,
			HANNING  !< Raised cosine: \f$0.5*(1-cos(x))\f$ where \f$x = 2*\pi*i/(N-1)\f$ ,
			HAMMING  !< The classic Hamming window is \f$W_M(x) = 0.54 - 0.46*\cos(x)\f$. This is generalized to \f$W_M(x) = \beta - (1-\beta)*\cos(x)\f$ where \f$\beta\f$ can take any value in the range \f$[0,1]\f$. \f$\beta=0.5\f$ corresponds to the Hanning window. ,
			BARTLETT  !< The Bartlett (triangular) window is \f$1 - |x/\pi|\f$, where \f$x = 2*\pi*i/(N-1)\f$. ,
			BLACKMANN  !< The window function is \f$W_B(x) = (0.5 - \beta) - 0.5*\cos(x_j) + \beta*\cos(2x_j)\f$, where \f$x_j=2*\pi*j/(N-1)\f$. The classic Blackman window is given by \f$\beta=0.08\f$. ,
			BLACKMANN_HARRIS  !< The BLACKMANN_HARRIS window is \f$1.0 - 1.36109*\cos(x) + 0.39381*\cos(2*x) - 0.032557*\cos(3*x)\f$, where \f$x = 2*\pi*i/(N-1)\f$. ,
			WELCH  !< The Welch window (parabolic) is \f$1 - (2*i/N)^2\f$. 
		};
		
		typedef sequence<WindowFunction> SofWindowFunction;
		typedef sequence<sequence<WindowFunction> > SofSofWindowFunction;
		typedef sequence<sequence<sequence<WindowFunction> > > SofSofSofWindowFunction;
	
	};


	/**
	*  A module to encapsulate the enumeration WVRMethod.
	*/
	module WVRMethodMod{
		
		const unsigned long version = 1; /*!< the major  version number of the enumeration. */
		const string revision = "1";  /*!< the revision identifier. */
		
		/*! Definition of enumeration WVRMethod : */
		/*! [CalDM.CalWVR] Methods for WVR Data processing in TelCal 
		 */
		
		enum WVRMethod{
			ATM_MODEL  !< WVR data reduction uses ATM model ,
			EMPIRICAL  !< WVR data reduction optimized using actual phase data 
		};
		
		typedef sequence<WVRMethod> SofWVRMethod;
		typedef sequence<sequence<WVRMethod> > SofSofWVRMethod;
		typedef sequence<sequence<sequence<WVRMethod> > > SofSofSofWVRMethod;
	
	};


	
#endif /* ALMA_DATA_MODEL_ENUMERATION_IDL */
